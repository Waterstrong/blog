<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Watersrong Blog</title>
  <subtitle>Enjoy this moment!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.waterstrong.me/"/>
  <updated>2016-06-11T13:30:06.000Z</updated>
  <id>http://blog.waterstrong.me/</id>
  
  <author>
    <name>Waterstrong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java单元和集成测试配置</title>
    <link href="http://blog.waterstrong.me/java-unit-intg-test/"/>
    <id>http://blog.waterstrong.me/java-unit-intg-test/</id>
    <published>2016-05-11T13:47:36.000Z</published>
    <updated>2016-06-11T13:30:06.000Z</updated>
    
    <content type="html">&lt;p&gt;基于Spring Boot搭建一个Java工程，通过Gradle进行构建，使用IntelliJ IDE开发，对于在&lt;code&gt;build.gradle&lt;/code&gt;中配置Integration Test和Unit Test有多种方式。接下来分别介绍两种方式:&lt;/p&gt;
&lt;p&gt;假设在IntelliJ中创建好如下Tree结构:&lt;br&gt;&lt;img src=&quot;/assets/java-unit-intg-test/java_project_tree.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;方法一-use-another-source-set&quot;&gt;&lt;a href=&quot;#方法一-use-another-source-set&quot; class=&quot;headerlink&quot; title=&quot;方法一: use another source set&quot;&gt;&lt;/a&gt;方法一: use another source set&lt;/h3&gt;&lt;p&gt;Add into the source sets&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sourceSets &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    main &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        java.srcDirs = [&amp;apos;src/main/java&amp;apos;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        resources.srcDirs = [&amp;apos;src/main/resources&amp;apos;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    test &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        java.srcDirs = [&amp;apos;src/test/unit/java&amp;apos;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        resources.srcDirs = [&amp;apos;src/test/unit/resources&amp;apos;, &amp;apos;src/test/intg/resources&amp;apos;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    integrationTest &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        java.srcDirs = [&amp;apos;src/test/intg/java&amp;apos;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Add into the idea intelliJ&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;idea &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    module &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        testSourceDirs += sourceSets.integrationTest.java.srcDirs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Apply the dependencies for integration test&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dependencies &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    compile(&amp;quot;org.springframework.boot:spring-boot-starter-web&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    compile(&amp;quot;org.springframework.boot:spring-boot-starter-data-jpa&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    testCompile(&amp;quot;com.jayway.jsonpath:json-path&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    testCompile(&amp;quot;org.springframework.boot:spring-boot-starter-test&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    integrationTestCompile sourceSets.main.output&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    integrationTestCompile sourceSets.test.output&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    integrationTestCompile configurations.testCompile&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    integrationTestRuntime configurations.testRuntime&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Create the unit and integrationTest tasks&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;task unitTest(dependsOn: test)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;task integrationTest(type: Test) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    testClassesDir = sourceSets.integrationTest.output.classesDir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    classpath = sourceSets.integrationTest.runtimeClasspath&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;build.dependsOn integrationTest&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;方法二-use-the-same-source-set-as-test&quot;&gt;&lt;a href=&quot;#方法二-use-the-same-source-set-as-test&quot; class=&quot;headerlink&quot; title=&quot;方法二: use the same source set as test&quot;&gt;&lt;/a&gt;方法二: use the same source set as test&lt;/h3&gt;&lt;p&gt;Add into the source sets&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sourceSets &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    main &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        java.srcDirs = [&amp;apos;src/main/java&amp;apos;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        resources.srcDirs = [&amp;apos;src/main/resources&amp;apos;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    test &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        java.srcDirs = [&amp;apos;src/test/unit/java&amp;apos;, &amp;apos;src/test/intg/java&amp;apos;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        resources.srcDirs = [&amp;apos;src/test/unit/resources&amp;apos;, &amp;apos;src/test/intg/resources&amp;apos;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Exclude the test classes &lt;code&gt;*IntegrationTest.class&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;test &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    exclude &amp;apos;**/*IntegrationTest.class&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Add the dependencies for test&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dependencies &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    compile(&amp;quot;org.springframework.boot:spring-boot-starter-web&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    compile(&amp;quot;org.springframework.boot:spring-boot-starter-data-jpa&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    testCompile(&amp;quot;com.jayway.jsonpath:json-path&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    testCompile(&amp;quot;org.springframework.boot:spring-boot-starter-test&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Create the unit and integrationTest tasks&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;task unitTest(dependsOn: test)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;task integrationTest(type: Test) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    include &amp;apos;**/*IntegrationTest.class&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;build.dependsOn integrationTest&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;集成测试实现DEMO&quot;&gt;&lt;a href=&quot;#集成测试实现DEMO&quot; class=&quot;headerlink&quot; title=&quot;集成测试实现DEMO&quot;&gt;&lt;/a&gt;集成测试实现DEMO&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@RunWith(SpringJUnit4ClassRunner.class)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@SpringApplicationConfiguration(classes = Application.class)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@WebAppConfiguration&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Transactional&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public abstract class ApplicationIntegrationTest &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    protected MockMvc mockMvc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class XXXControllerIntegrationTest extends ApplicationIntegrationTest &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Autowired&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private XXXController xxxController;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Autowired&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private XXXRepository xxxRepository;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Before&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void setUp() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mockMvc = MockMvcBuilders.standaloneSetup(xxxController).build();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Test&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void should_get_xxxs_by_book_xxx() throws Exception &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        xxxRepository.save(new XXX(&amp;quot;123456&amp;quot;, &amp;quot;This is a integ test&amp;quot;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mockMvc.perform(get(format(&amp;quot;/xxx/%s/yyys&amp;quot;, vvv)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .andExpect(status().isOk())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .andExpect(jsonPath(&amp;quot;$&amp;quot;, hasSize(1)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .andExpect(jsonPath(&amp;quot;$[0].uuid&amp;quot;).value(&amp;quot;123456&amp;quot;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .andExpect(jsonPath(&amp;quot;$[0].content&amp;quot;).value(&amp;quot;This is a integ test&amp;quot;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;单元测试实现DEMO&quot;&gt;&lt;a href=&quot;#单元测试实现DEMO&quot; class=&quot;headerlink&quot; title=&quot;单元测试实现DEMO&quot;&gt;&lt;/a&gt;单元测试实现DEMO&lt;/h3&gt;&lt;p&gt;单元测试采用JUnit和Mockito测试框架实现.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class DefaultXxxServiceTest &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @InjectMocks&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private DefaultXxxService xxxService;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Mock&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private XxxRepository xxxRepository;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Before&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void setUp() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MockitoAnnotations.initMocks(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Test&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void should_retrieve_xxxs_by_yyy_uuid() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String yyyUuid = &amp;quot;book123456&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;Xxx&amp;gt; expectedXxxs = asList(new Xxx(), new Xxx());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        when(xxxRepository.findByYyy(yyyUuid)).thenReturn(expectedXxxs);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Iterable&amp;lt;Xxx&amp;gt; xxxs = xxxService.retrieveXxxs(yyyUuid);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        assertThat(xxxs, is(expectedXxxs));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Run-unit-test&quot;&gt;&lt;a href=&quot;#Run-unit-test&quot; class=&quot;headerlink&quot; title=&quot;Run unit test&quot;&gt;&lt;/a&gt;Run unit test&lt;/h3&gt;&lt;p&gt;&lt;code&gt;./gradlew test&lt;/code&gt;, it depends on &lt;code&gt;build&lt;/code&gt; task.&lt;/p&gt;
&lt;h3 id=&quot;Run-integration-test&quot;&gt;&lt;a href=&quot;#Run-integration-test&quot; class=&quot;headerlink&quot; title=&quot;Run integration test&quot;&gt;&lt;/a&gt;Run integration test&lt;/h3&gt;&lt;p&gt;&lt;code&gt;./gradlew integrationTest&lt;/code&gt; or &lt;code&gt;./gradlew iT&lt;/code&gt;, it depends on &lt;code&gt;build&lt;/code&gt; task.&lt;/p&gt;
&lt;h3 id=&quot;Run-build-exclude-integration-test&quot;&gt;&lt;a href=&quot;#Run-build-exclude-integration-test&quot; class=&quot;headerlink&quot; title=&quot;Run build exclude integration test&quot;&gt;&lt;/a&gt;Run build exclude integration test&lt;/h3&gt;&lt;p&gt;&lt;code&gt;./gradlew build -x integrationTest&lt;/code&gt; or &lt;code&gt;./gradlew build -x iT&lt;/code&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      基于Spring Boot搭建一个Java工程，通过Gradle进行构建，使用IntelliJ IDE开发，对于在`build.gradle`中配置Integration Test和Unit Test有多种方式。
    
    </summary>
    
      <category term="Frameworks" scheme="http://blog.waterstrong.me/categories/Frameworks/"/>
    
    
      <category term="Java" scheme="http://blog.waterstrong.me/tags/Java/"/>
    
      <category term="Spring Boot" scheme="http://blog.waterstrong.me/tags/Spring-Boot/"/>
    
      <category term="Gradle" scheme="http://blog.waterstrong.me/tags/Gradle/"/>
    
      <category term="IntelliJ" scheme="http://blog.waterstrong.me/tags/IntelliJ/"/>
    
      <category term="Unit Test" scheme="http://blog.waterstrong.me/tags/Unit-Test/"/>
    
      <category term="Integration Test" scheme="http://blog.waterstrong.me/tags/Integration-Test/"/>
    
  </entry>
  
  <entry>
    <title>JBoss Tips in Practice</title>
    <link href="http://blog.waterstrong.me/jboss-tips/"/>
    <id>http://blog.waterstrong.me/jboss-tips/</id>
    <published>2016-04-20T14:23:50.000Z</published>
    <updated>2016-06-12T15:25:05.000Z</updated>
    
    <content type="html">&lt;p&gt;JBoss是众多Java EE容器中的一个，它不但是Servlet容器，而且是EJB容器，弥补了Tomcat只是一个Servlet容器的缺憾。为了实现一些特定的功能, 需要针对JBoss的一些配置, 以下列出一些Tips供使用参考。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Tip1-IP-域名黑白名单&quot;&gt;&lt;a href=&quot;#Tip1-IP-域名黑白名单&quot; class=&quot;headerlink&quot; title=&quot;Tip1: IP/域名黑白名单&quot;&gt;&lt;/a&gt;Tip1: IP/域名黑白名单&lt;/h2&gt;&lt;p&gt;针对JBoss EAP5，为了实现Web容器级别的IP/域名黑白名单，需要到JBoss的server.xml文件中配置相应Valve规则并重启JBoss后生效。&lt;/p&gt;
&lt;p&gt;在文件&lt;code&gt;jboss-as/server/&amp;lt;instance_name&amp;gt;/deploy/jbossweb.sar/server.xml&lt;/code&gt;中的&lt;code&gt;&amp;lt;Host&amp;gt;&amp;lt;/Host&amp;gt;&lt;/code&gt;内添加如下配置:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;Engine&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;Host&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;Valve className=&amp;apos;org.apache.catalina.valves.RemoteAddrValve&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        allow=&amp;apos;192.168.[0-1].*, *.testing.com&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        deny=&amp;apos;127.0.0.1&amp;apos;/&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/Host&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/Engine&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;allow&lt;/code&gt;表明允许的IP地址正则表达式，&lt;code&gt;deny&lt;/code&gt;表明拒绝的IP地址正则表达式，特别注意的是逗号(&lt;code&gt;,&lt;/code&gt;)会被解析成&lt;code&gt;或&lt;/code&gt;，因此IP Regex中一定不要包含&lt;code&gt;逗号&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当然，除了可以设置服务器级别&lt;code&gt;server-level&lt;/code&gt;，也可以设置应用层级别&lt;code&gt;application-level&lt;/code&gt;，更多关于Web Server的配置可参见&lt;a href=&quot;http://www.datadisk.co.uk/html_docs/java_app/jboss5/jboss5_web_server.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Configuring the Web Server&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外补充一下Valve的相关解释:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Valves are similar to filters, they can intercept any incoming and outgoing request. Valves are managed by the Engine, they access incoming/outgoing requests before they are handled by the servlet and JSP processing logic. Logically they can also be applied on a virtual host or web application basis.&lt;br&gt;Valves can add the following functionality:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Access logging&lt;/li&gt;
&lt;li&gt;Single sign-on for all Web applications&lt;/li&gt;
&lt;li&gt;Request filtering/blocking by IP address and or hostname&lt;/li&gt;
&lt;li&gt;Dumping of incoming/outgoing request headers for debugging purposes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Valves are nested components in the component model, they use the &lt;valve&gt; XML element in the server.xml file, they can be placed in the &lt;engine&gt;, &lt;host&gt; or &lt;context&gt; containers. The Java programming interface org.apache.catalina.Valve is used and well documented.&lt;/context&gt;&lt;/host&gt;&lt;/engine&gt;&lt;/valve&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想了解更多其他内容及详细解释请参见&lt;a href=&quot;http://www.datadisk.co.uk/html_docs/java_app/tomcat6/tomcat6_advanced.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Advanced Tomcat Features&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Tip2-自动清除work目录&quot;&gt;&lt;a href=&quot;#Tip2-自动清除work目录&quot; class=&quot;headerlink&quot; title=&quot;Tip2: 自动清除work目录&quot;&gt;&lt;/a&gt;Tip2: 自动清除work目录&lt;/h2&gt;&lt;p&gt;针对JBoss EAP5:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The work directory:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Directory where compiled JSP .java and .class files reside&lt;/li&gt;
&lt;li&gt;Also contains cached TLDs&lt;/li&gt;
&lt;li&gt;Very useful for debugging problems in JSPs&lt;br&gt;Java ServerPages (.jsp files) are automatically compiled into Java Servlets (.java file) and then into Java byte-code (.class files) by Tomcat (the embedded servlet engine running within JBoss AS).&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;JBoss中的work目录是工作目录，即把jsp转换为class文件的工作目录, 其工作原理是当浏览器访问某个jsp页面时，JBoss会在work目录里把这个jsp页面转换成.java文件，然后编译为.class文件，最后容器通过ClassLoader类把这个.class类装载入内存，进行响应客户端的工作。&lt;/p&gt;
&lt;p&gt;通常情况下会定时检查容器内的jsp文件，读取每个文件的属性，当发现某个jsp文件发生改变时(文件的最后修改时间与上次检查时不相同)，容器会重新转换、编译这个jsp文件, 但是检查是定时的不是实时的，因此jsp文件修改后需要几分钟的时间来等修改过的jsp生效。为了即刻生效，通常的做法是重启JBoss之前或在修改jsp页面后立即清除work目录里的文件。&lt;/p&gt;
&lt;p&gt;一般情况下, 当停止JBoss服务时对work目录进行一次清理, 最简单快速的做法就是在JBoss相应的目录下配置自动清理选项:&lt;br&gt;修改文件&lt;code&gt;jboss-as/server/&amp;lt;instance_name&amp;gt;/deployers/jbossweb.deployer/META-INF/war-deployers-jboss-beans.xml&lt;/code&gt;中的:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!--Flag to delete the Work Dir on Context Destroy --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;property name=&amp;quot;deleteWorkDirOnContextDestroy&amp;quot;&amp;gt;false&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;为&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!--Flag to delete the Work Dir on Context Destroy --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;property name=&amp;quot;deleteWorkDirOnContextDestroy&amp;quot;&amp;gt;true&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
</content>
    
    <summary type="html">
    
      JBoss是众多Java EE容器中的一个，它不但是Servlet容器，而且是EJB容器，弥补了Tomcat只是一个Servlet容器的缺憾。为了实现一些特定的功能, 需要针对JBoss的一些配置, 将列出一些Tips供使用参考。
    
    </summary>
    
      <category term="Frameworks" scheme="http://blog.waterstrong.me/categories/Frameworks/"/>
    
    
      <category term="Java" scheme="http://blog.waterstrong.me/tags/Java/"/>
    
      <category term="Web容器" scheme="http://blog.waterstrong.me/tags/Web%E5%AE%B9%E5%99%A8/"/>
    
      <category term="JBoss" scheme="http://blog.waterstrong.me/tags/JBoss/"/>
    
      <category term="EJB" scheme="http://blog.waterstrong.me/tags/EJB/"/>
    
      <category term="Servlet" scheme="http://blog.waterstrong.me/tags/Servlet/"/>
    
      <category term="JSP" scheme="http://blog.waterstrong.me/tags/JSP/"/>
    
  </entry>
  
  <entry>
    <title>Concourse CI 介绍</title>
    <link href="http://blog.waterstrong.me/concourse-ci/"/>
    <id>http://blog.waterstrong.me/concourse-ci/</id>
    <published>2016-04-19T05:02:02.000Z</published>
    <updated>2016-06-11T13:29:32.000Z</updated>
    
    <content type="html">&lt;p&gt;目前主流的CI/CD工具包括Concourse CI, Jenkins, Travis CI和GoCD，它们各自到底有什么优缺点，Concourse CI有什么优势和亮点能够跻身April ‘16的&lt;a href=&quot;https://www.thoughtworks.com/radar/tools/concourse-ci&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ThoughtWorks Tech Radar&lt;/a&gt;？&lt;/p&gt;
&lt;h3 id=&quot;Advantages-of-CI-CD&quot;&gt;&lt;a href=&quot;#Advantages-of-CI-CD&quot; class=&quot;headerlink&quot; title=&quot;Advantages of CI/CD&quot;&gt;&lt;/a&gt;Advantages of CI/CD&lt;/h3&gt;&lt;p&gt;首先还是快速介绍一下CI/CD，特别是为什么要采用CI/CD，有什么样的优势，只有在有意义的前提下，使用工具才能发挥作用，并且解决项目开发中的痛点问题。&lt;/p&gt;
&lt;h4 id=&quot;Continuous-Integration&quot;&gt;&lt;a href=&quot;#Continuous-Integration&quot; class=&quot;headerlink&quot; title=&quot;Continuous Integration&quot;&gt;&lt;/a&gt;Continuous Integration&lt;/h4&gt;&lt;p&gt;Continuous Integration(持续集成). Integrating, building, and testing code within the development environment.&lt;/p&gt;
&lt;h4 id=&quot;Continuous-Delivery&quot;&gt;&lt;a href=&quot;#Continuous-Delivery&quot; class=&quot;headerlink&quot; title=&quot;Continuous Delivery&quot;&gt;&lt;/a&gt;Continuous Delivery&lt;/h4&gt;&lt;p&gt;Continuous Delivery(持续交付). A software development discipline, build software that can be released to production at any time.&lt;/p&gt;
&lt;h4 id=&quot;CI-CD的好处&quot;&gt;&lt;a href=&quot;#CI-CD的好处&quot; class=&quot;headerlink&quot; title=&quot;CI/CD的好处&quot;&gt;&lt;/a&gt;CI/CD的好处&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;Reduced Deployment Risk，降低部署风险。快速提交小部分修改进行部署和集成，从而降低了出现错误的概率，即使出现错误也能快速定位问题并修复。&lt;/li&gt;
&lt;li&gt;Believable Progress，可信的进度。如果直接部署到线上环境中，项目进展以及完成度相对于开发人员自己声称已经完成要更加的有可信度。&lt;/li&gt;
&lt;li&gt;User Feedback，用户反馈。众所周知，项目开发中最大的风险就是开发的软件不被用户接受，这样的软件是没有太大的用处和意义的，尽早和更加频繁地交付给用户并且快速获得用户反馈来获取有价值的内容，从而保证了开发的软件是被用户接受的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有关CI/CD的更多详细解释可以参见Martin Fowler博客文章&lt;a href=&quot;http://martinfowler.com/bliki/ContinuousDelivery.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Continuous Delivery&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;What-is-Concourse&quot;&gt;&lt;a href=&quot;#What-is-Concourse&quot; class=&quot;headerlink&quot; title=&quot;What is Concourse?&quot;&gt;&lt;/a&gt;What is Concourse?&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://concourse.ci&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Concourse&lt;/a&gt; is a &lt;code&gt;CI/CD tool&lt;/code&gt; that treats &lt;code&gt;build pipelines and artifacts as first-class citizens&lt;/code&gt;.&lt;br&gt;It enables builds that &lt;code&gt;run in containers&lt;/code&gt;, has a &lt;code&gt;clean, usable UI and discourages snowflake&lt;/code&gt; build servers.&lt;br&gt;It aims to provide an &lt;code&gt;expressive system&lt;/code&gt; with as &lt;code&gt;few distinct moving parts&lt;/code&gt; as possible.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先感受一下Concourse的界面，这是Concourse项目本身的Pipelines:&lt;br&gt;&lt;img src=&quot;/assets/concourse-ci/concourse_pipeline.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Concourse CI是一款CI/CD工具，把构建pipeline和artifacts当作first-class citizens(可译作: 第一类公民)。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;First-class Citizens:&lt;/strong&gt; In programming language design, a first-class citizen (also type, object, entity, or value) in a given programming language is an entity which supports all the operations generally available to other entities. These operations typically include being passed as an argument, returned from a function, and assigned to a variable.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;第一类公民：&lt;/em&gt; 即支持其他实体所有操作的实体，比如能够在运行时被动态创建，能够作为参数或返回值直接被其他实体消费或生成。举个例子，在C语言中，function就不是第一类公民，而在Javascript中function是第一类公民。其中，实体是指各种各样的数据类型和值，比如对象、类、函数、字面量等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Concourse CI本身就与容器结合，Build构建在容器中运行，隔离各个环境，避免不同环境之间相互污染情况发生。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表现系统意味着有更简洁清晰可用的UI，而尽量少的移动部件意味着模块组件统一化，并且不会有雪花式的配置，Concourse CI采用YAML文件配置Pipeline，并且通过版本控制管理起来，很容易地实现移植和恢复。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下图中展示了一个标准的Pipeline示例，其中的黑色框元素代表资源(Resources)，彩色框元素代表Jobs，会有不同的颜色代表Build的状态，流线代表了依赖和执行顺序，如Integration需要前面所有的Jobs执行成功并且提供相关Resources才能正确触发并执行。&lt;br&gt;&lt;img src=&quot;/assets/concourse-ci/standard_pipeline_demo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对Jobs简单的YML配置示例:&lt;br&gt;&lt;img src=&quot;/assets/concourse-ci/config_yml_demo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Why-is-Concourse&quot;&gt;&lt;a href=&quot;#Why-is-Concourse&quot; class=&quot;headerlink&quot; title=&quot;Why is Concourse?&quot;&gt;&lt;/a&gt;Why is Concourse?&lt;/h3&gt;&lt;p&gt;为什么会出现Concourse呢？它能带来什么新思路呢？相比目前已有的CI/CD工具有什么区别呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Requires a CI/CD Tool, 首先当然是提供CI/CD的基本功能，需要一款CI/CD工具来解决项目开发中的一系列问题。&lt;/li&gt;
&lt;li&gt;Concourse vs GoCD/Jenkins/Travis CI，除此之外，还需要弥补目前CI/CD工具的一些不足，并加入一些新元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;vs-GoCD&quot;&gt;&lt;a href=&quot;#vs-GoCD&quot; class=&quot;headerlink&quot; title=&quot;vs. GoCD&quot;&gt;&lt;/a&gt;vs. GoCD&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/assets/concourse-ci/gocd_pipelines.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.go.cd/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GoCD&lt;/a&gt;属于老大级的，需要安装Server和Agent，其设计之初就是为了满足CI/CD的需求，把Build Pipelines和Artifacts作为First-class Citizens，因此也更好地支持自动化和流线式的build-test-release这样的CI/CD周期运作，同时，也支持更加复杂的工作流(Workflows)，包括并行和串行的，即使是很复杂的工作流也同样可以非常清晰直观地展示出来。&lt;/p&gt;
&lt;p&gt;除此之外，当然GoCD还有很多其他的优点，并且目前项目组也在使用。但是美中不足是GoCD配置操作的GUI很不人性化，使用过的人都知道，查看Jobs运行情况与配置Jobs的切换很麻烦，需要到首页分别点击Pipelines和Settings，而且每一项菜单层级很深，操作不友好，GoCD在架构设计上分为Pipelines -&amp;gt; Stages -&amp;gt; jobs -&amp;gt; tasks，层级嵌套显得有些复杂，不过这样的划分还好，只要操作上更加人性化就可以了。&lt;/p&gt;
&lt;p&gt;而Concourse针对GUI这一点进行了一些改进，并且引入了一种YML文件配置机制来实现对Job的配置，同样支持复杂的Workflow，也将Build Pipelines和Artifacts作为First-class Citizens，并且设计之初本身就与容器技术结合，每个Build都在Container中运行。&lt;/p&gt;
&lt;h4 id=&quot;vs-Jenkins&quot;&gt;&lt;a href=&quot;#vs-Jenkins&quot; class=&quot;headerlink&quot; title=&quot;vs. Jenkins&quot;&gt;&lt;/a&gt;vs. Jenkins&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/assets/concourse-ci/jenkins_dashboard.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/assets/concourse-ci/jenkins_plugins.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jenkins.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jenkins&lt;/a&gt;作为使用最广泛，用户量最大的CI工具，必定有其可取之处，无论是在GUI操作上，插件生态系统管理，稳定性、可靠性、功能性以及扩展性等方面都表现得很出色，而且简单易学，入门上手快，当然Jenkins的优势还有很多，之前的项目上都一直在使用Jenkins，对于大多项目来说是完全满足条件的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;但Jenkins也有其缺点，比如：&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在配置Shell命令时，如果Pipeline规模扩大，构建和部署环境增多，那么就会复制粘贴很多这样的Shell命令，称为雪花式(Snowflakes)配置，增加维护成本；&lt;/li&gt;
&lt;li&gt;另外，Jenkins定义Job的顺序是以Job为关注点，从全局出发，比如定义A Job的前置Job是B，后置Job是C，当Jobs顺序情况变得复杂就很难再梳理清楚了；&lt;/li&gt;
&lt;li&gt;Jenkins并未将Build Pipelines和Artifacts视作First-class Citizens，如果需要实现Continuous Delivery是需要借助插件完成，而Jenkins本身并不直接支持CD的；&lt;/li&gt;
&lt;li&gt;此外，虽然Jenkins的插件生态系统管理得很好，一旦Workspace中有很多的插件，难免会造成一些插件问题导致Build环境被污染。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;针对Jenkins的一些问题，Concourse进行了一些改进，比如：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Snowflakes的情况就采用统一配置YML文件来解决，各Task各工程自己维护，有重复的内容通过提取文件多处引用即可；&lt;/li&gt;
&lt;li&gt;通过VCS将这样配置文件进行版本控制管理，在恢复或移植时更加方便，虽然Jenkins和GoCD也有XML配置文件，但通常用于备份，一般的做法也不会进行版本控制，更不会直接去修改文件来实现Pipeline配置；&lt;/li&gt;
&lt;li&gt;Concourse对于每个Job只定义有效的输入，即哪个Job在什么情况下输出的什么的资源是可以触发当前Job的，即使复杂的Pipeline顺序出现时，配置也很方便，每个Job只关心自己的有效输入，局部优化达到了全局优化，不会造成混乱的感觉；&lt;/li&gt;
&lt;li&gt;特别指出的是Concourse的每一个Job构建都在独立的Container中Build，对其他的环境没有影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;vs-Travis-CI&quot;&gt;&lt;a href=&quot;#vs-Travis-CI&quot; class=&quot;headerlink&quot; title=&quot;vs. Travis CI&quot;&gt;&lt;/a&gt;vs. Travis CI&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://travis-ci.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Travis CI&lt;/a&gt;其实各方面也都挺不错的，没有Snowflake配置，使用.travis.yml文件配置，在容器中运行Builds，与Github集成度很好，支持PR。&lt;/p&gt;
&lt;p&gt;但是也有一些缺点：如它不支持pipeline，只能支持简单的构建; 并且如果CI跑不过，需要设置多个Debug提交点来找到问题所在; 另外Travis CI是由个人发起的项目，并且目前只对开源软件免费。&lt;/p&gt;
&lt;p&gt;总体说来，对于公司的项目，更倾向于选择GoCD或Jenkins这样的产品，个人的开源项目倒是可以通过Travis CI快速搭建来感受一下。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Concourse-Concepts&quot;&gt;&lt;a href=&quot;#Concourse-Concepts&quot; class=&quot;headerlink&quot; title=&quot;Concourse Concepts&quot;&gt;&lt;/a&gt;Concourse Concepts&lt;/h3&gt;&lt;p&gt;Concourse的核心概念: resources, jobs, tasks. 通过这三个核心模块可以对任何的Pipeline进行建模，从简单的unit-&amp;gt;integration-&amp;gt;deploy-&amp;gt;ship到复杂的多基础设施, fanning out/in等。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Resources: 就是资源，最重要的概念之一，Concourse把需要交互的对象都视作一种资源，比如Github上的某个工程代码，AWS的S3存储，以及其他的外部服务等。更多资源类型可参见&lt;a href=&quot;http://concourse.ci/resource-types.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Customer Resource Types&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/assets/concourse-ci/concourse_resources.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Jobs: Job是某个有计划有条件的工作任务，描述了一些依赖资源或手动触发的行为，当提交了代码就触发Build，或Unit Test通过后触发了Intg Test等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Tasks: Task就是在隔离环境中依赖于资源的某个脚本执行，如build, test等，Job其实封装了Task，Job更侧重于描述什么情况下发生，而Task重点描述发生什么。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Concourse-Architecture&quot;&gt;&lt;a href=&quot;#Concourse-Architecture&quot; class=&quot;headerlink&quot; title=&quot;Concourse Architecture&quot;&gt;&lt;/a&gt;Concourse Architecture&lt;/h3&gt;&lt;p&gt;Concourse架构属于一种简单的分布式系统，其三大核心部件分别为: &lt;code&gt;ATC&lt;/code&gt;, &lt;code&gt;TSA&lt;/code&gt;和&lt;code&gt;Workers&lt;/code&gt;，接下来将分别进行介绍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/concourse-ci/architecture.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;ATC-web-UI-amp-build-scheduler&quot;&gt;&lt;a href=&quot;#ATC-web-UI-amp-build-scheduler&quot; class=&quot;headerlink&quot; title=&quot;ATC: web UI &amp;amp; build scheduler&quot;&gt;&lt;/a&gt;ATC: web UI &amp;amp; build scheduler&lt;/h4&gt;&lt;p&gt;ATC主要用于运行Web UI和API以及所有Pipeline构建计划的，属于Concourse的心脏，占据了极其重要的位置。采用PostgreSQL数据库存储Pipeline数据和构建日志。&lt;/p&gt;
&lt;p&gt;多个ATCs可以作为一个集群运行，各个ATC都共享一个数据库，ATC通过加锁机制在集群之间同步与传输数据。&lt;/p&gt;
&lt;p&gt;ATC默认监听&lt;code&gt;8080&lt;/code&gt;端口，通常与&lt;code&gt;TSA&lt;/code&gt;一起处于负载均衡(Load Balancer)之后，为了实现正常拦截(&lt;a href=&quot;http://concourse.ci/fly-intercept.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Intercept&lt;/a&gt;)构建(Build)的功能，需要确保Load Balancer被正确配置到了TCP或SSL转发，而非HTTP或HTTPS。&lt;/p&gt;
&lt;h4 id=&quot;TSA-worker-registration-amp-forwarding&quot;&gt;&lt;a href=&quot;#TSA-worker-registration-amp-forwarding&quot; class=&quot;headerlink&quot; title=&quot;TSA: worker registration &amp;amp; forwarding&quot;&gt;&lt;/a&gt;TSA: worker registration &amp;amp; forwarding&lt;/h4&gt;&lt;p&gt;TSA是&lt;code&gt;ATC&lt;/code&gt;定制的SSH服务器，仅用于安全地注册&lt;code&gt;Workers&lt;/code&gt;，仅支持两个命令&lt;code&gt;register-worker&lt;/code&gt;和&lt;code&gt;forward-worker&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;register-worker命令用于为ATC直接注册在同一私有网络中运行的worker。&lt;/li&gt;
&lt;li&gt;forward-worker命令用于通过TSA反向隧道worker的地址，然后为ATC注册转发连接。这样只要workers能够连接到TSA，就可以运行在任意网络且安全地实现注册功能，ATC也就可以安全地连接到worker，该方式把worker与外界环境进行隔离，只有通过授权后才能访问，从而提高了其安全性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TSA默认监听&lt;code&gt;2222&lt;/code&gt;端口，通常与ATC协同工作运行在Load Balancer的之后。&lt;/p&gt;
&lt;h4 id=&quot;Workers-container-runtime-amp-cache-management&quot;&gt;&lt;a href=&quot;#Workers-container-runtime-amp-cache-management&quot; class=&quot;headerlink&quot; title=&quot;Workers: container runtime &amp;amp; cache management&quot;&gt;&lt;/a&gt;Workers: container runtime &amp;amp; cache management&lt;/h4&gt;&lt;p&gt;Workers可以认为是一台通过&lt;code&gt;TSA&lt;/code&gt;进行自注册的正在运行&lt;a href=&quot;https://github.com/cloudfoundry-incubator/garden&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Garden&lt;/a&gt;和&lt;a href=&quot;https://github.com/concourse/baggageclaim&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Baggageclaim&lt;/a&gt;服务的机器。&lt;/p&gt;
&lt;p&gt;Workers在自己所属机器上并没有配置重要的状态什么的，所有的内容都运行在容器中，更不需要关心相关依赖包安装到主机上在，这就是workers区别于其他非容器化(non-containerized)的CI解决方案，特别是当workers中的依赖包的状态成为了pipeline正常工作与否的关键因素，容器化显得尤为重要。&lt;/p&gt;
&lt;p&gt;每一个worker通过TSA注册自己，从而可以被Concourse集群发现并使用。Workers中的&lt;code&gt;Garden&lt;/code&gt;默认监听&lt;code&gt;7777&lt;/code&gt;端口，&lt;code&gt;Baggageclaim&lt;/code&gt;默认监听&lt;code&gt;7788&lt;/code&gt;端口。如果都在&lt;code&gt;ATC&lt;/code&gt;可达的同一个私有网络中，那么workers会绑定到所有地址&lt;code&gt;0.0.0.0&lt;/code&gt;，并且会直接注册自己，否则会绑定到&lt;code&gt;127.0.0.1&lt;/code&gt;，通过&lt;code&gt;TSA&lt;/code&gt;进行转发。&lt;/p&gt;
&lt;p&gt;以上就是Concourse的架构，更多细节可以参见&lt;a href=&quot;http://concourse.ci/architecture.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Concourse Architecture&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Concourse-Impacts&quot;&gt;&lt;a href=&quot;#Concourse-Impacts&quot; class=&quot;headerlink&quot; title=&quot;Concourse Impacts&quot;&gt;&lt;/a&gt;Concourse Impacts&lt;/h3&gt;&lt;p&gt;之所以要介绍Concourse，是因为Concourse带了一些新思路和想法，提供了另一个看待CI/CD的视角。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pluggable Resource Interface: 把操作对象看待资源，提供对资源访问的可接口，达到松耦合的目的&lt;/li&gt;
&lt;li&gt;Running builds in Containers Natively: 本身就支持在容器中运行构建，隔离不同环境&lt;/li&gt;
&lt;li&gt;Zero Snowflake-able Configuration: 没有雪花式的配置，可以重用相同的配置，通过版本控制管理，快速恢复和移植&lt;/li&gt;
&lt;li&gt;Submitting builds from the local file system up to run in CI: 通过本地配置文件提交构建到CI中运行，每个项目单独管理Build，降低维护成本&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cloudfoundry.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Cloud Foundry&lt;/a&gt;: Run on diff architectures, diff platforms, against varying underlying IaaSs: Cloud Foundry是一款PaaS平台即服务产品，为了解决Cloud Foundry的CI/CD问题才开发出Concourse，些类项目需要运行在不同的架构，不同的平台以及不同的基础设施中，因此Pipeline会相当复杂，而Concourse在配置这样复杂的Pipeline的时候表现得更加令人满意。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总得来说，Concourse带来了新的思路，并且与当下流行的Container技术结合，同样在支持PaaS项目的CI/CD时显得略胜一筹。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Using-Concourse&quot;&gt;&lt;a href=&quot;#Using-Concourse&quot; class=&quot;headerlink&quot; title=&quot;Using Concourse&quot;&gt;&lt;/a&gt;Using Concourse&lt;/h3&gt;&lt;p&gt;使用Concourse不会过多作介绍，后续会有专门针对如何使用Concourse的详细教程，本博客中只简单介绍一下流程:&lt;/p&gt;
&lt;h4 id=&quot;Step1-Install-and-Setup&quot;&gt;&lt;a href=&quot;#Step1-Install-and-Setup&quot; class=&quot;headerlink&quot; title=&quot;Step1. Install and Setup&quot;&gt;&lt;/a&gt;Step1. Install and Setup&lt;/h4&gt;&lt;p&gt;通常安装和运行Concourse有三种方式，任选一种方式尝试安装并启动：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Local VM with Vagrant&lt;/li&gt;
&lt;li&gt;Standalone Binaries&lt;/li&gt;
&lt;li&gt;Clusters with BOSH&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先我们在本地采用最快捷的Vagrant方式安装，运行以下命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vagrant init concourse/lite  # creates ./Vagrantfile&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vagrant up  # downloads the box and spins up the VM&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后Concourse服务已经开始运行了，通过&lt;a href=&quot;http://192.168.100.4:8080&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;192.168.100.4:8080&lt;/a&gt;地址进行访问。&lt;br&gt;&lt;img src=&quot;/assets/concourse-ci/no_pipeline.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果提示需要更新升级，可以尝试运行以下命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vagrant box update --box concourse/lite # gets the newest Vagrant box&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vagrant destroy                         # remove the old Vagrant box&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vagrant up                              # re-create the machine with the newer box&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但针对线上环境，不推荐Vagrant方式安装，Vagrant用于学习目的，快速掌握Concourse工作方式还是不错的选择，如果针对线上产品的项目，可以尝试采用后两种方式安装，更多安装介绍请参见&lt;a href=&quot;http://concourse.ci/installing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Concourse Installing&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;当安装Concourse完成后，还需要在本地下载&lt;a href=&quot;http://concourse.ci/fly-cli.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;the Fly CLI&lt;/a&gt;. 也可以访问Concourse主界面，然后点击Fly CLI链接进入下载页。&lt;/p&gt;
&lt;p&gt;针对Linux和Mac OS X系统，首先需要给下载的FLY CLI文件添加执行权限，然后安装到系统并添加到$PATH中：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;chmod +x fly&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;install fly /usr/local/bin/fly&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;Step2-Using-yml-to-describe-pipeline&quot;&gt;&lt;a href=&quot;#Step2-Using-yml-to-describe-pipeline&quot; class=&quot;headerlink&quot; title=&quot;Step2. Using *.yml to describe pipeline&quot;&gt;&lt;/a&gt;Step2. Using *.yml to describe pipeline&lt;/h4&gt;&lt;p&gt;为了创建一个Pipeline，首先在创建名为&lt;code&gt;hello.yml&lt;/code&gt;的文件，并写入以下内容:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;jobs:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- name: hello-world&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  plan:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - task: say-hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    config:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      platform: linux&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      image_resource:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        type: docker-image&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        source: &amp;#123;repository: ubuntu&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      run:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        path: echo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        args: [&amp;quot;Hello, world!&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;关于定义Pipeline的更多内容可参见&lt;a href=&quot;http://concourse.ci/pipelines.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pipelines&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;Step3-Push-to-Concourse&quot;&gt;&lt;a href=&quot;#Step3-Push-to-Concourse&quot; class=&quot;headerlink&quot; title=&quot;Step3. Push to Concourse&quot;&gt;&lt;/a&gt;Step3. Push to Concourse&lt;/h4&gt;&lt;p&gt;如果使用的是Vagrant安装方式，我们可以尝试登录到本地VirutalBox中：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fly -t lite login -c http://192.168.100.4:8080&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当前已经保存了名为&lt;code&gt;lite&lt;/code&gt;的目标，会在以后的多个命令行中使用，&lt;code&gt;-t&lt;/code&gt;代表目标名(Target Name)。&lt;/p&gt;
&lt;p&gt;当准备好&lt;code&gt;hello.yml&lt;/code&gt;后，可以通过以下命令设置Pipelilne：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fly -t lite set-pipeline -p hello-world -c hello.yml&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后刷新Concourse主页面，可以看到已经设置好一个简单的Hello World的Pipeline了。&lt;br&gt;&lt;img src=&quot;/assets/concourse-ci/hello_demo_pipeline.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;该默认配置是暂停Pipeline，可以通过界面启动，也可以通过命令行方式启动：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fly -t lite unpause-pipeline -p hello-world&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;也可以通过命令查看当前Pipeline的配置：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fly -t lite get-pipeline -p hello-world&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该Pipeline非常简单，只有单一的&lt;code&gt;Job&lt;/code&gt;，整个计划中只有一个&lt;code&gt;Task&lt;/code&gt;，可以看到&lt;code&gt;Task&lt;/code&gt;执行过程的快照：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/concourse-ci/hello_run_build.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;更多示例教程可以参见&lt;a href=&quot;http://concourse.ci/tutorials.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Concourse官网Demo&lt;/a&gt;或&lt;a href=&quot;https://github.com/starkandwayne/concourse-tutorial&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Github的Concourse教程&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;Concourse-Assess&quot;&gt;&lt;a href=&quot;#Concourse-Assess&quot; class=&quot;headerlink&quot; title=&quot;Concourse Assess&quot;&gt;&lt;/a&gt;Concourse Assess&lt;/h3&gt;&lt;p&gt;虽然列举出了很多Concourse的优点和创新思路，但也有一些Concerns:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Concerns 1: 与其他CI/CD以GUI进行配置的方式不同，虽然Build和Pipeline的UI可视化效果很不错，但在配置上采用了YML文件，且需要使用FLY命令行的方式进行交互，因此要求记住一些规则、关键字和相关命令，这样势必增加了学习成本。&lt;/li&gt;
&lt;li&gt;Concerns 2: 因为Concourse作为新产品新工具，稳定性、易用行、扩展性等各方面还有待市场和用户的大量验证，当然，如果Concourse确实能够带来更多方便和更多新思路，并且解决了用户的真正痛点问题，那么，相信其未来一定是非常光明的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至于目前选择用哪款工具，其实需要根据团队和项目的情况来平衡选择的，有兴趣喜欢尝鲜的同学倒是可以折腾下，还是很有意思的。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[1] &lt;a href=&quot;https://concourse.ci&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://concourse.ci&lt;/a&gt;&lt;br&gt;[2] &lt;a href=&quot;https://www.go.cd/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.go.cd/&lt;/a&gt;&lt;br&gt;[3] &lt;a href=&quot;https://jenkins.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://jenkins.io/&lt;/a&gt;&lt;br&gt;[4] &lt;a href=&quot;https://travis-ci.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://travis-ci.com/&lt;/a&gt;&lt;br&gt;[5] &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_citizen&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://en.wikipedia.org/wiki/First-class_citizen&lt;/a&gt;&lt;br&gt;[6] &lt;a href=&quot;https://github.com/starkandwayne/concourse-tutorial&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/starkandwayne/concourse-tutorial&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      目前主流的CI/CD工具包括Concourse CI, Jenkins, Travis CI和GoCD，它们各自到底有什么优缺点，Concourse CI有什么优势和亮点能够跻身Tech Radar?
    
    </summary>
    
      <category term="Tools" scheme="http://blog.waterstrong.me/categories/Tools/"/>
    
    
      <category term="DevOps" scheme="http://blog.waterstrong.me/tags/DevOps/"/>
    
      <category term="CI/CD" scheme="http://blog.waterstrong.me/tags/CI-CD/"/>
    
      <category term="Concourse" scheme="http://blog.waterstrong.me/tags/Concourse/"/>
    
      <category term="Jenkins" scheme="http://blog.waterstrong.me/tags/Jenkins/"/>
    
      <category term="TravisCI" scheme="http://blog.waterstrong.me/tags/TravisCI/"/>
    
      <category term="GoCD" scheme="http://blog.waterstrong.me/tags/GoCD/"/>
    
  </entry>
  
  <entry>
    <title>AWS EC2搭建VPN服务器</title>
    <link href="http://blog.waterstrong.me/aws-ec2-vpn/"/>
    <id>http://blog.waterstrong.me/aws-ec2-vpn/</id>
    <published>2016-04-13T15:30:52.000Z</published>
    <updated>2016-06-11T13:29:32.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;主要介绍如何在12个月免费的AWS EC2中搭建基于PPTP协议的VPN服务用于翻越GFW，平时Google搜索一下也很方便，会涉及CentOS, RedHat和Ubuntu操作系统。虽然自己有用其他翻Wall软件，也有我司的VPN服务帐号，但还是想折腾一下，说不定还可以出售给小白同学。&lt;/p&gt;
&lt;p&gt;而且自己搭建VPN有诸多好处:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;暂时免费，只要不超出AWS免费流量和时间限制;&lt;/li&gt;
&lt;li&gt;速度有保障，可以选择最快地区的AWS EC2进行搭建;&lt;/li&gt;
&lt;li&gt;自己的帐号自己管理，流量也自己控制，安全有保障。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;AWS EC2已经在另一篇Blog中有相关介绍，有兴趣可以参见&lt;a href=&quot;/aws-ec2-basic&quot;&gt;AWS EC2入门篇&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;VPN: Virtual Private Network, 虚拟专用网络，是一种远程访问技术，主要功能是在公用网络上建立专用网络，进行加密通讯，支持跨平台。&lt;br&gt;PPTP: Point to Point Tunneling Protocol, 点对点隧道协议，是PPP协议的基础上的增强型安全协议，支持多协议VPN，默认端口号1723。利于PPTP可以快速搭建自己的VPN，并且在很多的移动设备上也支持PPTP，同时PPTP速度也较快，资源消耗也小。&lt;/p&gt;
&lt;p&gt;简单介绍了之后，可以尝试以下步骤在服务器上搭建一个VPN服务。&lt;/p&gt;
&lt;h3 id=&quot;Step1-安装PPTP&quot;&gt;&lt;a href=&quot;#Step1-安装PPTP&quot; class=&quot;headerlink&quot; title=&quot;Step1 - 安装PPTP&quot;&gt;&lt;/a&gt;Step1 - 安装PPTP&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;On Ubuntu 14.04 x64:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo su  # 登录服务器后切换到超级管理员&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;apt-get update -y  # 更新源&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;apt-get install pptpd -y  # 安装pptpd, 同时会自动安装依赖组件ppp和iptables&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;On CentOS or Red Hat Linux 6.x x64:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo su  # 登录服务器后切换到超级管理员&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum update -y  # 更新源&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum install pptpd -y  # 安装pptpd, 同时会自动安装依赖组件ppp和iptables&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;如果找不到源，返回&lt;code&gt;No package pptpd available&lt;/code&gt;，如Amazon AMI Linux，可以采用以下方法解决: &lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;方法一: 下载rpm包直接安装（推荐）&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 针对EL6.x版本:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wget -c http://poptop.sourceforge.net/yum/stable/packages/pptpd-1.4.0-1.el6.x86_64.rpm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 针对EL7.x版本:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wget -c http://dl.fedoraproject.org/pub/epel/7/x86_64/p/pptpd-1.4.0-2.el7.x86_64.rpm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rpm -ivh pptpd-1.4.0-1.el6.x86_64.rpm  # 安装显示安装进度--install--verbose--hash&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;方法二: 需要添加新的源&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum repolist  # 查看yum源列表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 只针对EL7版本:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum localinstall http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-5.noarch.rpm -y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum makecache  # 将服务器上的软件包信息下载到本地缓存, 以提高搜索和安装软件的速度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum repolist  # 可以再次查看新加入的列表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum install pptpd -y  # 再次执行安装pptpd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 可用 yum-config-manager --disable &amp;lt;repoid&amp;gt; 删除源&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Step2-配置PPTP&quot;&gt;&lt;a href=&quot;#Step2-配置PPTP&quot; class=&quot;headerlink&quot; title=&quot;Step2 - 配置PPTP&quot;&gt;&lt;/a&gt;Step2 - 配置PPTP&lt;/h3&gt;&lt;p&gt;编辑&lt;code&gt;/etc/pptpd.conf&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vim /etc/pptpd.conf&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;搜索&lt;code&gt;localip&lt;/code&gt;并去掉以下字段前的注释符&lt;code&gt;#&lt;/code&gt;，保存并退出&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;localip 192.168.0.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remoteip 192.168.0.234-238,192.168.0.245&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;localip&lt;/code&gt;表示VPN服务器使用的地址，而&lt;code&gt;remoteip&lt;/code&gt;表示分配给VPN客户端的地址范围，当然也可以自定义设置范围。&lt;/p&gt;
&lt;h3 id=&quot;Step3-添加DNS解析&quot;&gt;&lt;a href=&quot;#Step3-添加DNS解析&quot; class=&quot;headerlink&quot; title=&quot;Step3 - 添加DNS解析&quot;&gt;&lt;/a&gt;Step3 - 添加DNS解析&lt;/h3&gt;&lt;p&gt;针对&lt;code&gt;Ubuntu&lt;/code&gt;系统，编辑&lt;code&gt;/etc/ppp/pptpd-options&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vim /etc/ppp/pptpd-options&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;针对&lt;code&gt;CentOS/RedHat&lt;/code&gt;，编辑&lt;code&gt;/etc/ppp/options.pptpd&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vim /etc/ppp/options.pptpd&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在文件中搜索&lt;code&gt;ms-dns&lt;/code&gt;，去掉以下字段前的注释符&lt;code&gt;#&lt;/code&gt;，并修改为以下值后保存退出&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ms-dns 8.8.8.8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ms-dns 8.8.4.4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上两条配置指定了使用Google Public DNS服务器。&lt;/p&gt;
&lt;h3 id=&quot;Step4-添加VPN用户&quot;&gt;&lt;a href=&quot;#Step4-添加VPN用户&quot; class=&quot;headerlink&quot; title=&quot;Step4 - 添加VPN用户&quot;&gt;&lt;/a&gt;Step4 - 添加VPN用户&lt;/h3&gt;&lt;p&gt;编辑&lt;code&gt;/etc/ppp/chap-secrets&lt;/code&gt;，添加用户名和密码条目，格式为&lt;code&gt;[username] [service] [password] [ip]&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# client	server  	secret		IP addresses&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vpnuser01	pptpd   	123456		*&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中，用户名和密码可自行设置，服务名应为&lt;code&gt;pptpd&lt;/code&gt;，IP表明允许登录的ip列表，如果允许所有ip可以设置为&lt;code&gt;*&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;Step5-开启IPv4转发&quot;&gt;&lt;a href=&quot;#Step5-开启IPv4转发&quot; class=&quot;headerlink&quot; title=&quot;Step5 - 开启IPv4转发&quot;&gt;&lt;/a&gt;Step5 - 开启IPv4转发&lt;/h3&gt;&lt;p&gt;为了支持IP数据包的转发，需要开启IPv4转发功能。&lt;br&gt;编辑&lt;code&gt;/etc/sysctl.conf&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vim /etc/sysctl.conf&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;搜索并找到以下字段，去掉注释并修改为以下值：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;net.ipv4.ip_forward = 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;= 1&lt;/code&gt;表明开启了服务器内核支持IP数据包转发功能，允许通过PPTP协议在公有IP和私有IPs之间进行数据包转发。&lt;/p&gt;
&lt;p&gt;使得修改生效，需要执行：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sysctl -p&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Step6-创建NAT规则&quot;&gt;&lt;a href=&quot;#Step6-创建NAT规则&quot; class=&quot;headerlink&quot; title=&quot;Step6 - 创建NAT规则&quot;&gt;&lt;/a&gt;Step6 - 创建NAT规则&lt;/h3&gt;&lt;p&gt;创建网络地址转换，添加防火墙规则到iptables中，在终端执行以下命令&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE  # 将所有目标IP包转向eth0接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;service iptables save  # 添加规则后重启会失效，所以需要保存，若不支持，可添加到rc.local文件中开机自动设置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 也可使用命令 iptables-save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;service iptables restart  # 重启iptables，貌似针对Ubuntu无效(忽略)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;pptpd默认监听1723端口，可以通过以下命令查看：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;netstat -nap | grep pptpd&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(可选)如果端口没有开启则开启相关端口:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;iptables -I INPUT -p tcp –dport 1723 -j ACCEPT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iptables -I INPUT -p tcp –dport 47 -j ACCEPT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iptables -I INPUT -p UDP --dport 53 -j ACCEPT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iptables -I INPUT -p gre -j ACCEPT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;service iptables save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Step7-启动PPTP服务&quot;&gt;&lt;a href=&quot;#Step7-启动PPTP服务&quot; class=&quot;headerlink&quot; title=&quot;Step7 - 启动PPTP服务&quot;&gt;&lt;/a&gt;Step7 - 启动PPTP服务&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;chkconfig pptpd on  # 设置开机启动VPN服务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;service pptpd restart  # 重启VPN服务, 当然可以用stop/start来停止/启动服务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;service pptpd status  # 查看VPN服务当前运行状态&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到服务已经启动:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-vpn/linux_pptpd_started.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;针对Ubuntu，即使运行start命令，但查看status还是显示&lt;code&gt;pptpd is not running&lt;/code&gt;，可以编辑&lt;code&gt;/etc/init.d/pptpd&lt;/code&gt;文件，搜索&lt;code&gt;status&lt;/code&gt;找到该行&lt;code&gt;status_of_proc &amp;quot;$PIDFILE&amp;quot; &amp;quot;$DAEMON&amp;quot; &amp;quot;$NAME&amp;quot; &amp;amp;&amp;amp; exit 0 || exit $?&lt;/code&gt;，并添加&lt;code&gt;-p&lt;/code&gt;参数：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;status_of_proc -p &amp;quot;$PIDFILE&amp;quot; &amp;quot;$DAEMON&amp;quot; &amp;quot;$NAME&amp;quot; &amp;amp;&amp;amp; exit 0 || exit $?&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;针对VPN日志，在CentOS中，VPN服务器默认会写日志到&lt;code&gt;/var/log/messages&lt;/code&gt;中; 在Ubuntu中，VPN服务器默认会写日志到&lt;code&gt;/var/log/syslog&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;以上步骤完成配置正确后，可以利用自己的终端设备连接到VPN上网了。&lt;/p&gt;
&lt;h3 id=&quot;Step8-使用VPN服务&quot;&gt;&lt;a href=&quot;#Step8-使用VPN服务&quot; class=&quot;headerlink&quot; title=&quot;Step8 - 使用VPN服务&quot;&gt;&lt;/a&gt;Step8 - 使用VPN服务&lt;/h3&gt;&lt;h4 id=&quot;在Mac-OS-X上配置VPN&quot;&gt;&lt;a href=&quot;#在Mac-OS-X上配置VPN&quot; class=&quot;headerlink&quot; title=&quot;在Mac OS X上配置VPN&quot;&gt;&lt;/a&gt;在Mac OS X上配置VPN&lt;/h4&gt;&lt;p&gt;System Preferences(系统设置) -&amp;gt; Network(网络):&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-vpn/mac_system_network.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;选择左下角的&lt;code&gt;+&lt;/code&gt;号添加VPN，选择PPTP类型，点击create创建:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-vpn/mac_new_vpn.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Advanced(高级) -&amp;gt; Options(选项) -&amp;gt; 勾选Session Options中的所有项 -&amp;gt; OK保存:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-vpn/mac_vpn_options.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;填写VPN相关服务器地址、用户名、密码等信息 -&amp;gt; 点击Apply应用所有修改 -&amp;gt; 点击connect连接VPN服务:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-vpn/mac_vpn_connected.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中Server Address绑定了子域名&lt;code&gt;aws.vpn.xxx&lt;/code&gt;，在需要更改服务主机时只需要重定位DNS即可，Client终端配置不需要更改，当然要做负载时也很方便，同时也利用记忆。&lt;/p&gt;
&lt;h4 id=&quot;在iPhone-6s上配置VPN&quot;&gt;&lt;a href=&quot;#在iPhone-6s上配置VPN&quot; class=&quot;headerlink&quot; title=&quot;在iPhone 6s上配置VPN&quot;&gt;&lt;/a&gt;在iPhone 6s上配置VPN&lt;/h4&gt;&lt;p&gt;首先进入Settings设置，选择VPN项（也可以借助第三方软件，如AnyConnect）:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-vpn/6s_vpn_setting.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;选择PPTP类型，填写服务器地址、用户名、密码等，然后保存:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-vpn/6s_new_vpn.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;点击connect连接VPN服务:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-vpn/6s_vpn_connected.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;进入已连接的VPN查看分配的IP，连接时间等详细信息，当然也可以删除VPN:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-vpn/6s_vpn_detail.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;测试访问Google，在手机浏览器输入&lt;code&gt;www.google.com&lt;/code&gt;，使用4G数据流量，连接正常，速度没有明显差异:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-vpn/6s_test_vpn.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当然，其他设备上也是类似配置，都是一些基础的操作，也该收工了。OK, Just Enjoy~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      主要介绍如何在12个月免费的AWS EC2中搭建基于PPTP协议的VPN服务用于翻越GFW，平时Google搜索一下也很方便，会涉及CentOS, RedHat和Ubuntu操作系统。
    
    </summary>
    
      <category term="Platforms" scheme="http://blog.waterstrong.me/categories/Platforms/"/>
    
    
      <category term="Linux" scheme="http://blog.waterstrong.me/tags/Linux/"/>
    
      <category term="DevOps" scheme="http://blog.waterstrong.me/tags/DevOps/"/>
    
      <category term="AWS EC2" scheme="http://blog.waterstrong.me/tags/AWS-EC2/"/>
    
      <category term="VPN" scheme="http://blog.waterstrong.me/tags/VPN/"/>
    
      <category term="PPTP" scheme="http://blog.waterstrong.me/tags/PPTP/"/>
    
      <category term="CentOS" scheme="http://blog.waterstrong.me/tags/CentOS/"/>
    
      <category term="RedHat" scheme="http://blog.waterstrong.me/tags/RedHat/"/>
    
      <category term="Ubuntu" scheme="http://blog.waterstrong.me/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>AWS EC2入门篇</title>
    <link href="http://blog.waterstrong.me/aws-ec2-basic/"/>
    <id>http://blog.waterstrong.me/aws-ec2-basic/</id>
    <published>2016-04-11T04:00:08.000Z</published>
    <updated>2016-06-11T13:29:32.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;h4 id=&quot;什么是Amazon-EC2&quot;&gt;&lt;a href=&quot;#什么是Amazon-EC2&quot; class=&quot;headerlink&quot; title=&quot;什么是Amazon EC2&quot;&gt;&lt;/a&gt;什么是Amazon EC2&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Amazon Elastic Compute Cloud (Amazon EC2) provides scalable computing capacity in the Amazon Web Services (AWS) cloud.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Amazon EC2是一个IaaS云服务，主要提供弹性的计算资源，通俗地讲，就是提供多种类型的虚拟机。EC2也是整个AWS最核心的组成部分，AWS中有许多的服务需要依赖它。在EC2环境中，虚拟机被称为实例，实例的镜像被称为AMI(Amazon Machine Image)。使用AWS EC2有如下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可避免前期的硬件投入，因此能够快速开发和部署应用程序&lt;/li&gt;
&lt;li&gt;可根据自身需要快速启动任意数量的虚拟服务器、配置安全和网络以及管理存储&lt;/li&gt;
&lt;li&gt;允许根据需要进行缩放以应对需求变化或流行高峰，降低流量预测需求&lt;/li&gt;
&lt;li&gt;主要是根据类型和使用时间收费，即使用多少收多少的费用&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;相关概念和名词解释&quot;&gt;&lt;a href=&quot;#相关概念和名词解释&quot; class=&quot;headerlink&quot; title=&quot;相关概念和名词解释&quot;&gt;&lt;/a&gt;相关概念和名词解释&lt;/h4&gt;&lt;p&gt;Instance: 实例，在EC2环境中，虚拟计算环境被称为实例。&lt;br&gt;AMI: Amazon Machine Image，亚马逊系统映像，即实例的预配置模板，其中包含服务器需要的程序包（包括操作系统和其他软件）。&lt;/p&gt;
&lt;p&gt;IaaS: Infrastructure as a Service, 基础设施即服务。消费者通过Internet可以从完善的计算机基础设施获得服务，这类服务称为基础设施即服务(IaaS)，基于Internet的服务（如存储和数据库）是IaaS的一部分。&lt;/p&gt;
&lt;p&gt;IaaS通常分为三种用法：公有云、私有云和混合云。Amazon EC2在基础设施云中使用公共服务器池(公有云)，更加私有化的服务会使用企业内部数据中心的一组公用或私有服务器池(私有云)，如果在企业数据中心环境中开发软件，那么这两种类型公有云、私有云都能使用(混合云)。&lt;/p&gt;
&lt;p&gt;Internet上其他类型的服务包括平台即服务(Platform as a Service, PaaS)和软件即服务(Software as a Service, SaaS)。PaaS提供了用户可以访问的完整或部分的应用程序开发，SaaS则提供了完整的可直接使用的应用程序，比如通过 Internet管理企业资源。&lt;/p&gt;
&lt;h3 id=&quot;注册并创建EC2实例&quot;&gt;&lt;a href=&quot;#注册并创建EC2实例&quot; class=&quot;headerlink&quot; title=&quot;注册并创建EC2实例&quot;&gt;&lt;/a&gt;注册并创建EC2实例&lt;/h3&gt;&lt;p&gt;若没有帐号可进入&lt;a href=&quot;http://aws.amazon.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AWS主页&lt;/a&gt;选择&lt;code&gt;Create an AWS Account&lt;/code&gt;注册:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-basic/aws_homepage.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;大概需要填写用户名密码,联系人信息,信用卡信息等，信用卡会被扣掉1美元:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-basic/register_in_process.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后进入AWS控制台选择EC2:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-basic/aws_overview.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了选择最近的地区，可以在&lt;a href=&quot;http://www.cloudping.info/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CloudPing&lt;/a&gt;上测试一下Ping速度，选择最快的Singapore:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-basic/choose_location_area.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-basic/cloud_ping.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;点击&lt;code&gt;Launch Instance&lt;/code&gt;创建一个实例，可以选择&lt;code&gt;Community AMIs&lt;/code&gt;进行筛选，也可能直接选择Amazon的Linux AMI，据说是速度和性能都进行过优化:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-basic/launch_choose_ami.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;一定只选择标记为&lt;code&gt;Free tier eligible&lt;/code&gt;的免费类型，否则运行一段时间就等着哭吧:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-basic/launch_choose_instance_type.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;根据步骤和提示一步步完成即可，最后启动会选择Key Pair。当系统提示提供密钥时，选择Choose an existing key pair，然后选择已创建的密钥对。另外，也可以新建密钥对，选择Create a new key pair，输入密钥对的名称，然后选择Download Key Pair。这是保存私有密钥文件的唯一机会，因此务必单击进行下载，将私有密钥文件保存在安全位置。当启动实例时，需要提供密钥对的名称，当每次连接到实例时，需要提供相应的私有密钥。&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-basic/launch_select_key_pair.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最后就可以看到Instances页面出现了已创建成功的实例。如果需要SSH到实例，可以点击&lt;code&gt;Instances -&amp;gt; 选择Instance -&amp;gt; Connect&lt;/code&gt;查看，Shell Command如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh -i &amp;lt;key.pem&amp;gt; &amp;lt;username&amp;gt;@&amp;lt;instance-address&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;更多说明请参见&lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/get-set-up-for-amazon-ec2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Amazon EC2 的设置&lt;/a&gt;和&lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/managing-users.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在 Linux 实例上管理用户账户&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Instances-Management-实例管理&quot;&gt;&lt;a href=&quot;#Instances-Management-实例管理&quot; class=&quot;headerlink&quot; title=&quot;Instances Management 实例管理&quot;&gt;&lt;/a&gt;Instances Management 实例管理&lt;/h3&gt;&lt;p&gt;实例(Instance), 即虚拟计算环境。实例的预配置模板，也称为亚马逊系统映像(AMI)，其中包含服务器需要的程序包(包括操作系统和其他软件)。实例CPU、内存、存储和网络容量的多种配置，也称为实例类型。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Instances&lt;/code&gt;栏中可以对实例进行Reboot, Stop, Start, Terminate(永久删除)以及其他的网络,安全,卷等设置。&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-basic/instances.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Resource-amp-Tags-资源-amp-标签&quot;&gt;&lt;a href=&quot;#Resource-amp-Tags-资源-amp-标签&quot; class=&quot;headerlink&quot; title=&quot;Resource &amp;amp; Tags 资源 &amp;amp; 标签&quot;&gt;&lt;/a&gt;Resource &amp;amp; Tags 资源 &amp;amp; 标签&lt;/h3&gt;&lt;p&gt;Amazon EC2提供可创建和使用的不同资源，这些资源中的一部分资源包括映像、实例、卷和快照，在创建某个资源时，该资源会被分配一个唯一资源 ID。可以定义某个值标记某些资源，来帮助组织和识别这些资源，即Tags。&lt;/p&gt;
&lt;p&gt;标签(Tag)为了&lt;code&gt;方便管理实例、映像以及其他Amazon EC2资源&lt;/code&gt;，可通过标签的形式为每个资源分配元数据(Meta Data)。&lt;code&gt;标签可按各种标准(例如用途、所有者或环境)对AWS资源进行分类&lt;/code&gt;，每个标签都包含定义的一个键和一个可选值，例如下图所示：&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-basic/tag_example.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Volumes-卷&quot;&gt;&lt;a href=&quot;#Volumes-卷&quot; class=&quot;headerlink&quot; title=&quot;Volumes 卷&quot;&gt;&lt;/a&gt;Volumes 卷&lt;/h3&gt;&lt;p&gt;卷是一种数据块级存储设备，可以连接到单个EC2实例，可以像使用其他物理硬盘一样使用它。使用Amazon Elastic Block Store(Amazon EBS)的数据的持久性存储卷，也称为Amazon EBS卷，提供了三种卷类型：通用型SSD、Provisioned IOPS和磁介质，各卷类型特点可参见: &lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/EBSVolumeTypes.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Amazon EBS 卷类型&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;除了EBS，还有提供临时性块级存储&lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/InstanceStorage.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实例存储&lt;/a&gt;和存储Internet数据的Amazon Simple Storage Service (&lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/AmazonS3.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Amazon S3&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;卷存储的架构如下图所示:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-basic/architecture_storage.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以选择&lt;code&gt;elastic block store -&amp;gt; Volumes -&amp;gt; Create Volume&lt;/code&gt;创建一个新卷:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-basic/create_volume.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;选择Volumes中的一个条目，通过&lt;code&gt;Actions或右键 -&amp;gt; Attach Volume&lt;/code&gt;连接到某个Instance上:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-basic/attach_volume.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Instance上通过以下命令实现Mount(挂载)创建的卷:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df -h  # 查看已挂载的卷&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;df -T  # 可以查看挂载卷的类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo fdisk -l  # 查看连接到的卷&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 当确定卷的名称为 /dev/xvdf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo mkfs.ext4 /dev/xvdf  # 格式化卷类型为ext4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir /mnt/ebs  # 创建文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo mount /dev/xvdf /mnt/ebs  # 挂载卷到ebs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;df -T  # 再次查看挂载情况&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 若需要卸载卷&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo umount /dev/xvdf&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Snapshots-快照&quot;&gt;&lt;a href=&quot;#Snapshots-快照&quot; class=&quot;headerlink&quot; title=&quot;Snapshots 快照&quot;&gt;&lt;/a&gt;Snapshots 快照&lt;/h3&gt;&lt;p&gt;每个快照代表一个卷在一个特定时间点的状态。快照属于增量备份，这意味着仅保存设备上在最新快照之后更改的数据块。相对容易理解，此处不再赘述。&lt;/p&gt;
&lt;h3 id=&quot;Security-Groups-安全组&quot;&gt;&lt;a href=&quot;#Security-Groups-安全组&quot; class=&quot;headerlink&quot; title=&quot;Security Groups 安全组&quot;&gt;&lt;/a&gt;Security Groups 安全组&lt;/h3&gt;&lt;p&gt;可以使用安全组来控制实例的访问权限，这些安全组类似于一个传入网络防火墙，可以指定允许访问实例的协议、端口和源IP范围。可以创建多个安全组，并给每个安全组指定不同的规则，然后可以给每个实例分配一个或多个安全组，通过这些规则规则确定允许哪些流量可访问实例。&lt;/p&gt;
&lt;p&gt;Security Group安全组架构如图所示:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-basic/architecture_security_group.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;创建新的安全组，选择&lt;code&gt;Network &amp;amp; Security -&amp;gt; Security Groups -&amp;gt; Create Security Group&lt;/code&gt;进行创建:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-basic/create_security_group.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图显示下拉列表中，可以根据需要选择如SSH,TCP,UDP等，也可以选择Customer Rule来自定义端口号等，还可指定来源IP范围。&lt;/p&gt;
&lt;p&gt;选择Security Groups中一个条目，通过&lt;code&gt;Actions或右键 -&amp;gt; Edit inbound rules或Edit outbound rules&lt;/code&gt;来添加流量流入和流出限制规则:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-basic/edit_inbound_rules.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以根据实际需要添加规则，如果对安全性没有需求，可以不设置防火墙限制(但不推荐)，可直接选择&lt;code&gt;type&lt;/code&gt;为&lt;code&gt;All traffic&lt;/code&gt;，选择&lt;code&gt;source&lt;/code&gt;为&lt;code&gt;Anywhere&lt;/code&gt;，这样就允许所有类型和源的流量流入。&lt;/p&gt;
&lt;h3 id=&quot;Key-Pairs-密钥对&quot;&gt;&lt;a href=&quot;#Key-Pairs-密钥对&quot; class=&quot;headerlink&quot; title=&quot;Key Pairs 密钥对&quot;&gt;&lt;/a&gt;Key Pairs 密钥对&lt;/h3&gt;&lt;p&gt;Amazon EC2使用公有密钥密码术加密和解密登录信息。公有密钥密码术使用公有密钥加密某个数据(如一个密码)，然后收件人可以使用私有密钥解密数据，公有和私有密钥被称为密钥对。AWS存储公有密钥，个人在安全位置存储私有密钥。如果经常使用SSH那就比较清楚了。&lt;/p&gt;
&lt;p&gt;选择&lt;code&gt;Network &amp;amp; Security -&amp;gt; Key Pairs -&amp;gt; Import Key Pair&lt;/code&gt;可以导入本机的公钥，当然也可以创建Key Pair:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-basic/create_key_pair.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Placement-Groups-置放群组&quot;&gt;&lt;a href=&quot;#Placement-Groups-置放群组&quot; class=&quot;headerlink&quot; title=&quot;Placement Groups 置放群组&quot;&gt;&lt;/a&gt;Placement Groups 置放群组&lt;/h3&gt;&lt;h3 id=&quot;Elastic-IPs-弹性IP&quot;&gt;&lt;a href=&quot;#Elastic-IPs-弹性IP&quot; class=&quot;headerlink&quot; title=&quot;Elastic IPs 弹性IP&quot;&gt;&lt;/a&gt;Elastic IPs 弹性IP&lt;/h3&gt;&lt;p&gt;弹性IP地址是专为动态云计算设计的静态IP地址。&lt;code&gt;实例在重启后会自动重新分配一个与原实例不同的公有IP地址&lt;/code&gt;，如果应用程序需要一个静态IP地址，可以使用弹性IP地址关联到实例，并且在实例发生故障的情况下能够将该地址映射到另一实例，并能够将 DNS主机名用于所有其他节点间通信，从而屏蔽实例故障。&lt;/p&gt;
&lt;p&gt;如下图所示选择&lt;code&gt;Network &amp;amp; Security -&amp;gt; Elastic IPs -&amp;gt; Allocate New Address&lt;/code&gt;分配一个新的EIP:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-basic/new_elastic_ip.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;选择Elastic IPs中一个条目，通过&lt;code&gt;Actions或右键 -&amp;gt; Associate Address&lt;/code&gt;输入需要关联的Instance:&lt;br&gt;&lt;img src=&quot;/assets/aws-ec2-basic/associate_elastic_ip.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;此时可以通过EIP访问关联到的Instance了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;特别注意:&lt;/code&gt; 为确保弹性IP地址的有效使用，如果弹性IP地址未与正在运行的实例关联，或者它已与停止的实例或未连接的网络接口关联，Amazon将强制收取小额的小时费用，每小时是$0.005。当实例正在运行时，无需为与该实例关联的某个弹性IP地址付费。当重新映射弹性IP地址次数一个月内超过了100次将收取$0.10费用。在默认情况下，所有AWS账户最多可拥有5个EIP。&lt;/p&gt;
&lt;h3 id=&quot;Network-Interfaces-网络接口&quot;&gt;&lt;a href=&quot;#Network-Interfaces-网络接口&quot; class=&quot;headerlink&quot; title=&quot;Network Interfaces 网络接口&quot;&gt;&lt;/a&gt;Network Interfaces 网络接口&lt;/h3&gt;&lt;p&gt;您可以创建的虚拟网络，这些网络与其余 AWS 云在逻辑上隔离，并且您可以选择连接到您自己的网络，也称为Virtual Private Cloud(VPC)。&lt;/p&gt;
&lt;h3 id=&quot;Load-Banlancers-负载均衡&quot;&gt;&lt;a href=&quot;#Load-Banlancers-负载均衡&quot; class=&quot;headerlink&quot; title=&quot;Load Banlancers 负载均衡&quot;&gt;&lt;/a&gt;Load Banlancers 负载均衡&lt;/h3&gt;&lt;p&gt;可以跨越多个Amazon EC2实例自动分配应用程序的传入流量。&lt;/p&gt;
&lt;h3 id=&quot;Auto-Scaling&quot;&gt;&lt;a href=&quot;#Auto-Scaling&quot; class=&quot;headerlink&quot; title=&quot;Auto Scaling&quot;&gt;&lt;/a&gt;Auto Scaling&lt;/h3&gt;&lt;p&gt;根据定义的条件自动扩展Amazon EC2容量。&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;p&gt;[1] &lt;a href=&quot;http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/concepts.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Amazon EC2 User Guide for Linux Instances&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      Amazon EC2是一个IaaS云服务，主要提供弹性的计算资源，EC2是整个AWS最核心的组成部分，可以在很短的时间内创建、启动和运行不同的类型和大小的EC2实例。
    
    </summary>
    
      <category term="Platforms" scheme="http://blog.waterstrong.me/categories/Platforms/"/>
    
    
      <category term="DevOps" scheme="http://blog.waterstrong.me/tags/DevOps/"/>
    
      <category term="AWS EC2" scheme="http://blog.waterstrong.me/tags/AWS-EC2/"/>
    
      <category term="IaaS" scheme="http://blog.waterstrong.me/tags/IaaS/"/>
    
      <category term="云服务" scheme="http://blog.waterstrong.me/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="SSH" scheme="http://blog.waterstrong.me/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>事务处理机制与协议</title>
    <link href="http://blog.waterstrong.me/transactional-mechanism-protocol/"/>
    <id>http://blog.waterstrong.me/transactional-mechanism-protocol/</id>
    <published>2016-02-04T11:11:03.000Z</published>
    <updated>2016-06-11T13:29:32.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;事务定义及其特性&quot;&gt;&lt;a href=&quot;#事务定义及其特性&quot; class=&quot;headerlink&quot; title=&quot;事务定义及其特性&quot;&gt;&lt;/a&gt;事务定义及其特性&lt;/h2&gt;&lt;h3 id=&quot;什么是事务？&quot;&gt;&lt;a href=&quot;#什么是事务？&quot; class=&quot;headerlink&quot; title=&quot;什么是事务？&quot;&gt;&lt;/a&gt;什么是事务？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;A transaction is a unit of work that you want to treat as “a whole”. It has to either happen in full, or not at all.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直接地讲，就是事务是一个整体，其中的若干处理要么都做，要么都不做。本文主要涉及事务的定义及特性、本地事务、编程式事务、声明式事务、分布式事务、XA事务问题与优化策略等。接下来我们就详细地聊聊事务。&lt;/p&gt;
&lt;h3 id=&quot;事务的ACID特性&quot;&gt;&lt;a href=&quot;#事务的ACID特性&quot; class=&quot;headerlink&quot; title=&quot;事务的ACID特性&quot;&gt;&lt;/a&gt;事务的ACID特性&lt;/h3&gt;&lt;p&gt;事务的四大特性分别为原子性、一致性、隔离性和永久性，称为ACID特性，也称酸性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;原子性（Atomicity）&lt;/strong&gt;&lt;br&gt;一个事务中所有操作是一个不可分割的操作序列，要么全做，要么全不做。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性（Consistency）&lt;/strong&gt;&lt;br&gt;数据不会因为事务的执行而遭到破坏，一致性保证了这个事务所包含的一系列的操作完成后系统仍然在一个一致的状态，侧重点在于，事务执行前后在某种程度上是等价的，从一个一致状态到另一个一致状态。例如，对银行转帐事务，不管事务成功还是失败，应该保证事务结束后两人存款总额为定值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离性（Isolation）&lt;/strong&gt;&lt;br&gt;一个事务的执行，不受其他事务（进程）的干扰，既并发执行的个事务之间互不干扰，每个事务都有各自的完整数据空间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;永久性（Durability）&lt;/strong&gt;&lt;br&gt;一个事务一旦提交，它对数据库所作的改变将是永久的，使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;数据库事务管理&quot;&gt;&lt;a href=&quot;#数据库事务管理&quot; class=&quot;headerlink&quot; title=&quot;数据库事务管理&quot;&gt;&lt;/a&gt;数据库事务管理&lt;/h3&gt;&lt;p&gt;对于数据库来说，事务的ACID特性是由关系数据库管理系统（RDBMS，数据库系统）来实现的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DBMS采用&lt;strong&gt;日志&lt;/strong&gt;来保证事务的原子性、一致性和持久性。&lt;ul&gt;
&lt;li&gt;日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DBMS采用&lt;strong&gt;锁机制&lt;/strong&gt;来实现事务的隔离性。&lt;ul&gt;
&lt;li&gt;每个事务对所依赖的资源（如行、页或表）请求不同类型的锁，当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。锁可以阻止其他事务以某种可能会导致事务请求锁出错的方式修改资源，当事务不再依赖锁定的资源时，它将释放锁。通常会有共享(S)锁、排它(X)锁、更新(U)锁等，各锁的解释、并发效率、锁冲突及其防止办法不在本文范围，有兴趣可以自行了解。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除了锁定外，也可能采用&lt;strong&gt;行版本控制&lt;/strong&gt;来实现事务隔离性。&lt;ul&gt;
&lt;li&gt;当启用了基于行版本控制的隔离级别时，数据库引擎将维护修改的每一行的版本，应用程序可以指定事务使用行版本查看事务或查询开始时存在的数据，而不是使用锁保护所有读取。通过使用行版本控制，读取操作阻止其他事务的可能性将大大降低，锁数量减少，死锁可能性降低，有效减少了管理锁的开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;锁定和行版本控制可以防止用户读取未提交的数据，还可以防止多个用户尝试同时更改同一数据。如果不进行锁定或行版本控制，对数据执行的查询可能会返回数据库中尚未提交的数据，从而产生意外的结果。&lt;/p&gt;
&lt;p&gt;在了解数据库保证事务ACID特性的基本原理后，那么……对程序提供的数据库编程接口，如何实现事务的呢？接下来介绍本地事务。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;本地事务（Local-Transaction）&quot;&gt;&lt;a href=&quot;#本地事务（Local-Transaction）&quot; class=&quot;headerlink&quot; title=&quot;本地事务（Local Transaction）&quot;&gt;&lt;/a&gt;本地事务（Local Transaction）&lt;/h2&gt;&lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;本地事务(Local Transaction)主要指限制在单个进程内的事务，不涉及多个数据库源，通常会有Begin Transaction … End Transaction来控制事务的开始与结束。以对数据库访问为例，接下来用伪代码实现事务的提交/回滚。&lt;/p&gt;
&lt;h3 id=&quot;本地事务-模型1&quot;&gt;&lt;a href=&quot;#本地事务-模型1&quot; class=&quot;headerlink&quot; title=&quot;本地事务 模型1&quot;&gt;&lt;/a&gt;本地事务 模型1&lt;/h3&gt;&lt;p&gt;设置自动提交的情况：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;conn = getConnection(“url&amp;quot;,&amp;quot;user&amp;quot;,&amp;quot;pwd&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conn.setAutoCommit(true);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;try&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn.execute(...);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;catch(Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;finally &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;本地事务-模型2&quot;&gt;&lt;a href=&quot;#本地事务-模型2&quot; class=&quot;headerlink&quot; title=&quot;本地事务 模型2&quot;&gt;&lt;/a&gt;本地事务 模型2&lt;/h3&gt;&lt;p&gt;设置非自动提交情况：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;conn = getConnection(“url&amp;quot;,&amp;quot;user&amp;quot;,&amp;quot;pwd&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conn.setAutoCommit(false);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;try&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn.execute(…);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn.commit();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;catch(Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn.rollback();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;finally &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这也是最早的访问方式，相信你也发现一些问题了，如果设置为自动提交，当某个操作需要多个执行序列完成时，那么每次execute时都会commit，在很程度上降低了执行效率。若设置为非自动提交，虽然解决了多次execute的问题，但直接暴露conn并不是理想的做法，同时还需要手动close连接。因此，有没有更好地方式呢？答案是肯定的，接下来就看看编程式事务的实现方式。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;编程式事务（Programmatic-Transaction）&quot;&gt;&lt;a href=&quot;#编程式事务（Programmatic-Transaction）&quot; class=&quot;headerlink&quot; title=&quot;编程式事务（Programmatic Transaction）&quot;&gt;&lt;/a&gt;编程式事务（Programmatic Transaction）&lt;/h2&gt;&lt;h3 id=&quot;基本介绍-1&quot;&gt;&lt;a href=&quot;#基本介绍-1&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;编程式事务(Programmatic Transaction)通过编程语言提供的事务API和事务服务提供者进行事务控制。通常的做法是在代码中直接加入处理事务的逻辑，显式地调用其commit()、rollback()等事务管理相关方法。&lt;/p&gt;
&lt;h3 id=&quot;编程式事务-模型&quot;&gt;&lt;a href=&quot;#编程式事务-模型&quot; class=&quot;headerlink&quot; title=&quot;编程式事务 模型&quot;&gt;&lt;/a&gt;编程式事务 模型&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;userTransaction.begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    doSomething();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    doAnotherThing();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    userTransaction.commit();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; catch (Exception ex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    userTransaction.rollback();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;与Local事务的区别&quot;&gt;&lt;a href=&quot;#与Local事务的区别&quot; class=&quot;headerlink&quot; title=&quot;与Local事务的区别&quot;&gt;&lt;/a&gt;与Local事务的区别&lt;/h3&gt;&lt;p&gt;Programmatic与Local Transaction的区别在于Programmatic把Local方式下的conn封装起来，并且手动控制commit和rollback，在一定程序上简化了编程的繁琐性，更加关注事务开始、提交与回滚。你觉得这种方式就已经很棒了么，再想想还有没有更好更创新的方法呢，声明式事务会给你想要的答案。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;声明式事务（Declarative-Transaction）&quot;&gt;&lt;a href=&quot;#声明式事务（Declarative-Transaction）&quot; class=&quot;headerlink&quot; title=&quot;声明式事务（Declarative Transaction）&quot;&gt;&lt;/a&gt;声明式事务（Declarative Transaction）&lt;/h2&gt;&lt;h3 id=&quot;基本介绍-2&quot;&gt;&lt;a href=&quot;#基本介绍-2&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;声明式事务(Declarative Transaction)对目标方法上添加注解(Annotation)或在配置文件中定义，通过对方法前后拦截添加事务处理逻辑。虽然XML配置的方式在前几年很受欢迎，也是具有里程碑的意义，但小编我更青睐注解的方式，况且目前主流的IoC框架也都支持注解方式并且推荐使用。接下来将给出Java形式的伪代码进行解释。&lt;/p&gt;
&lt;h3 id=&quot;声明式事务-模型&quot;&gt;&lt;a href=&quot;#声明式事务-模型&quot; class=&quot;headerlink&quot; title=&quot;声明式事务 模型&quot;&gt;&lt;/a&gt;声明式事务 模型&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@Transaction&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void doSomething() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    process1();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    process2();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    repository.save();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中的@Transaction就是一个注解(Annotation)，其内部实现原理通常采用的是&lt;a href=&quot;/aspect-oriented-programming&quot;&gt;AOP(面向切面编程)&lt;/a&gt;的方式进行方法的拦截。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Object intercept(proxy, method, args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    trans.begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	method.invoke(target, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	trans.commit();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; catch (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	trans.rollback();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以上所有的事务实现方式都主要集中在单一数据库情况，那么对于多数据库协调或者混合数据源情形，如数据库加消息队列等，又如何保证事务正确有效地执行呢？答案是分布式事务，也称全局事务来管理了。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;全局-分布式事务（Global-Distributed-Transaction）&quot;&gt;&lt;a href=&quot;#全局-分布式事务（Global-Distributed-Transaction）&quot; class=&quot;headerlink&quot; title=&quot;全局/分布式事务（Global/Distributed Transaction）&quot;&gt;&lt;/a&gt;全局/分布式事务（Global/Distributed Transaction）&lt;/h2&gt;&lt;h3 id=&quot;基本介绍-3&quot;&gt;&lt;a href=&quot;#基本介绍-3&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;全局/分布式事务(Global/Distributed Transaction)也称XA事务，主要处理跨越多个数据库或进程，多资源协调的情形（例如：访问多个数据库，或数据库加消息队列，又或是多个消息队列等）。其中核心概念包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务管理器（Transaction Manager）&lt;/li&gt;
&lt;li&gt;资源管理器（Resource Manager）&lt;/li&gt;
&lt;li&gt;XA协议标准（eXtended Architecture Standard）&lt;/li&gt;
&lt;li&gt;两阶段提交（Two-Phase Commit）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先来看一个关于JMS Message触发数据库更新操作的实例。&lt;/p&gt;
&lt;h3 id=&quot;JMS触发DB更新的实例&quot;&gt;&lt;a href=&quot;#JMS触发DB更新的实例&quot; class=&quot;headerlink&quot; title=&quot;JMS触发DB更新的实例&quot;&gt;&lt;/a&gt;JMS触发DB更新的实例&lt;/h3&gt;&lt;h4 id=&quot;DB-JMS-伪代码&quot;&gt;&lt;a href=&quot;#DB-JMS-伪代码&quot; class=&quot;headerlink&quot; title=&quot;DB+JMS 伪代码&quot;&gt;&lt;/a&gt;DB+JMS 伪代码&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@JMSListener(...)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void onMessage(...) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    service.merge(...);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Transaction&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void merge(…) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    repository.update(…);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;成功调用过程&quot;&gt;&lt;a href=&quot;#成功调用过程&quot; class=&quot;headerlink&quot; title=&quot;成功调用过程&quot;&gt;&lt;/a&gt;成功调用过程&lt;/h4&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Start messaging transaction&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Receive message&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Start database transaction&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Update database&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Commit database transaction&lt;/li&gt;
&lt;li&gt;Commit messaging transaction&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;成功调用Happy Pass当然没有什么问题，正常提交到数据库，也完成消息提交，但在实际情况中往往不是所期望的。&lt;/p&gt;
&lt;h4 id=&quot;可能失败的情形&quot;&gt;&lt;a href=&quot;#可能失败的情形&quot; class=&quot;headerlink&quot; title=&quot;可能失败的情形&quot;&gt;&lt;/a&gt;可能失败的情形&lt;/h4&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Start messaging transaction&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Receive message&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Start database transaction&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Update database, fail!&lt;/strong&gt; &amp;lt;–&lt;/li&gt;
&lt;li&gt;Roll back database transaction&lt;/li&gt;
&lt;li&gt;Roll back messaging transaction&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到第4步更新数据库时由于某种外键或唯一键约束导致数据库更新失败，这时需要回滚数据库操作以及消息提交，而如何保证Database和JMS之间能够正确工作是首要问题。同理，针对多个数据库或多个消息队列(Queue)/主题(Topic)，Transaction是如何协调多资源的呢？&lt;/p&gt;
&lt;h3 id=&quot;XA事务多资源协调&quot;&gt;&lt;a href=&quot;#XA事务多资源协调&quot; class=&quot;headerlink&quot; title=&quot;XA事务多资源协调&quot;&gt;&lt;/a&gt;XA事务多资源协调&lt;/h3&gt;&lt;h4 id=&quot;X-Open-XA规范接口&quot;&gt;&lt;a href=&quot;#X-Open-XA规范接口&quot; class=&quot;headerlink&quot; title=&quot;X/Open XA规范接口&quot;&gt;&lt;/a&gt;X/Open XA规范接口&lt;/h4&gt;&lt;p&gt;XA协议采用两阶段提交方式来管理分布式事务，XA接口提供资源管理器(RM)与事务管理器(TM)之间进行通信的标准接口。下图来自网络，大致描述了RM和TM的关系以及XA工作范畴，资源管理器管理着多个资源，事务管理器与资源管理器通过XA进行双向通信。&lt;br&gt;&lt;img src=&quot;/assets/transactional-mp/XA_standard_interface.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;XA事务实现原理主要是针对每一个XA资源给全局事务和本地事务分配一个xid，每一个XA资源都被加入的XA的管理器中，通过某个方法来决定XA资源已经被加入到事务中并且已经准备就绪，最后统一提交，也就是所谓的两阶段提交。&lt;/p&gt;
&lt;h4 id=&quot;XA两阶段提交协议&quot;&gt;&lt;a href=&quot;#XA两阶段提交协议&quot; class=&quot;headerlink&quot; title=&quot;XA两阶段提交协议&quot;&gt;&lt;/a&gt;XA两阶段提交协议&lt;/h4&gt;&lt;p&gt;两阶段提交协议（The two-phase commit protocol，2PC）是XA用于在全局事务中协调多个资源的机制。两阶段提交协议包含了两个阶段：准备阶段(Prepare)和提交阶段(Commit)。准备阶段需要检查资源的状态(READY, READ_ONLY, NOT_READY)，当且仅当所有资源都是READY状态，准备阶段完成，否则进行Rollback操作。下图来自网络，大致描述了2PC的工作流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/transactional-mp/XA_two_phase_commit.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;TM可以向RM查询事务的状态，RM必须要返回一系列事务的XID，表明事务是prepared状态，还是已经commit的状态。TM会把XID,已完成的RM等这样的事务信息保存起来的，只有当全部的RM提交或者回滚完后，才能丢弃这些事务的信息。&lt;strong&gt;XA事务都假定了TM和RM都是有牢靠的存储，所以也保证了TM重启后可以从日志里恢复还未处理完的事务。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TM/RM初始化和XA两阶段提交伪代码如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// TM/RM Init 伪代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TransactionManager() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xaResourceManager = new XAResourceManager(gtrid);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bool enlistResource(xaResource) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xaResourceHolder = findXAResourceHolder(xaResource);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xaResourceHolderState = new XAResourceHolderState(xaResourceHolder);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xaResourceHolderState.setTransactionTimeoutDate(timeout);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xaResourceManager.enlist(xaResourceHolderState);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;////////////////////////////////&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// XA 2PC 伪代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;XAResourceHolderState&amp;gt; interestedResources;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    interestedResources = preparer.prepare(this); //Get resources and check their states&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; catch(RollbackException ex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rollbackPrepareFailure(ex); // If one of the resources is not ready&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;committer.commit(this, interestedResources); // All resources are ready and commit all at once&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;…… // Other code goes here&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;////////////////////////////////&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 备注:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// preparer.prepare(this) is to get the resources and check their states&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// should call resource manager: transaction.getResourceManager().getAllResources();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;XA事务问题与优化策略&quot;&gt;&lt;a href=&quot;#XA事务问题与优化策略&quot; class=&quot;headerlink&quot; title=&quot;XA事务问题与优化策略&quot;&gt;&lt;/a&gt;XA事务问题与优化策略&lt;/h2&gt;&lt;p&gt;对于非XA事务，范围仅限于单个可识别数据资源的事务操作。对于XA事务，可能出现timeout问题，连锁反应导致系统变慢，同时XA事务也会消耗更多性能资源。因此，仅在同一个事务上下文中需要协调多种资源时，才有必要使用XA，也就是说仅当多个资源必须在同一个事务范畴内被协调时，才有必要用XA。&lt;/p&gt;
&lt;p&gt;针对XA事务可能出现的问题，目前常用的优化策略:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;最后资源提交优化（Last Resource Commit Optimization）&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;最后资源提交优化允许有且仅有一个资源是非XA资源，不必进入到准备阶段而可以直接提交或回滚，如果有这样的一个资源存在XA事务中，那首先应该尝试准备其他XA的资源，然后提交该非XA资源，如果成功，提交其他XA资源，否则回滚所有资源。通常的场景是当如JDBC这样的Driver不支持XA时，可以将其配置成最后参与者(资源)，然后就可以和XA资源进行协作了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一阶段提交优化（One-Phase Commit Optimization）&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;如果使用了XA事务，但资源只有一个，为了节省不必要的开销，XA不会执行两阶段提交，准确地说是没有准备阶段，而是当作单个资源处理并直接提交。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;经验异常（Heuristic Exception）处理&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;在两阶段提交的过程，资源管理器可能会使用“经验化决策”的策略，提交或者回滚，而不受事务管理器的控制。“经验化决策”是指根据多种内部和外部因素做出智能决定的过程，当资源管理器这么做了，它会向客户端报上一个经验异常（Heuristic Exception）。在XA环境下，两阶段提交的过程中，特别是事务参与者在第一阶段产生了响应之后，经验异常最常见的原因是第一阶段和第二阶段之间的超时情况，当网络延迟或故障、资源锁定以及资源使用过量时，资源管理器或许要做出提交或回滚其工作的决定，以释放资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;学海无涯-Keep-Learning&quot;&gt;&lt;a href=&quot;#学海无涯-Keep-Learning&quot; class=&quot;headerlink&quot; title=&quot;学海无涯 Keep Learning&quot;&gt;&lt;/a&gt;学海无涯 Keep Learning&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1. 可以研究下Java中Spring JTA Transaction Manager, 如Bitronix, Atomikos, etc.
2. 可以研究下各数据库如何开启和关闭支持XA事务，如何设置同时处于&amp;quot;准备好&amp;quot;状态的事务的最大数目（max_prepared_transactions）.
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      事务(Transaction)作为一个整体，其中的若干处理要么都做，要么都不做。主要涉及事务的定义及特性、本地事务、编程式事务、声明式事务、分布式事务、XA事务问题与优化策略等。
    
    </summary>
    
      <category term="Techniques" scheme="http://blog.waterstrong.me/categories/Techniques/"/>
    
    
      <category term="数据库" scheme="http://blog.waterstrong.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Transaction" scheme="http://blog.waterstrong.me/tags/Transaction/"/>
    
      <category term="ACID特性" scheme="http://blog.waterstrong.me/tags/ACID%E7%89%B9%E6%80%A7/"/>
    
      <category term="XA协议" scheme="http://blog.waterstrong.me/tags/XA%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="分布式事务" scheme="http://blog.waterstrong.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="锁机制" scheme="http://blog.waterstrong.me/tags/%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    
      <category term="行版本控制" scheme="http://blog.waterstrong.me/tags/%E8%A1%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>AOP面向切面编程</title>
    <link href="http://blog.waterstrong.me/aspect-oriented-programming/"/>
    <id>http://blog.waterstrong.me/aspect-oriented-programming/</id>
    <published>2016-01-20T05:45:32.000Z</published>
    <updated>2016-06-11T13:27:25.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;What-is-AOP&quot;&gt;&lt;a href=&quot;#What-is-AOP&quot; class=&quot;headerlink&quot; title=&quot;What is AOP ?&quot;&gt;&lt;/a&gt;What is AOP ?&lt;/h2&gt;&lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;AOP(Aspect Oriented Programming)，即面向切面编程，是一种设计思想，通过预编译方式或运行时动态代理实现为程序统一添加功能的技术。&lt;/p&gt;
&lt;p&gt;AOP可以理解为OOP(面向对象编程)里程碑式的补充。OOP是从静态角度考虑程序结构，从横向上区分出类，AOP是从动态角度考虑程序运行过程，从纵向上向对象中加入特定的代码，加上时间维度，AOP使得OOP从二维变成三维，由平面变成立体。常常通过AOP来处理一些具有横切性质的系统性服务，如&lt;a href=&quot;/transactional-mechanism-protocol&quot;&gt;事务处理&lt;/a&gt;、安全检查、缓存、对象池管理等。&lt;/p&gt;
&lt;p&gt;通常做法，是在运行时动态地将代码切入到类的指定方法、指定位置上，而切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点，采用AOP可以把几个类共有的代码抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。接下来将详解AOP中的几个核心概念。&lt;/p&gt;
&lt;h3 id=&quot;AOP相关概念&quot;&gt;&lt;a href=&quot;#AOP相关概念&quot; class=&quot;headerlink&quot; title=&quot;AOP相关概念&quot;&gt;&lt;/a&gt;AOP相关概念&lt;/h3&gt;&lt;h4 id=&quot;Aspect（切面-方面）&quot;&gt;&lt;a href=&quot;#Aspect（切面-方面）&quot; class=&quot;headerlink&quot; title=&quot;Aspect（切面/方面）&quot;&gt;&lt;/a&gt;Aspect（切面/方面）&lt;/h4&gt;&lt;p&gt;需要切入到指定类指定方法的代码片段称为切面，包含定义的额外功能的某个模块，相当于OOP中定义的类，但代表的更多是对象间横向的关系，如日志切面、权限切面、事务切面等。&lt;/p&gt;
&lt;h4 id=&quot;Joinpoint（连接点）&quot;&gt;&lt;a href=&quot;#Joinpoint（连接点）&quot; class=&quot;headerlink&quot; title=&quot;Joinpoint（连接点）&quot;&gt;&lt;/a&gt;Joinpoint（连接点）&lt;/h4&gt;&lt;p&gt;程序执行过程中精确执行点，如类中的方法调用、异常抛出等。&lt;/p&gt;
&lt;h4 id=&quot;Advice（通知-增强）&quot;&gt;&lt;a href=&quot;#Advice（通知-增强）&quot; class=&quot;headerlink&quot; title=&quot;Advice（通知/增强）&quot;&gt;&lt;/a&gt;Advice（通知/增强）&lt;/h4&gt;&lt;p&gt;在切面的某个特定的连接点(Joinpoint)上执行的动作，是执行切面的具体逻辑，包括Before，AfterReturning，AfterThrowing，After，Around等Advice。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Before Advice: 前置通知，在方法执行前执行&lt;/li&gt;
&lt;li&gt;AfterReturning: 后置返回通知，在方法执行正常返回后执行，方法没有抛出任何异常&lt;/li&gt;
&lt;li&gt;AfterThrowing Advice: 后置异常通知，在方法执行过程中抛出异常的时候执行&lt;/li&gt;
&lt;li&gt;After Advice: 后置通知/后置最终通知，在方法执行完成后执行，不论是正常返回还是异常退出&lt;/li&gt;
&lt;li&gt;Around Advice: 环绕通知，在方法执行前后和抛出异常时执行，环绕通知可以在方法调用前后完成自定义的行为&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Pointcut（切入点）&quot;&gt;&lt;a href=&quot;#Pointcut（切入点）&quot; class=&quot;headerlink&quot; title=&quot;Pointcut（切入点）&quot;&gt;&lt;/a&gt;Pointcut（切入点）&lt;/h4&gt;&lt;p&gt;匹配连接点(Joinpoint)的断言，通知(Advice)和切入点(Pointcut)表达式关联，并在满足该切入点(Pointcut)的连接点(Joinpoint)上运行，可以认为是连接点的集合，本质是一个捕获连接点的结构，通常可用正则表达式来找到那些匹配的连接点。&lt;/p&gt;
&lt;h4 id=&quot;Target（目标对象）&quot;&gt;&lt;a href=&quot;#Target（目标对象）&quot; class=&quot;headerlink&quot; title=&quot;Target（目标对象）&quot;&gt;&lt;/a&gt;Target（目标对象）&lt;/h4&gt;&lt;p&gt;包含连接点的对象，即被通知或被代理的实际对象。&lt;/p&gt;
&lt;h4 id=&quot;Proxy（代理对象）&quot;&gt;&lt;a href=&quot;#Proxy（代理对象）&quot; class=&quot;headerlink&quot; title=&quot;Proxy（代理对象）&quot;&gt;&lt;/a&gt;Proxy（代理对象）&lt;/h4&gt;&lt;p&gt;通过代理模式创建的对象，从而实现在目标对象连接点处插入切面，代理对象对使用者透明，是程序运行中间产物。&lt;/p&gt;
&lt;h4 id=&quot;Weaving（织入）&quot;&gt;&lt;a href=&quot;#Weaving（织入）&quot; class=&quot;headerlink&quot; title=&quot;Weaving（织入）&quot;&gt;&lt;/a&gt;Weaving（织入）&lt;/h4&gt;&lt;p&gt;织入是一个过程，将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期(Complie)、类装载期(Classload)、运行期(Runtime)进行。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;How-does-it-wok&quot;&gt;&lt;a href=&quot;#How-does-it-wok&quot; class=&quot;headerlink&quot; title=&quot;How does it wok ?&quot;&gt;&lt;/a&gt;How does it wok ?&lt;/h2&gt;&lt;p&gt;AOP技术可以通过反射机制与动态代理机制实现，业务逻辑组件在运行过程中，动态创建一个代理对象供使用者调用，该代理对象已经将切面成功切入到目标方法的连接点上，从而使切面的功能与业务逻辑的功能同时得以执行。当然也可以通过静态织入的方式，引入特定的语法，在编译期间织入有关切面代码。&lt;/p&gt;
&lt;p&gt;反射机制被视为动态（或准动态）语言的一个关键性质，它允许取得任何一个已知名称的class的内部信息，并能直接操作程序的内部属性。&lt;br&gt;动态代理机制指在程序运行时运用反射机制动态创建代理类，后续会有举例讲解到。&lt;/p&gt;
&lt;p&gt;从网络图库中收割到一幅关于AOP理解的图例，表达得非常到位，可以参见一下:&lt;br&gt;&lt;img src=&quot;/assets/aop/aop_diagram.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;图中的切入箭头代表切入的动作，而切入的动作是依赖于称为切入点(Pointcut)的表达式规则匹配找到应该切入到哪些连接点(Joinpoint)上。从图解中可以大致了解到AOP的工作原理和过程，同时加强了对切面、连接点和切入点区别和关系的进一步理解。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Why-AOP&quot;&gt;&lt;a href=&quot;#Why-AOP&quot; class=&quot;headerlink&quot; title=&quot;Why AOP ?&quot;&gt;&lt;/a&gt;Why AOP ?&lt;/h2&gt;&lt;p&gt;OOP引入封装、继承和多态来建立对象层次结构，从而模拟公共行为的一个集合，当需要为分散的对象引入公共行为的时候，OOP则显得无能为力，如日志、权限、事务等功能。这种与主要业务处理流程（核心关注点）关系不大的代码被称为横切（cross cutting），在OO设计中会导致大量重复代码，也不利于模块重用和维护。&lt;/p&gt;
&lt;p&gt;因此需要AOP作为OOP的补充和完善来解决上述问题，AOP的优势主要表现在以下方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解决核心业务逻辑共有代码冗余问题，使代码变更简洁优雅&lt;/li&gt;
&lt;li&gt;只需关心核心的业务逻辑处理，能够提高编写工作效率&lt;/li&gt;
&lt;li&gt;核心关注点和横切关注点分离开来，共有代码集中存放，使得维护工作更加简单轻松&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;When-AOP&quot;&gt;&lt;a href=&quot;#When-AOP&quot; class=&quot;headerlink&quot; title=&quot;When AOP?&quot;&gt;&lt;/a&gt;When AOP?&lt;/h2&gt;&lt;p&gt;其实之前多次提到，当需要为分散的对象引入公共行为的时候，需要处理一些具有横切性质的系统性服务的时候，就可以使用AOP，以下列举了常见的几种应用范围和场合:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Authentication 权限检查&lt;/li&gt;
&lt;li&gt;logging / tracing 日志/跟踪&lt;/li&gt;
&lt;li&gt;Transactions 事务处理&lt;/li&gt;
&lt;li&gt;Exception Handling 异常处理&lt;/li&gt;
&lt;li&gt;profiling / monitoring　分析/监控&lt;/li&gt;
&lt;li&gt;Caching 缓存&lt;/li&gt;
&lt;li&gt;Debugging 调试&lt;/li&gt;
&lt;li&gt;Performance Optimization 性能优化&lt;/li&gt;
&lt;li&gt;Persistence 持久化&lt;/li&gt;
&lt;li&gt;Resource Pooling 资源池&lt;/li&gt;
&lt;li&gt;Synchronization 同步&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;AOP-in-Practice&quot;&gt;&lt;a href=&quot;#AOP-in-Practice&quot; class=&quot;headerlink&quot; title=&quot;AOP in Practice&quot;&gt;&lt;/a&gt;AOP in Practice&lt;/h2&gt;&lt;p&gt;主要针对AOP在Java中的实现，并解读在Spring中AOP的伪代码实现。&lt;/p&gt;
&lt;h3 id=&quot;代理设计模式&quot;&gt;&lt;a href=&quot;#代理设计模式&quot; class=&quot;headerlink&quot; title=&quot;代理设计模式&quot;&gt;&lt;/a&gt;代理设计模式&lt;/h3&gt;&lt;p&gt;首先来回顾一下设计模式中的代理模式:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代理模式(Proxy Design Pattern)，为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是如下图所示的关系，代理对象通过调用实际对象的方法来控制对该实际对象的访问。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/aop/proxy_dp.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;以下简单给出以Hello类为例的伪代码，通过代理对象调用实际对象的sayHello方法，并且在该方法的实际调用前后增加打印记录行为，模拟了拦截方法的过程。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public interface IHello &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void sayHello(String name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 实际的类，已有的操作和行为&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Hello implements IHello &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void sayHello(String name) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         println(“Hello &amp;quot;+name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 代理类，通过调用代理方法访问实际方法并且添加新的职责&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class HelloProxy implements IHello &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private IHello hello = new Hello(); // 指向目标对象,通常在用构造方法传值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void sayHello(String name) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println(&amp;quot;before....&amp;quot;); // 实际调用前添加新的行为&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        hello.sayHello(name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println(&amp;quot;after....&amp;quot;); // 实际调用后添加新的行为&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在回顾了代理模式后，那么进一步了解如何结合代理模式在运行时通过反射机制动态创建代理类，即动态代理技术。&lt;/p&gt;
&lt;h3 id=&quot;JDK动态代理&quot;&gt;&lt;a href=&quot;#JDK动态代理&quot; class=&quot;headerlink&quot; title=&quot;JDK动态代理&quot;&gt;&lt;/a&gt;JDK动态代理&lt;/h3&gt;&lt;p&gt;主要针对JDK动态代理方式，使用接口实现，给出核心部分伪代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class DynamicProxyHello implements InvocationHandler &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Object target; // 目标对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public Object bind(Object target)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.target = target;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 通过目标类和接口来生成代理类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return Proxy.newProxyInstance(target.getClass().getClassLoader(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                      target.getClass().getInterfaces(), this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override // 代理类中拦截了目标对象的方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public Object invoke(Object proxy, Method method, Object[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        do(&amp;quot;before..... &amp;quot;); // 代理类中Advice&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Object result = method.invoke(target, args); // 目标对象的实际方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        do(&amp;quot;after.....&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;特别注意: JDK动态代理只能基于接口动态代理。一般默认情况下，如果目标类是接口，则使用JDK动态代理技术，否则只能使用CGLib来生成代理。&lt;/p&gt;
&lt;h3 id=&quot;CGLib代理&quot;&gt;&lt;a href=&quot;#CGLib代理&quot; class=&quot;headerlink&quot; title=&quot;CGLib代理&quot;&gt;&lt;/a&gt;CGLib代理&lt;/h3&gt;&lt;p&gt;CGLIB方式，使用继承实现：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 主要了解以下几个类, 代码在相应的库中都可以找到, 此处不再赘述&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MethodInterceptor // 方法拦截类, 定义的代理类需要实现该接口以调用intercept方法添加Advice&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Enhancer // 增强类, 继承至AbstractClassGenerator, 主要用于生成目标类的子类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MethodProxy // 生成的子类, 可以在intercept中通过调用proxy.invokeSuper()来调用目标对象的实际方法&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;特别注意: CGLib代理基于接口和非final类代理，不能代理static方法。&lt;/p&gt;
&lt;p&gt;之前有用Java实现过简单的IoC和AOP，有兴趣可以参见工程: &lt;a href=&quot;https://github.com/Waterstrong/summarine&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;summarine&lt;/a&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      AOP(Aspect Oriented Programming)，即面向切面编程，是一种设计思想，通过预编译方式或运行时动态代理实现为程序统一添加功能的技术。
    
    </summary>
    
      <category term="Design Patterns" scheme="http://blog.waterstrong.me/categories/Design-Patterns/"/>
    
    
      <category term="Java" scheme="http://blog.waterstrong.me/tags/Java/"/>
    
      <category term="面向切面编程" scheme="http://blog.waterstrong.me/tags/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    
      <category term="AOP" scheme="http://blog.waterstrong.me/tags/AOP/"/>
    
      <category term="反射机制" scheme="http://blog.waterstrong.me/tags/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    
      <category term="代理模式" scheme="http://blog.waterstrong.me/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Proxy" scheme="http://blog.waterstrong.me/tags/Proxy/"/>
    
      <category term="CGLib" scheme="http://blog.waterstrong.me/tags/CGLib/"/>
    
  </entry>
  
  <entry>
    <title>MySQL在Linux下默认区分大小写</title>
    <link href="http://blog.waterstrong.me/mysql-case-sensitive-linux/"/>
    <id>http://blog.waterstrong.me/mysql-case-sensitive-linux/</id>
    <published>2015-12-20T14:28:42.000Z</published>
    <updated>2016-06-09T04:28:44.000Z</updated>
    
    <content type="html">&lt;p&gt;前段时间遇到一个Hibernate/JPA自动映射MySQL Schema时报错问题，然后查了一下官方文档，原来是MySQL在Linux下默认区分大小写导致的，大致了解了一下，主要涉及两个变量lower_case_file_system和lower_case_table_names。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;默认大小写敏感&quot;&gt;&lt;a href=&quot;#默认大小写敏感&quot; class=&quot;headerlink&quot; title=&quot;默认大小写敏感&quot;&gt;&lt;/a&gt;默认大小写敏感&lt;/h4&gt;&lt;p&gt;MySQL数据库名、表名、别名在Linux下默认区分大小写，root登录通过命令查看其配置：&lt;br&gt;mysql&amp;gt; show variables like ‘lower%’;&lt;br&gt;+————————+——-+&lt;br&gt;| Variable_name          | Value |&lt;br&gt;+————————+——-+&lt;br&gt;| lower_case_file_system | OFF   |&lt;br&gt;| lower_case_table_names | 0     |&lt;br&gt;+————————+——-+&lt;/p&gt;
&lt;h4 id=&quot;变量名和值解释&quot;&gt;&lt;a href=&quot;#变量名和值解释&quot; class=&quot;headerlink&quot; title=&quot;变量名和值解释&quot;&gt;&lt;/a&gt;变量名和值解释&lt;/h4&gt;&lt;p&gt;lower_case_file_system为只读属性，显示出系统的文件系统是否大小写敏感，OFF表示大小写敏感，ON表示大小写不敏感。&lt;br&gt;lower_case_table_names默认为0，表示大小写敏感；设置1表示大小写不敏感，创建的表/数据库以小写形式存放在磁盘上，对于sql语句转换为小写操作；设置2表示创建的表/数据库依据语句上格式存放，但查找都是转换为小写进行。&lt;/p&gt;
&lt;p&gt;lower_case_file_system解释可参见&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_lower_case_file_system&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This variable describes the case sensitivity of file names on the file system where the data directory is located. OFF means file names are case sensitive,ON means they are not case sensitive. This variable is read only because it reflects a file system attribute and setting it would have no effect on the file system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;lower_case_table_names解释可参见&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_lower_case_table_names&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;的说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_lower_case_table_names&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;lower_case_table_names&lt;/a&gt;, If set to 0, table names are stored as specified and comparisons are case sensitive. If set to 1, table names are stored in lowercase on disk and comparisons are not case sensitive. If set to 2, table names are stored as given but compared in lowercase. This option also applies to database names and table aliases. For additional information, see &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.6/en/identifier-case-sensitivity.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Section 9.2.2&lt;/a&gt;, “Identifier Case Sensitivity”.&lt;/p&gt;
&lt;p&gt;On Windows the default value is 1. On OS X, the default value is 2.&lt;/p&gt;
&lt;p&gt;You should &lt;em&gt;not&lt;/em&gt; set &lt;strong&gt;lower_case_table_names&lt;/strong&gt; to 0 if you are running MySQL on a system where the data directory resides on a case-insensitive file system (such as on Windows or OS X). It is an unsupported combination that could result in a hang condition when running an INSERT INTO … SELECT … FROM &lt;strong&gt;tbl_name&lt;/strong&gt; operation with the wrong &lt;strong&gt;tbl_name&lt;/strong&gt; letter case. With MyISAM, accessing table names using different letter cases could cause index corruption.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h4&gt;&lt;p&gt;关于Hibernate/JPA数据库schema自动映射时，对于Linux上MySQL大小写敏感解决方案为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方案一: 设计时在数据库中命名都采用 小写字母或小写字母+下划线 的方式。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方案二: 用root登录，修改/etc/mysql/my.cnf, 在[mysqld]下加入一行：lower_case_table_names=1，重启数据库。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;但是特别注意：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As of MySQL 5.6.27, an error message is printed and the server exits if you attempt to start the server with –lower_case_table_names=0 on a case-insensitive file system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若需要设置lower_case_table_names = 1时，在重启数据库实例之前就需要将原来的数据库和表转换为小写，否则将找不到数据库名。而数据库名无法直接更名，可以新建一个小写的数据库名，然后rename table到新的数据库，完成表的迁移。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间遇到一个Hibernate/JPA自动映射MySQL Schema时报错问题，然后查了一下官方文档，原来是MySQL在Linux下默认区分大小写导致的，大致了解了一下，主要涉及两个变量lower_case_file_system和lower_case_table_names。&lt;br&gt;
    
    </summary>
    
      <category term="Techniques" scheme="http://blog.waterstrong.me/categories/Techniques/"/>
    
    
      <category term="数据库" scheme="http://blog.waterstrong.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://blog.waterstrong.me/tags/MySQL/"/>
    
      <category term="Linux" scheme="http://blog.waterstrong.me/tags/Linux/"/>
    
      <category term="Hibernate" scheme="http://blog.waterstrong.me/tags/Hibernate/"/>
    
      <category term="JPA" scheme="http://blog.waterstrong.me/tags/JPA/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个简单的IoC容器</title>
    <link href="http://blog.waterstrong.me/code-your-ioc/"/>
    <id>http://blog.waterstrong.me/code-your-ioc/</id>
    <published>2015-12-20T12:41:09.000Z</published>
    <updated>2016-06-11T13:27:14.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;IoC容器是依赖注入的框架，用来映射依赖，管理对象创建和生存周期（DI框架）。通过学习IoC可以简单实现一个IoC容器，同时加深对IoC的理解。&lt;/p&gt;
&lt;h3 id=&quot;Let’s-Code-a-IoC-Container&quot;&gt;&lt;a href=&quot;#Let’s-Code-a-IoC-Container&quot; class=&quot;headerlink&quot; title=&quot;Let’s Code a IoC Container&quot;&gt;&lt;/a&gt;Let’s Code a IoC Container&lt;/h3&gt;&lt;p&gt;How to define a bean ?&lt;br&gt;How to store data collection ?&lt;br&gt;How to load component and bean ?&lt;br&gt;How to define a annotation ?&lt;br&gt;How to handle the annotation ?&lt;br&gt;How to create an Object ?&lt;br&gt;How to invoke a Method ?&lt;br&gt;How to initialize the container ?&lt;/p&gt;
&lt;p&gt;之前自己写了一个小的IoC Demo: &lt;a href=&quot;https://github.com/Waterstrong/summarine&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IoC Demo&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      IoC容器是依赖注入的框架，用来映射依赖，管理对象创建和生存周期（DI框架）。通过学习IoC可以简单实现一个IoC容器，同时加深对IoC的理解。
    
    </summary>
    
      <category term="Design Patterns" scheme="http://blog.waterstrong.me/categories/Design-Patterns/"/>
    
    
      <category term="Java" scheme="http://blog.waterstrong.me/tags/Java/"/>
    
      <category term="控制反转" scheme="http://blog.waterstrong.me/tags/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    
      <category term="IoC" scheme="http://blog.waterstrong.me/tags/IoC/"/>
    
      <category term="依赖倒置" scheme="http://blog.waterstrong.me/tags/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE/"/>
    
      <category term="依赖注入" scheme="http://blog.waterstrong.me/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
      <category term="SOLID原则" scheme="http://blog.waterstrong.me/tags/SOLID%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis入门与实践</title>
    <link href="http://blog.waterstrong.me/mybatis-in-practice/"/>
    <id>http://blog.waterstrong.me/mybatis-in-practice/</id>
    <published>2015-10-12T04:52:44.000Z</published>
    <updated>2016-06-11T13:29:32.000Z</updated>
    
    <content type="html">&lt;p&gt;MyBatis是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以对配置和原生Map使用简单的XML或注解，将接口和Java的POJOs(Plain Old Java Objects,普通的Java对象)映射成数据库中的记录。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;What-is-MyBatis&quot;&gt;&lt;a href=&quot;#What-is-MyBatis&quot; class=&quot;headerlink&quot; title=&quot;What is MyBatis?&quot;&gt;&lt;/a&gt;What is MyBatis?&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;MyBatis is a first class persistence framework with support for custom SQL, stored procedures and advanced mappings.&lt;/li&gt;
&lt;li&gt;MyBatis eliminates almost all of the JDBC code and manual setting of parameters and retrieval of results.&lt;/li&gt;
&lt;li&gt;MyBatis can use simple XML or Annotations for configuration and map primitives, Map interfaces and Java POJOs (Plain Old Java Objects) to database records.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.mybatis.org/mybatis-3/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MyBatis 3 Introduction&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还没有时间去总结，不过相对来说不是太难，理论可以错过，但实践部分一定不能错过，之前写过一个Demo: &lt;a href=&quot;https://github.com/Waterstrong/demo-mybatis&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Demo-Mybatis&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;MyBatis是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以对配置和原生Map使用简单的XML或注解，将接口和Java的POJOs(Plain Old Java Objects,普通的Java对象)映射成数据库中的记录。&lt;br&gt;
    
    </summary>
    
      <category term="Frameworks" scheme="http://blog.waterstrong.me/categories/Frameworks/"/>
    
    
      <category term="MyBatis" scheme="http://blog.waterstrong.me/tags/MyBatis/"/>
    
      <category term="数据库" scheme="http://blog.waterstrong.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="持久层框架" scheme="http://blog.waterstrong.me/tags/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"/>
    
      <category term="动态SQL" scheme="http://blog.waterstrong.me/tags/%E5%8A%A8%E6%80%81SQL/"/>
    
      <category term="Java" scheme="http://blog.waterstrong.me/tags/Java/"/>
    
  </entry>
  
</feed>
