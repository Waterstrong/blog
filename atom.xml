<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Watersrong Blog</title>
  <subtitle>Enjoy this moment!</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://waterstrong.me/blog/"/>
  <updated>2016-04-10T15:58:50.000Z</updated>
  <id>http://waterstrong.me/blog/</id>
  
  <author>
    <name>Waterstrong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AOP面向切面编程</title>
    <link href="http://waterstrong.me/blog/aspect-oriented-programming/"/>
    <id>http://waterstrong.me/blog/aspect-oriented-programming/</id>
    <published>2016-04-07T05:45:32.000Z</published>
    <updated>2016-04-10T15:58:50.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;What-is-AOP&quot;&gt;&lt;a href=&quot;#What-is-AOP&quot; class=&quot;headerlink&quot; title=&quot;What is AOP ?&quot;&gt;&lt;/a&gt;What is AOP ?&lt;/h2&gt;&lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;AOP(Aspect Oriented Programming)，即面向切面编程，是一种设计思想，通过预编译方式或运行时动态代理实现为程序统一添加功能的技术。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;AOP可以理解为OOP(面向对象编程)里程碑式的补充。OOP是从静态角度考虑程序结构，从横向上区分出类，AOP是从动态角度考虑程序运行过程，从纵向上向对象中加入特定的代码，加上时间维度，AOP使得OOP从二维变成三维，由平面变成立体。常常通过AOP来处理一些具有横切性质的系统性服务，如&lt;a href=&quot;/blog/transactional-mechanism-protocol&quot;&gt;事务处理&lt;/a&gt;、安全检查、缓存、对象池管理等。&lt;/p&gt;
&lt;p&gt;通常做法，是在运行时动态地将代码切入到类的指定方法、指定位置上，而切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点，采用AOP可以把几个类共有的代码抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。接下来将详解AOP中的几个核心概念。&lt;/p&gt;
&lt;h3 id=&quot;AOP相关概念&quot;&gt;&lt;a href=&quot;#AOP相关概念&quot; class=&quot;headerlink&quot; title=&quot;AOP相关概念&quot;&gt;&lt;/a&gt;AOP相关概念&lt;/h3&gt;&lt;h4 id=&quot;Aspect（切面-方面）&quot;&gt;&lt;a href=&quot;#Aspect（切面-方面）&quot; class=&quot;headerlink&quot; title=&quot;Aspect（切面/方面）&quot;&gt;&lt;/a&gt;Aspect（切面/方面）&lt;/h4&gt;&lt;p&gt;需要切入到指定类指定方法的代码片段称为切面，包含定义的额外功能的某个模块，相当于OOP中定义的类，但代表的更多是对象间横向的关系，如日志切面、权限切面、事务切面等。&lt;/p&gt;
&lt;h4 id=&quot;Joinpoint（连接点）&quot;&gt;&lt;a href=&quot;#Joinpoint（连接点）&quot; class=&quot;headerlink&quot; title=&quot;Joinpoint（连接点）&quot;&gt;&lt;/a&gt;Joinpoint（连接点）&lt;/h4&gt;&lt;p&gt;程序执行过程中精确执行点，如类中的方法调用、异常抛出等。&lt;/p&gt;
&lt;h4 id=&quot;Advice（通知-增强）&quot;&gt;&lt;a href=&quot;#Advice（通知-增强）&quot; class=&quot;headerlink&quot; title=&quot;Advice（通知/增强）&quot;&gt;&lt;/a&gt;Advice（通知/增强）&lt;/h4&gt;&lt;p&gt;在切面的某个特定的连接点(Joinpoint)上执行的动作，是执行切面的具体逻辑，包括Before，AfterReturning，AfterThrowing，After，Around等Advice。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Before Advice: 前置通知，在方法执行前执行&lt;/li&gt;
&lt;li&gt;AfterReturning: 后置返回通知，在方法执行正常返回后执行，方法没有抛出任何异常&lt;/li&gt;
&lt;li&gt;AfterThrowing Advice: 后置异常通知，在方法执行过程中抛出异常的时候执行&lt;/li&gt;
&lt;li&gt;After Advice: 后置通知/后置最终通知，在方法执行完成后执行，不论是正常返回还是异常退出&lt;/li&gt;
&lt;li&gt;Around Advice: 环绕通知，在方法执行前后和抛出异常时执行，环绕通知可以在方法调用前后完成自定义的行为&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Pointcut（切入点）&quot;&gt;&lt;a href=&quot;#Pointcut（切入点）&quot; class=&quot;headerlink&quot; title=&quot;Pointcut（切入点）&quot;&gt;&lt;/a&gt;Pointcut（切入点）&lt;/h4&gt;&lt;p&gt;匹配连接点(Joinpoint)的断言，通知(Advice)和切入点(Pointcut)表达式关联，并在满足该切入点(Pointcut)的连接点(Joinpoint)上运行，可以认为是连接点的集合，本质是一个捕获连接点的结构，通常可用正则表达式来找到那些匹配的连接点。&lt;/p&gt;
&lt;h4 id=&quot;Target（目标对象）&quot;&gt;&lt;a href=&quot;#Target（目标对象）&quot; class=&quot;headerlink&quot; title=&quot;Target（目标对象）&quot;&gt;&lt;/a&gt;Target（目标对象）&lt;/h4&gt;&lt;p&gt;包含连接点的对象，即被通知或被代理的实际对象。&lt;/p&gt;
&lt;h4 id=&quot;Proxy（代理对象）&quot;&gt;&lt;a href=&quot;#Proxy（代理对象）&quot; class=&quot;headerlink&quot; title=&quot;Proxy（代理对象）&quot;&gt;&lt;/a&gt;Proxy（代理对象）&lt;/h4&gt;&lt;p&gt;通过代理模式创建的对象，从而实现在目标对象连接点处插入切面，代理对象对使用者透明，是程序运行中间产物。&lt;/p&gt;
&lt;h4 id=&quot;Weaving（织入）&quot;&gt;&lt;a href=&quot;#Weaving（织入）&quot; class=&quot;headerlink&quot; title=&quot;Weaving（织入）&quot;&gt;&lt;/a&gt;Weaving（织入）&lt;/h4&gt;&lt;p&gt;织入是一个过程，将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期(Complie)、类装载期(Classload)、运行期(Runtime)进行。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;How-does-it-wok&quot;&gt;&lt;a href=&quot;#How-does-it-wok&quot; class=&quot;headerlink&quot; title=&quot;How does it wok ?&quot;&gt;&lt;/a&gt;How does it wok ?&lt;/h2&gt;&lt;p&gt;AOP技术可以通过反射机制与动态代理机制实现，业务逻辑组件在运行过程中，动态创建一个代理对象供使用者调用，该代理对象已经将切面成功切入到目标方法的连接点上，从而使切面的功能与业务逻辑的功能同时得以执行。当然也可以通过静态织入的方式，引入特定的语法，在编译期间织入有关切面代码。&lt;/p&gt;
&lt;p&gt;反射机制被视为动态（或准动态）语言的一个关键性质，它允许取得任何一个已知名称的class的内部信息，并能直接操作程序的内部属性。&lt;br&gt;动态代理机制指在程序运行时运用反射机制动态创建代理类，后续会有举例讲解到。&lt;/p&gt;
&lt;p&gt;从网络图库中收割到一幅关于AOP理解的图例，表达得非常到位，可以参见一下:&lt;br&gt;&lt;img src=&quot;../images/aop/aop_diagram.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;图中的切入箭头代表切入的动作，而切入的动作是依赖于称为切入点(Pointcut)的表达式规则匹配找到应该切入到哪些连接点(Joinpoint)上。从图解中可以大致了解到AOP的工作原理和过程，同时加强了对切面、连接点和切入点区别和关系的进一步理解。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Why-AOP&quot;&gt;&lt;a href=&quot;#Why-AOP&quot; class=&quot;headerlink&quot; title=&quot;Why AOP ?&quot;&gt;&lt;/a&gt;Why AOP ?&lt;/h2&gt;&lt;p&gt;OOP引入封装、继承和多态来建立对象层次结构，从而模拟公共行为的一个集合，当需要为分散的对象引入公共行为的时候，OOP则显得无能为力，如日志、权限、事务等功能。这种与主要业务处理流程（核心关注点）关系不大的代码被称为横切（cross cutting），在OO设计中会导致大量重复代码，也不利于模块重用和维护。&lt;/p&gt;
&lt;p&gt;因此需要AOP作为OOP的补充和完善来解决上述问题，AOP的优势主要表现在以下方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解决核心业务逻辑共有代码冗余问题，使代码变更简洁优雅&lt;/li&gt;
&lt;li&gt;只需关心核心的业务逻辑处理，能够提高编写工作效率&lt;/li&gt;
&lt;li&gt;核心关注点和横切关注点分离开来，共有代码集中存放，使得维护工作更加简单轻松&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;When-AOP&quot;&gt;&lt;a href=&quot;#When-AOP&quot; class=&quot;headerlink&quot; title=&quot;When AOP?&quot;&gt;&lt;/a&gt;When AOP?&lt;/h2&gt;&lt;p&gt;其实之前多次提到，当需要为分散的对象引入公共行为的时候，需要处理一些具有横切性质的系统性服务的时候，就可以使用AOP，以下列举了常见的几种应用范围和场合:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Authentication 权限检查&lt;/li&gt;
&lt;li&gt;logging / tracing 日志/跟踪&lt;/li&gt;
&lt;li&gt;Transactions 事务处理&lt;/li&gt;
&lt;li&gt;Exception Handling 异常处理&lt;/li&gt;
&lt;li&gt;profiling / monitoring　分析/监控&lt;/li&gt;
&lt;li&gt;Caching 缓存&lt;/li&gt;
&lt;li&gt;Debugging 调试&lt;/li&gt;
&lt;li&gt;Performance Optimization 性能优化&lt;/li&gt;
&lt;li&gt;Persistence 持久化&lt;/li&gt;
&lt;li&gt;Resource Pooling 资源池&lt;/li&gt;
&lt;li&gt;Synchronization 同步&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;AOP-in-Practice&quot;&gt;&lt;a href=&quot;#AOP-in-Practice&quot; class=&quot;headerlink&quot; title=&quot;AOP in Practice&quot;&gt;&lt;/a&gt;AOP in Practice&lt;/h2&gt;&lt;p&gt;主要针对AOP在Java中的实现，并解读在Spring中AOP的伪代码实现。&lt;/p&gt;
&lt;h3 id=&quot;代理设计模式&quot;&gt;&lt;a href=&quot;#代理设计模式&quot; class=&quot;headerlink&quot; title=&quot;代理设计模式&quot;&gt;&lt;/a&gt;代理设计模式&lt;/h3&gt;&lt;p&gt;首先来回顾一下设计模式中的代理模式:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代理模式(Proxy Design Pattern)，为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是如下图所示的关系，代理对象通过调用实际对象的方法来控制对该实际对象的访问。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/aop/proxy_dp.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;以下简单给出以Hello类为例的伪代码，通过代理对象调用实际对象的sayHello方法，并且在该方法的实际调用前后增加打印记录行为，模拟了拦截方法的过程。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public interface IHello &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void sayHello(String name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 实际的类，已有的操作和行为&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Hello implements IHello &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void sayHello(String name) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         println(“Hello &amp;quot;+name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 代理类，通过调用代理方法访问实际方法并且添加新的职责&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class HelloProxy implements IHello &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private IHello hello = new Hello(); // 指向目标对象,通常在用构造方法传值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void sayHello(String name) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println(&amp;quot;before....&amp;quot;); // 实际调用前添加新的行为&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        hello.sayHello(name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println(&amp;quot;after....&amp;quot;); // 实际调用后添加新的行为&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在回顾了代理模式后，那么进一步了解如何结合代理模式在运行时通过反射机制动态创建代理类，即动态代理技术。&lt;/p&gt;
&lt;h3 id=&quot;JDK动态代理&quot;&gt;&lt;a href=&quot;#JDK动态代理&quot; class=&quot;headerlink&quot; title=&quot;JDK动态代理&quot;&gt;&lt;/a&gt;JDK动态代理&lt;/h3&gt;&lt;p&gt;主要针对JDK动态代理方式，使用接口实现，给出核心部分伪代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class DynamicProxyHello implements InvocationHandler &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Object target; // 目标对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public Object bind(Object target)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.target = target;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 通过目标类和接口来生成代理类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return Proxy.newProxyInstance(target.getClass().getClassLoader(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                      target.getClass().getInterfaces(), this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override // 代理类中拦截了目标对象的方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public Object invoke(Object proxy, Method method, Object[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        do(&amp;quot;before..... &amp;quot;); // 代理类中Advice&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Object result = method.invoke(target, args); // 目标对象的实际方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        do(&amp;quot;after.....&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;特别注意: JDK动态代理只能基于接口动态代理。一般默认情况下，如果目标类是接口，则使用JDK动态代理技术，否则只能使用CGLib来生成代理。&lt;/p&gt;
&lt;h3 id=&quot;CGLib代理&quot;&gt;&lt;a href=&quot;#CGLib代理&quot; class=&quot;headerlink&quot; title=&quot;CGLib代理&quot;&gt;&lt;/a&gt;CGLib代理&lt;/h3&gt;&lt;p&gt;CGLIB方式，使用继承实现：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 主要了解以下几个类, 代码在相应的库中都可以找到, 此处不再赘述&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MethodInterceptor // 方法拦截, 定义代理类需要实现该接口以调用intercept方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Enhancer // 增强类, 继承至AbstractClassGenerator, 主要用于生成目标类的子类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MethodProxy // 生成的子类, 可以通过调用invokeSuper来调用目标对象的实际方法&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;特别注意: CGLib代理基于接口和非final类代理，不能代理static方法。&lt;/p&gt;
&lt;p&gt;之前有实现过简单的IoC和AOP，有兴趣可以参见工程: &lt;a href=&quot;https://github.com/Waterstrong/summarine&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;summarine&lt;/a&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;What-is-AOP&quot;&gt;&lt;a href=&quot;#What-is-AOP&quot; class=&quot;headerlink&quot; title=&quot;What is AOP ?&quot;&gt;&lt;/a&gt;What is AOP ?&lt;/h2&gt;&lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;AOP(Aspect Oriented Programming)，即面向切面编程，是一种设计思想，通过预编译方式或运行时动态代理实现为程序统一添加功能的技术。&lt;/p&gt;
    
    </summary>
    
      <category term="AOP" scheme="http://waterstrong.me/blog/categories/AOP/"/>
    
    
      <category term="面向切面编程" scheme="http://waterstrong.me/blog/tags/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    
      <category term="反射机制" scheme="http://waterstrong.me/blog/tags/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    
      <category term="Proxy" scheme="http://waterstrong.me/blog/tags/Proxy/"/>
    
      <category term="Java" scheme="http://waterstrong.me/blog/tags/Java/"/>
    
      <category term="CGLib" scheme="http://waterstrong.me/blog/tags/CGLib/"/>
    
      <category term="代理模式" scheme="http://waterstrong.me/blog/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>事务处理机制与协议</title>
    <link href="http://waterstrong.me/blog/transactional-mechanism-protocol/"/>
    <id>http://waterstrong.me/blog/transactional-mechanism-protocol/</id>
    <published>2016-04-04T11:11:03.000Z</published>
    <updated>2016-04-10T15:58:00.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;事务定义及其特性&quot;&gt;&lt;a href=&quot;#事务定义及其特性&quot; class=&quot;headerlink&quot; title=&quot;事务定义及其特性&quot;&gt;&lt;/a&gt;事务定义及其特性&lt;/h2&gt;&lt;h3 id=&quot;什么是事务？&quot;&gt;&lt;a href=&quot;#什么是事务？&quot; class=&quot;headerlink&quot; title=&quot;什么是事务？&quot;&gt;&lt;/a&gt;什么是事务？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;A transaction is a unit of work that you want to treat as “a whole”. It has to either happen in full, or not at all.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直接地讲，就是事务是一个整体，其中的若干处理要么都做，要么都不做。接下来我们就详细地聊聊事务。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;事务的ACID特性&quot;&gt;&lt;a href=&quot;#事务的ACID特性&quot; class=&quot;headerlink&quot; title=&quot;事务的ACID特性&quot;&gt;&lt;/a&gt;事务的ACID特性&lt;/h3&gt;&lt;p&gt;事务的四大特性分别为原子性、一致性、隔离性和永久性，称为ACID特性，也称酸性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;原子性（Atomicity）&lt;/strong&gt;&lt;br&gt;一个事务中所有操作是一个不可分割的操作序列，要么全做，要么全不做。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性（Consistency）&lt;/strong&gt;&lt;br&gt;数据不会因为事务的执行而遭到破坏，一致性保证了这个事务所包含的一系列的操作完成后系统仍然在一个一致的状态，侧重点在于，事务执行前后在某种程度上是等价的，从一个一致状态到另一个一致状态。例如，对银行转帐事务，不管事务成功还是失败，应该保证事务结束后两人存款总额为定值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离性（Isolation）&lt;/strong&gt;&lt;br&gt;一个事务的执行，不受其他事务（进程）的干扰，既并发执行的个事务之间互不干扰，每个事务都有各自的完整数据空间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;永久性（Durability）&lt;/strong&gt;&lt;br&gt;一个事务一旦提交，它对数据库所作的改变将是永久的，使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;数据库事务管理&quot;&gt;&lt;a href=&quot;#数据库事务管理&quot; class=&quot;headerlink&quot; title=&quot;数据库事务管理&quot;&gt;&lt;/a&gt;数据库事务管理&lt;/h3&gt;&lt;p&gt;对于数据库来说，事务的ACID特性是由关系数据库管理系统（RDBMS，数据库系统）来实现的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DBMS采用&lt;strong&gt;日志&lt;/strong&gt;来保证事务的原子性、一致性和持久性。&lt;ul&gt;
&lt;li&gt;日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DBMS采用&lt;strong&gt;锁机制&lt;/strong&gt;来实现事务的隔离性。&lt;ul&gt;
&lt;li&gt;每个事务对所依赖的资源（如行、页或表）请求不同类型的锁，当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。锁可以阻止其他事务以某种可能会导致事务请求锁出错的方式修改资源，当事务不再依赖锁定的资源时，它将释放锁。通常会有共享(S)锁、排它(X)锁、更新(U)锁等，各锁的解释、并发效率、锁冲突及其防止办法不在本文范围，有兴趣可以自行了解。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除了锁定外，也可能采用&lt;strong&gt;行版本控制&lt;/strong&gt;来实现事务隔离性。&lt;ul&gt;
&lt;li&gt;当启用了基于行版本控制的隔离级别时，数据库引擎将维护修改的每一行的版本，应用程序可以指定事务使用行版本查看事务或查询开始时存在的数据，而不是使用锁保护所有读取。通过使用行版本控制，读取操作阻止其他事务的可能性将大大降低，锁数量减少，死锁可能性降低，有效减少了管理锁的开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;锁定和行版本控制可以防止用户读取未提交的数据，还可以防止多个用户尝试同时更改同一数据。如果不进行锁定或行版本控制，对数据执行的查询可能会返回数据库中尚未提交的数据，从而产生意外的结果。&lt;/p&gt;
&lt;p&gt;在了解数据库保证事务ACID特性的基本原理后，那么……对程序提供的数据库编程接口，如何实现事务的呢？接下来介绍本地事务。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;本地事务（Local-Transaction）&quot;&gt;&lt;a href=&quot;#本地事务（Local-Transaction）&quot; class=&quot;headerlink&quot; title=&quot;本地事务（Local Transaction）&quot;&gt;&lt;/a&gt;本地事务（Local Transaction）&lt;/h2&gt;&lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;本地事务(Local Transaction)主要指限制在单个进程内的事务，不涉及多个数据库源，通常会有Begin Transaction … End Transaction来控制事务的开始与结束。以对数据库访问为例，接下来用伪代码实现事务的提交/回滚。&lt;/p&gt;
&lt;h3 id=&quot;本地事务-模型1&quot;&gt;&lt;a href=&quot;#本地事务-模型1&quot; class=&quot;headerlink&quot; title=&quot;本地事务 模型1&quot;&gt;&lt;/a&gt;本地事务 模型1&lt;/h3&gt;&lt;p&gt;设置自动提交的情况：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;conn = getConnection(“url&amp;quot;,&amp;quot;user&amp;quot;,&amp;quot;pwd&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conn.setAutoCommit(true);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;try&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn.execute(...);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;catch(Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;finally &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;本地事务-模型2&quot;&gt;&lt;a href=&quot;#本地事务-模型2&quot; class=&quot;headerlink&quot; title=&quot;本地事务 模型2&quot;&gt;&lt;/a&gt;本地事务 模型2&lt;/h3&gt;&lt;p&gt;设置非自动提交情况：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;conn = getConnection(“url&amp;quot;,&amp;quot;user&amp;quot;,&amp;quot;pwd&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conn.setAutoCommit(false);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;try&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn.execute(…);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn.commit();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;catch(Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn.rollback();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;finally &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这也是最早的访问方式，相信你也发现一些问题了，如果设置为自动提交，当某个操作需要多个执行序列完成时，那么每次execute时都会commit，在很程度上降低了执行效率。若设置为非自动提交，虽然解决了多次execute的问题，但直接暴露conn并不是理想的做法，同时还需要手动close连接。因此，有没有更好地方式呢？答案是肯定的，接下来就看看编程式事务的实现方式。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;编程式事务（Programmatic-Transaction）&quot;&gt;&lt;a href=&quot;#编程式事务（Programmatic-Transaction）&quot; class=&quot;headerlink&quot; title=&quot;编程式事务（Programmatic Transaction）&quot;&gt;&lt;/a&gt;编程式事务（Programmatic Transaction）&lt;/h2&gt;&lt;h3 id=&quot;基本介绍-1&quot;&gt;&lt;a href=&quot;#基本介绍-1&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;编程式事务(Programmatic Transaction)通过编程语言提供的事务API和事务服务提供者进行事务控制。通常的做法是在代码中直接加入处理事务的逻辑，显式地调用其commit()、rollback()等事务管理相关方法。&lt;/p&gt;
&lt;h3 id=&quot;编程式事务-模型&quot;&gt;&lt;a href=&quot;#编程式事务-模型&quot; class=&quot;headerlink&quot; title=&quot;编程式事务 模型&quot;&gt;&lt;/a&gt;编程式事务 模型&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;userTransaction.begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    doSomething();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    doAnotherThing();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    userTransaction.commit();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; catch (Exception ex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    userTransaction.rollback();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;与Local事务的区别&quot;&gt;&lt;a href=&quot;#与Local事务的区别&quot; class=&quot;headerlink&quot; title=&quot;与Local事务的区别&quot;&gt;&lt;/a&gt;与Local事务的区别&lt;/h3&gt;&lt;p&gt;Programmatic与Local Transaction的区别在于Programmatic把Local方式下的conn封装起来，并且手动控制commit和rollback，在一定程序上简化了编程的繁琐性，更加关注事务开始、提交与回滚。你觉得这种方式就已经很棒了么，再想想还有没有更好更创新的方法呢，声明式事务会给你想要的答案。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;声明式事务（Declarative-Transaction）&quot;&gt;&lt;a href=&quot;#声明式事务（Declarative-Transaction）&quot; class=&quot;headerlink&quot; title=&quot;声明式事务（Declarative Transaction）&quot;&gt;&lt;/a&gt;声明式事务（Declarative Transaction）&lt;/h2&gt;&lt;h3 id=&quot;基本介绍-2&quot;&gt;&lt;a href=&quot;#基本介绍-2&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;声明式事务(Declarative Transaction)对目标方法上添加注解(Annotation)或在配置文件中定义，通过对方法前后拦截添加事务处理逻辑。虽然XML配置的方式在前几年很受欢迎，也是具有里程碑的意义，但小编我更青睐注解的方式，况且目前主流的IoC框架也都支持注解方式并且推荐使用。接下来将给出Java形式的伪代码进行解释。&lt;/p&gt;
&lt;h3 id=&quot;声明式事务-模型&quot;&gt;&lt;a href=&quot;#声明式事务-模型&quot; class=&quot;headerlink&quot; title=&quot;声明式事务 模型&quot;&gt;&lt;/a&gt;声明式事务 模型&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@Transaction&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void doSomething() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    process1();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    process2();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    repository.save();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中的@Transaction就是一个注解(Annotation)，其内部实现原理通常采用的是&lt;a href=&quot;/blog/aspect-oriented-programming&quot;&gt;AOP(面向切面编程)&lt;/a&gt;的方式进行方法的拦截。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Object intercept(proxy, method, args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    trans.begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	method.invoke(target, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	trans.commit();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; catch (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	trans.rollback();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以上所有的事务实现方式都主要集中在单一数据库情况，那么对于多数据库协调或者混合数据源情形，如数据库加消息队列等，又如何保证事务正确有效地执行呢？答案是分布式事务，也称全局事务来管理了。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;全局-分布式事务（Global-Distributed-Transaction）&quot;&gt;&lt;a href=&quot;#全局-分布式事务（Global-Distributed-Transaction）&quot; class=&quot;headerlink&quot; title=&quot;全局/分布式事务（Global/Distributed Transaction）&quot;&gt;&lt;/a&gt;全局/分布式事务（Global/Distributed Transaction）&lt;/h2&gt;&lt;h3 id=&quot;基本介绍-3&quot;&gt;&lt;a href=&quot;#基本介绍-3&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;全局/分布式事务(Global/Distributed Transaction)也称XA事务，主要处理跨越多个数据库或进程，多资源协调的情形（例如：访问多个数据库，或数据库加消息队列，又或是多个消息队列等）。其中核心概念包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务管理器（Transaction Manager）&lt;/li&gt;
&lt;li&gt;资源管理器（Resource Manager）&lt;/li&gt;
&lt;li&gt;XA协议标准（eXtended Architecture Standard）&lt;/li&gt;
&lt;li&gt;两阶段提交（Two-Phase Commit）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先来看一个关于JMS Message触发数据库更新操作的实例。&lt;/p&gt;
&lt;h3 id=&quot;JMS触发DB更新的实例&quot;&gt;&lt;a href=&quot;#JMS触发DB更新的实例&quot; class=&quot;headerlink&quot; title=&quot;JMS触发DB更新的实例&quot;&gt;&lt;/a&gt;JMS触发DB更新的实例&lt;/h3&gt;&lt;h4 id=&quot;DB-JMS-伪代码&quot;&gt;&lt;a href=&quot;#DB-JMS-伪代码&quot; class=&quot;headerlink&quot; title=&quot;DB+JMS 伪代码&quot;&gt;&lt;/a&gt;DB+JMS 伪代码&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@JMSListener(...)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void onMessage(...) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    service.merge(...);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Transaction&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void merge(…) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    repository.update(…);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;成功调用过程&quot;&gt;&lt;a href=&quot;#成功调用过程&quot; class=&quot;headerlink&quot; title=&quot;成功调用过程&quot;&gt;&lt;/a&gt;成功调用过程&lt;/h4&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Start messaging transaction&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Receive message&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Start database transaction&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Update database&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Commit database transaction&lt;/li&gt;
&lt;li&gt;Commit messaging transaction&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;成功调用Happy Pass当然没有什么问题，正常提交到数据库，也完成消息提交，但在实际情况中往往不是所期望的。&lt;/p&gt;
&lt;h4 id=&quot;可能失败的情形&quot;&gt;&lt;a href=&quot;#可能失败的情形&quot; class=&quot;headerlink&quot; title=&quot;可能失败的情形&quot;&gt;&lt;/a&gt;可能失败的情形&lt;/h4&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Start messaging transaction&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Receive message&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Start database transaction&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Update database, fail!&lt;/strong&gt; &amp;lt;–&lt;/li&gt;
&lt;li&gt;Roll back database transaction&lt;/li&gt;
&lt;li&gt;Roll back messaging transaction&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到第4步更新数据库时由于某种外键或唯一键约束导致数据库更新失败，这时需要回滚数据库操作以及消息提交，而如何保证Database和JMS之间能够正确工作是首要问题。同理，针对多个数据库或多个消息队列(Queue)/主题(Topic)，Transaction是如何协调多资源的呢？&lt;/p&gt;
&lt;h3 id=&quot;XA事务多资源协调&quot;&gt;&lt;a href=&quot;#XA事务多资源协调&quot; class=&quot;headerlink&quot; title=&quot;XA事务多资源协调&quot;&gt;&lt;/a&gt;XA事务多资源协调&lt;/h3&gt;&lt;h4 id=&quot;X-Open-XA规范接口&quot;&gt;&lt;a href=&quot;#X-Open-XA规范接口&quot; class=&quot;headerlink&quot; title=&quot;X/Open XA规范接口&quot;&gt;&lt;/a&gt;X/Open XA规范接口&lt;/h4&gt;&lt;p&gt;XA协议采用两阶段提交方式来管理分布式事务，XA接口提供资源管理器(RM)与事务管理器(TM)之间进行通信的标准接口。下图来自网络，大致描述了RM和TM的关系以及XA工作范畴，资源管理器管理着多个资源，事务管理器与资源管理器通过XA进行双向通信。&lt;br&gt;&lt;img src=&quot;../images/transactional-mp/XA_standard_interface.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;XA事务实现原理主要是针对每一个XA资源给全局事务和本地事务分配一个xid，每一个XA资源都被加入的XA的管理器中，通过某个方法来决定XA资源已经被加入到事务中并且已经准备就绪，最后统一提交，也就是所谓的两阶段提交。&lt;/p&gt;
&lt;h4 id=&quot;XA两阶段提交协议&quot;&gt;&lt;a href=&quot;#XA两阶段提交协议&quot; class=&quot;headerlink&quot; title=&quot;XA两阶段提交协议&quot;&gt;&lt;/a&gt;XA两阶段提交协议&lt;/h4&gt;&lt;p&gt;两阶段提交协议（The two-phase commit protocol，2PC）是XA用于在全局事务中协调多个资源的机制。两阶段提交协议包含了两个阶段：准备阶段(Prepare)和提交阶段(Commit)。准备阶段需要检查资源的状态(READY, READ_ONLY, NOT_READY)，当且仅当所有资源都是READY状态，准备阶段完成，否则进行Rollback操作。下图来自网络，大致描述了2PC的工作流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/transactional-mp/XA_two_phase_commit.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;TM可以向RM查询事务的状态，RM必须要返回一系列事务的XID，表明事务是prepared状态，还是已经commit的状态。TM会把XID,已完成的RM等这样的事务信息保存起来的，只有当全部的RM提交或者回滚完后，才能丢弃这些事务的信息。&lt;strong&gt;XA事务都假定了TM和RM都是有牢靠的存储，所以也保证了TM重启后可以从日志里恢复还未处理完的事务。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TM/RM初始化和XA两阶段提交伪代码如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// TM/RM Init 伪代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TransactionManager() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xaResourceManager = new XAResourceManager(gtrid);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bool enlistResource(xaResource) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xaResourceHolder = findXAResourceHolder(xaResource);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xaResourceHolderState = new XAResourceHolderState(xaResourceHolder);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xaResourceHolderState.setTransactionTimeoutDate(timeout);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xaResourceManager.enlist(xaResourceHolderState);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;////////////////////////////////&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// XA 2PC 伪代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;XAResourceHolderState&amp;gt; interestedResources;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    interestedResources = preparer.prepare(this); //Get resources and check their states&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; catch(RollbackException ex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rollbackPrepareFailure(ex); // If one of the resources is not ready&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;committer.commit(this, interestedResources); // All resources are ready and commit all at once&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;…… // Other code goes here&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;////////////////////////////////&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 备注:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// preparer.prepare(this) is to get the resources and check their states&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// should call resource manager: transaction.getResourceManager().getAllResources();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;XA事务问题与优化策略&quot;&gt;&lt;a href=&quot;#XA事务问题与优化策略&quot; class=&quot;headerlink&quot; title=&quot;XA事务问题与优化策略&quot;&gt;&lt;/a&gt;XA事务问题与优化策略&lt;/h2&gt;&lt;p&gt;对于非XA事务，范围仅限于单个可识别数据资源的事务操作。对于XA事务，可能出现timeout问题，连锁反应导致系统变慢，同时XA事务也会消耗更多性能资源。因此，仅在同一个事务上下文中需要协调多种资源时，才有必要使用XA，也就是说仅当多个资源必须在同一个事务范畴内被协调时，才有必要用XA。&lt;/p&gt;
&lt;p&gt;针对XA事务可能出现的问题，目前常用的优化策略:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;最后资源提交优化（Last Resource Commit Optimization）&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;最后资源提交优化允许有且仅有一个资源是非XA资源，不必进入到准备阶段而可以直接提交或回滚，如果有这样的一个资源存在XA事务中，那首先应该尝试准备其他XA的资源，然后提交该非XA资源，如果成功，提交其他XA资源，否则回滚所有资源。通常的场景是当如JDBC这样的Driver不支持XA时，可以将其配置成最后参与者(资源)，然后就可以和XA资源进行协作了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一阶段提交优化（One-Phase Commit Optimization）&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;如果使用了XA事务，但资源只有一个，为了节省不必要的开销，XA不会执行两阶段提交，准确地说是没有准备阶段，而是当作单个资源处理并直接提交。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;经验异常（Heuristic Exception）处理&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;在两阶段提交的过程，资源管理器可能会使用“经验化决策”的策略，提交或者回滚，而不受事务管理器的控制。“经验化决策”是指根据多种内部和外部因素做出智能决定的过程，当资源管理器这么做了，它会向客户端报上一个经验异常（Heuristic Exception）。在XA环境下，两阶段提交的过程中，特别是事务参与者在第一阶段产生了响应之后，经验异常最常见的原因是第一阶段和第二阶段之间的超时情况，当网络延迟或故障、资源锁定以及资源使用过量时，资源管理器或许要做出提交或回滚其工作的决定，以释放资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;学海无涯-Keep-Learning&quot;&gt;&lt;a href=&quot;#学海无涯-Keep-Learning&quot; class=&quot;headerlink&quot; title=&quot;学海无涯 Keep Learning&quot;&gt;&lt;/a&gt;学海无涯 Keep Learning&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1. 可以研究下Java中Spring JTA Transaction Manager, 如Bitronix, Atomikos, etc.
2. 可以研究下各数据库如何开启和关闭支持XA事务，如何设置同时处于&amp;quot;准备好&amp;quot;状态的事务的最大数目（max_prepared_transactions）.
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;事务定义及其特性&quot;&gt;&lt;a href=&quot;#事务定义及其特性&quot; class=&quot;headerlink&quot; title=&quot;事务定义及其特性&quot;&gt;&lt;/a&gt;事务定义及其特性&lt;/h2&gt;&lt;h3 id=&quot;什么是事务？&quot;&gt;&lt;a href=&quot;#什么是事务？&quot; class=&quot;headerlink&quot; title=&quot;什么是事务？&quot;&gt;&lt;/a&gt;什么是事务？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;A transaction is a unit of work that you want to treat as “a whole”. It has to either happen in full, or not at all.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直接地讲，就是事务是一个整体，其中的若干处理要么都做，要么都不做。接下来我们就详细地聊聊事务。&lt;/p&gt;
    
    </summary>
    
      <category term="Transaction" scheme="http://waterstrong.me/blog/categories/Transaction/"/>
    
    
      <category term="数据库" scheme="http://waterstrong.me/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="事务" scheme="http://waterstrong.me/blog/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="ACID特性" scheme="http://waterstrong.me/blog/tags/ACID%E7%89%B9%E6%80%A7/"/>
    
      <category term="XA协议" scheme="http://waterstrong.me/blog/tags/XA%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="分布式事务" scheme="http://waterstrong.me/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="锁机制" scheme="http://waterstrong.me/blog/tags/%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    
      <category term="行版本控制" scheme="http://waterstrong.me/blog/tags/%E8%A1%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://waterstrong.me/blog/hello-world/"/>
    <id>http://waterstrong.me/blog/hello-world/</id>
    <published>2016-03-19T16:00:00.000Z</published>
    <updated>2016-03-30T10:37:33.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;Hello-World-Let’s-Begin&quot;&gt;&lt;a href=&quot;#Hello-World-Let’s-Begin&quot; class=&quot;headerlink&quot; title=&quot;Hello World, Let’s Begin!&quot;&gt;&lt;/a&gt;Hello World, Let’s Begin!&lt;/h4&gt;&lt;p&gt;&lt;em&gt;This is a test!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://waterstrong.me&quot;&gt;http://waterstrong.me&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;../images/hello-world/nature.jpg&quot; alt=&quot;Hello Nature&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Hello-World-Let’s-Begin&quot;&gt;&lt;a href=&quot;#Hello-World-Let’s-Begin&quot; class=&quot;headerlink&quot; title=&quot;Hello World, Let’s Begin!&quot;&gt;&lt;/a&gt;Hello World, Let’s Begin!&lt;/h4&gt;&lt;p&gt;&lt;em&gt;This is a test!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://waterstrong.me&quot;&gt;http://waterstrong.me&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://waterstrong.me/blog/categories/Tech/"/>
    
    
      <category term="tech" scheme="http://waterstrong.me/blog/tags/tech/"/>
    
      <category term="life" scheme="http://waterstrong.me/blog/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>MySQL在Linux下默认区分大小写</title>
    <link href="http://waterstrong.me/blog/mysql-case-sensitive-linux/"/>
    <id>http://waterstrong.me/blog/mysql-case-sensitive-linux/</id>
    <published>2015-12-20T14:28:42.000Z</published>
    <updated>2016-03-29T15:47:25.000Z</updated>
    
    <content type="html">&lt;p&gt;前段时间遇到一个Hibernate/JPA自动映射MySQL Schema时报错问题，然后查了一下官方文档，原来是MySQL在Linux下默认区分大小写导致的，大致了解了一下，主要涉及两个变量lower_case_file_system和lower_case_table_names。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;默认大小写敏感&quot;&gt;&lt;a href=&quot;#默认大小写敏感&quot; class=&quot;headerlink&quot; title=&quot;默认大小写敏感&quot;&gt;&lt;/a&gt;默认大小写敏感&lt;/h4&gt;&lt;p&gt;MySQL数据库名、表名、别名在Linux下默认区分大小写，root登录通过命令查看其配置：&lt;br&gt;mysql&amp;gt; show variables like ‘lower%’;&lt;br&gt;+————————+——-+&lt;br&gt;| Variable_name          | Value |&lt;br&gt;+————————+——-+&lt;br&gt;| lower_case_file_system | OFF   |&lt;br&gt;| lower_case_table_names | 0     |&lt;br&gt;+————————+——-+&lt;/p&gt;
&lt;h4 id=&quot;变量名和值解释&quot;&gt;&lt;a href=&quot;#变量名和值解释&quot; class=&quot;headerlink&quot; title=&quot;变量名和值解释&quot;&gt;&lt;/a&gt;变量名和值解释&lt;/h4&gt;&lt;p&gt;lower_case_file_system为只读属性，显示出系统的文件系统是否大小写敏感，OFF表示大小写敏感，ON表示大小写不敏感。&lt;br&gt;lower_case_table_names默认为0，表示大小写敏感；设置1表示大小写不敏感，创建的表/数据库以小写形式存放在磁盘上，对于sql语句转换为小写操作；设置2表示创建的表/数据库依据语句上格式存放，但查找都是转换为小写进行。&lt;/p&gt;
&lt;p&gt;lower_case_file_system解释可参见&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_lower_case_file_system&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This variable describes the case sensitivity of file names on the file system where the data directory is located. OFF means file names are case sensitive,ON means they are not case sensitive. This variable is read only because it reflects a file system attribute and setting it would have no effect on the file system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;lower_case_table_names解释可参见&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_lower_case_table_names&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;的说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_lower_case_table_names&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;lower_case_table_names&lt;/a&gt;, If set to 0, table names are stored as specified and comparisons are case sensitive. If set to 1, table names are stored in lowercase on disk and comparisons are not case sensitive. If set to 2, table names are stored as given but compared in lowercase. This option also applies to database names and table aliases. For additional information, see &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.6/en/identifier-case-sensitivity.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Section 9.2.2&lt;/a&gt;, “Identifier Case Sensitivity”.&lt;/p&gt;
&lt;p&gt;On Windows the default value is 1. On OS X, the default value is 2.&lt;/p&gt;
&lt;p&gt;You should &lt;em&gt;not&lt;/em&gt; set &lt;strong&gt;lower_case_table_names&lt;/strong&gt; to 0 if you are running MySQL on a system where the data directory resides on a case-insensitive file system (such as on Windows or OS X). It is an unsupported combination that could result in a hang condition when running an INSERT INTO … SELECT … FROM &lt;strong&gt;tbl_name&lt;/strong&gt; operation with the wrong &lt;strong&gt;tbl_name&lt;/strong&gt; letter case. With MyISAM, accessing table names using different letter cases could cause index corruption.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h4&gt;&lt;p&gt;关于Hibernate/JPA数据库schema自动映射时，对于Linux上MySQL大小写敏感解决方案为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方案一: 设计时在数据库中命名都采用 小写字母或小写字母+下划线 的方式。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方案二: 用root登录，修改/etc/mysql/my.cnf, 在[mysqld]下加入一行：lower_case_table_names=1，重启数据库。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;但是特别注意：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As of MySQL 5.6.27, an error message is printed and the server exits if you attempt to start the server with –lower_case_table_names=0 on a case-insensitive file system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若需要设置lower_case_table_names = 1时，在重启数据库实例之前就需要将原来的数据库和表转换为小写，否则将找不到数据库名。而数据库名无法直接更名，可以新建一个小写的数据库名，然后rename table到新的数据库，完成表的迁移。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间遇到一个Hibernate/JPA自动映射MySQL Schema时报错问题，然后查了一下官方文档，原来是MySQL在Linux下默认区分大小写导致的，大致了解了一下，主要涉及两个变量lower_case_file_system和lower_case_table_names。&lt;/p&gt;
    
    </summary>
    
      <category term="Database" scheme="http://waterstrong.me/blog/categories/Database/"/>
    
    
      <category term="数据库" scheme="http://waterstrong.me/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://waterstrong.me/blog/tags/MySQL/"/>
    
      <category term="Linux" scheme="http://waterstrong.me/blog/tags/Linux/"/>
    
      <category term="Hibernate" scheme="http://waterstrong.me/blog/tags/Hibernate/"/>
    
      <category term="JPA" scheme="http://waterstrong.me/blog/tags/JPA/"/>
    
  </entry>
  
  <entry>
    <title>C++单例模式实现</title>
    <link href="http://waterstrong.me/blog/cpp-singleton/"/>
    <id>http://waterstrong.me/blog/cpp-singleton/</id>
    <published>2011-12-27T16:00:00.000Z</published>
    <updated>2016-03-26T04:59:45.000Z</updated>
    
    <content type="html">&lt;p&gt;之前遇到关于C++实现单例模式的问题，并非那么简单，主要有部分问题要解决，现在和大家分享一下。我们都知道在Java/C#中实现起来相当容易，但C++确实是有点绕，不过这正是其魅力所在，现在直接上代码，有注释。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using namespace std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Singleton&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static Singleton* sin;//如果定义为static Singleton sin;在C++里这句话相当于有对象产生，还调用了构造函数，而此时此刻的Singleton 还没有创造出来，所以调用里就会有无法解析的外部符号的编译错误&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Singleton() //阻止创建实例&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt;&amp;quot;con&amp;quot;&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static Singleton* GetInstance()//返回实例，要么返回指针，要么返回引用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt;&amp;quot;ins&amp;quot;&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return sin;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static void Destroy()//应该显式释放sin，如果不显式释放，或者直接在析构函数里delete，当然在外部显式访问析构函数访问没问题，但是在delete sin时会再次调用析构函数，这样将造成不断地循环调用析构函数，这是非常可怕的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt;&amp;quot;destroy&amp;quot;&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(sin)//显式释放&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            delete sin;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sin = NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ~Singleton()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt;&amp;quot;descon&amp;quot;&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Singleton* Singleton::sin = new Singleton();//全局初始化, 必须new出来，在编译时就初始化了，如果出现派生的情况也只会有一个惟一的实例，而且构造函数声明为private后，派生类也没法写出构造函数，要注意的一点就是如果只有一个文件就可以直接写在后面，如果有.h和.cpp两个文件，那初始化应该写在.cpp文件中，否则可能会重定义错误。如果初始化为null,下次用时再判断并new的话必须要加双重锁定，消耗比较大，所以就采用这种方式了，不过这种消耗只有第一次才会出现，以后都不会new，但每次都要判断是否为null,也是很不爽的事。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int _tmain(int argc, _TCHAR* argv[])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Singleton* sin1 = Singleton::GetInstance();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Singleton* sin2 = Singleton::GetInstance();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (sin1 == sin2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt;&amp;quot;the same&amp;quot;&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt;&amp;quot;not the same&amp;quot;&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Singleton::Destroy();//一定要显式调用释放sin，可能还有其方法，但暂时还没有想到，最好能隐式释放，毕竟让客户端负责释放是不太明智的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    system(&amp;quot;pause&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;补充：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;process.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;Windows.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HANDLE mutex = CreateMutex(NULL,FALSE,NULL); //创建互斥量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;WaitForSingleObject(mutex,INFINITE);//等待互斥量&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;//……互斥代码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ReleaseMutex(mutex);//释放权限，让下一个线程可以进入&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CloseHandle(mutex);//关闭创建的mutex句柄&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mutex = NULL;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;双重锁定，当然要先创建互斥量并初始化，最后要清除。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static Singleton* GetInstance()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(!sin)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        WaitForSingleObject(mutex,INFINITE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (!sin)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sin = new Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ReleaseMutex(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sin = new Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return sin;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;之前遇到关于C++实现单例模式的问题，并非那么简单，主要有部分问题要解决，现在和大家分享一下。我们都知道在Java/C#中实现起来相当容易，但C++确实是有点绕，不过这正是其魅力所在，现在直接上代码，有注释。&lt;/p&gt;
    
    </summary>
    
      <category term="Design Pattern" scheme="http://waterstrong.me/blog/categories/Design-Pattern/"/>
    
    
      <category term="设计模式" scheme="http://waterstrong.me/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="C++" scheme="http://waterstrong.me/blog/tags/C/"/>
    
      <category term="Singleton" scheme="http://waterstrong.me/blog/tags/Singleton/"/>
    
  </entry>
  
  <entry>
    <title>DirectShow获取摄像头图像</title>
    <link href="http://waterstrong.me/blog/directshow-graphics/"/>
    <id>http://waterstrong.me/blog/directshow-graphics/</id>
    <published>2011-12-27T16:00:00.000Z</published>
    <updated>2016-03-29T15:50:03.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;在Windows下配置DirectX-Aug09-DShow获取摄像头图像&quot;&gt;&lt;a href=&quot;#在Windows下配置DirectX-Aug09-DShow获取摄像头图像&quot; class=&quot;headerlink&quot; title=&quot;在Windows下配置DirectX Aug09 DShow获取摄像头图像:&quot;&gt;&lt;/a&gt;在Windows下配置DirectX Aug09 DShow获取摄像头图像:&lt;/h4&gt;&lt;p&gt;1、首先带例子安装DXSDK_Aug09.exe，可在&lt;a href=&quot;http://msdn.microsoft.com/directx/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网&lt;/a&gt;下载&lt;a href=&quot;http://download.microsoft.com/download/4/C/F/4CFED5F5-B11C-4159-9ADC-E133B7E42E5C/DXSDK_Aug09.exe&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DirectX August 2009&lt;/a&gt;。假设安装路径为：D:\Program Files\Microsoft DirectX SDK (August 2009)。&lt;/p&gt;
&lt;p&gt;2、将strmbasd+&amp;amp;+strmbase文件夹中的两个dll文件拷到D:\Program Files\Microsoft DirectX SDK (August 2009)\Lib\x86下(64位机到x64下)。&lt;/p&gt;
&lt;p&gt;3、将DShow文件拷到D:\Program Files\Microsoft DirectX SDK (August 2009)\sample\C++下。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;4、Visual Studio中包含文件D:\Program Files\Microsoft DirectX SDK (August 2009)\Include和D:\Program Files\Microsoft DirectX SDK (August 2009)\Samples\C++\DirectShow\BaseClasses。&lt;/p&gt;
&lt;p&gt;5、添加库文件D:\Program Files\Microsoft DirectX SDK (August 2009)\Lib\x86到最顶端。&lt;/p&gt;
&lt;p&gt;6、添加strmbase.lib strmbasd.lib到lib链接器中。&lt;/p&gt;
&lt;p&gt;7、将ARFrameGrabber文件夹中的ARFrameGrabber.h 和 ARFrameGrabber.cpp 拷贝到到自己工程中（自己修改一下，加了些逻辑判断），再添加进来。测试一下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include&amp;lt;iostream&amp;gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;highgui.h&amp;gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;ARFrameGrabber.h&amp;quot;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;Windows.h&amp;gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using namespace std;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int _tmain(int argc, _TCHAR* argv[])  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static ARFrameGrabber frameGrabber;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    IplImage ds_frame;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int stride;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BYTE* myBuffer;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    frameGrabber.Init(0, true); //设置支持directshow的设备编号，从0开始  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    frameGrabber.SetFlippedImage(true); //图像是否翻转  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    IplImage* frame=NULL;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cvNamedWindow(&amp;quot;test&amp;quot;,0);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while (true)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        frame = NULL;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        frameGrabber.GrabByteFrame(); //获取一帧  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        myBuffer = frameGrabber.GetByteBuffer(); //得到图像的缓冲  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(!myBuffer)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            UINT nRet=MessageBox(0,&amp;quot;警告：\n\n摄像头正被其他程序占用，请关闭可能使用摄像头的程序后重试！&amp;quot;,&amp;quot;启动出错&amp;quot;,MB_RETRYCANCEL|MB_ICONEXCLAMATION);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(nRet==IDRETRY)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                frameGrabber.GrabByteFrame(); //获取一帧  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                myBuffer = frameGrabber.GetByteBuffer(); //得到图像的缓冲  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            else  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                cvDestroyAllWindows();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                exit(0);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int width = frameGrabber.GetWidth();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int height = frameGrabber.GetHeight();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        stride  = (width * sizeof( RGBTRIPLE ) + 3) &amp;amp; -4;//图像每行所占的字节数，4的倍数，对齐  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cvInitImageHeader( &amp;amp;ds_frame, cvSize(width, height), 8, 3,IPL_ORIGIN_BL, 4 ); //创建IplImage  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ds_frame.widthStep = stride;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cvSetData( &amp;amp;ds_frame, myBuffer, stride ); //copy数据  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        frame = &amp;amp;ds_frame;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cvShowImage(&amp;quot;test&amp;quot;,frame);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (cvWaitKey(3)==27)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cvDestroyAllWindows();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h4 id=&quot;遇到问题一：&quot;&gt;&lt;a href=&quot;#遇到问题一：&quot; class=&quot;headerlink&quot; title=&quot;遇到问题一：&quot;&gt;&lt;/a&gt;遇到问题一：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;如果报错: &amp;quot;dxtrans.h&amp;quot;: No such file or directory&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在qedit.h 中添加如下&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define __IDxtCompositor_INTERFACE_DEFINED__   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define __IDxtAlphaSetter_INTERFACE_DEFINED__   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define __IDxtJpeg_INTERFACE_DEFINED__   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define __IDxtKey_INTERFACE_DEFINED__&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再修改qedit.h 中引用 dxtrans.h 的部分，要求注释掉&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;oaidl.h&amp;quot;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;ocidl.h&amp;quot;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//#include &amp;quot;dxtrans.h&amp;quot;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;amstream.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h4 id=&quot;遇到问题二：&quot;&gt;&lt;a href=&quot;#遇到问题二：&quot; class=&quot;headerlink&quot; title=&quot;遇到问题二：&quot;&gt;&lt;/a&gt;遇到问题二：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//#include &amp;lt;qedit.h&amp;gt; 出现问题，或者找不到了什么基类可以直接用下面方式  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define __IDxtCompositor_INTERFACE_DEFINED__   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define __IDxtAlphaSetter_INTERFACE_DEFINED__   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define __IDxtJpeg_INTERFACE_DEFINED__   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define __IDxtKey_INTERFACE_DEFINED__   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;qedit.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;注：以上除DXSDK_Aug09.exe安装文件外(553MB)，其他都可在资源《&lt;a href=&quot;http://download.csdn.net/download/waterstrong/3981334&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;配置DX_Aug09_DShow获取摄像头图像&lt;/a&gt;》中下载。&lt;/em&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;在Windows下配置DirectX-Aug09-DShow获取摄像头图像&quot;&gt;&lt;a href=&quot;#在Windows下配置DirectX-Aug09-DShow获取摄像头图像&quot; class=&quot;headerlink&quot; title=&quot;在Windows下配置DirectX Aug09 DShow获取摄像头图像:&quot;&gt;&lt;/a&gt;在Windows下配置DirectX Aug09 DShow获取摄像头图像:&lt;/h4&gt;&lt;p&gt;1、首先带例子安装DXSDK_Aug09.exe，可在&lt;a href=&quot;http://msdn.microsoft.com/directx/&quot;&gt;官网&lt;/a&gt;下载&lt;a href=&quot;http://download.microsoft.com/download/4/C/F/4CFED5F5-B11C-4159-9ADC-E133B7E42E5C/DXSDK_Aug09.exe&quot;&gt;DirectX August 2009&lt;/a&gt;。假设安装路径为：D:\Program Files\Microsoft DirectX SDK (August 2009)。&lt;/p&gt;
&lt;p&gt;2、将strmbasd+&amp;amp;+strmbase文件夹中的两个dll文件拷到D:\Program Files\Microsoft DirectX SDK (August 2009)\Lib\x86下(64位机到x64下)。&lt;/p&gt;
&lt;p&gt;3、将DShow文件拷到D:\Program Files\Microsoft DirectX SDK (August 2009)\sample\C++下。&lt;/p&gt;
    
    </summary>
    
      <category term="Graphics" scheme="http://waterstrong.me/blog/categories/Graphics/"/>
    
    
      <category term="C++" scheme="http://waterstrong.me/blog/tags/C/"/>
    
      <category term="图形图像" scheme="http://waterstrong.me/blog/tags/%E5%9B%BE%E5%BD%A2%E5%9B%BE%E5%83%8F/"/>
    
      <category term="DirectX" scheme="http://waterstrong.me/blog/tags/DirectX/"/>
    
      <category term="OpenCV" scheme="http://waterstrong.me/blog/tags/OpenCV/"/>
    
  </entry>
  
</feed>
