<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Watersrong Blog</title>
  <subtitle>Enjoy this moment!</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://waterstrong.me/blog/"/>
  <updated>2016-04-19T05:40:26.000Z</updated>
  <id>http://waterstrong.me/blog/</id>
  
  <author>
    <name>Waterstrong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Concourse CI 介绍</title>
    <link href="http://waterstrong.me/blog/concourse-ci/"/>
    <id>http://waterstrong.me/blog/concourse-ci/</id>
    <published>2016-04-19T05:02:02.000Z</published>
    <updated>2016-04-19T05:40:26.000Z</updated>
    
    <content type="html">&lt;p&gt;目前主流的CI/CD工具包括Concourse CI, Jenkins, Travis CI和GoCD，它们各自到底有什么优缺点，Concourse CI有什么优势和亮点能够跻身April ‘16的&lt;a href=&quot;https://www.thoughtworks.com/radar/tools/concourse-ci&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ThoughtWorks Tech Radar&lt;/a&gt;？&lt;/p&gt;
&lt;h3 id=&quot;What-is-Concourse&quot;&gt;&lt;a href=&quot;#What-is-Concourse&quot; class=&quot;headerlink&quot; title=&quot;What is Concourse?&quot;&gt;&lt;/a&gt;What is Concourse?&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Concourse is a CI/CD tool that treats build pipelines and artifacts as first-class citizens&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Keeping all configuration in declarative files that can be checked into version control&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Why-Concourse&quot;&gt;&lt;a href=&quot;#Why-Concourse&quot; class=&quot;headerlink&quot; title=&quot;Why Concourse?&quot;&gt;&lt;/a&gt;Why Concourse?&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Requires a CI/CD Tool&lt;/li&gt;
&lt;li&gt;Concourse vs Jenkins/Travis CI/GoCD&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;vs-Jenkins&quot;&gt;&lt;a href=&quot;#vs-Jenkins&quot; class=&quot;headerlink&quot; title=&quot;vs. Jenkins&quot;&gt;&lt;/a&gt;vs. Jenkins&lt;/h4&gt;&lt;h4 id=&quot;vs-Travis-CI&quot;&gt;&lt;a href=&quot;#vs-Travis-CI&quot; class=&quot;headerlink&quot; title=&quot;vs. Travis CI&quot;&gt;&lt;/a&gt;vs. Travis CI&lt;/h4&gt;&lt;h4 id=&quot;vs-GoCD&quot;&gt;&lt;a href=&quot;#vs-GoCD&quot; class=&quot;headerlink&quot; title=&quot;vs. GoCD&quot;&gt;&lt;/a&gt;vs. GoCD&lt;/h4&gt;&lt;h3 id=&quot;Concepts&quot;&gt;&lt;a href=&quot;#Concepts&quot; class=&quot;headerlink&quot; title=&quot;Concepts&quot;&gt;&lt;/a&gt;Concepts&lt;/h3&gt;&lt;h3 id=&quot;Impact&quot;&gt;&lt;a href=&quot;#Impact&quot; class=&quot;headerlink&quot; title=&quot;Impact&quot;&gt;&lt;/a&gt;Impact&lt;/h3&gt;&lt;p&gt;Bringing some interesting new ideas&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pluggable Resource Interface&lt;/li&gt;
&lt;li&gt;Running builds in Containers Natively&lt;/li&gt;
&lt;li&gt;Zero Snowflake-able Configuration&lt;/li&gt;
&lt;li&gt;Submitting builds from the local file system up to run in CI&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      目前主流的CI/CD工具包括Concourse CI, Jenkins, Travis CI和GoCD，它们各自到底有什么优缺点，Concourse CI有什么优势和亮点能够跻身Tech Radar?
    
    </summary>
    
      <category term="DevOps" scheme="http://waterstrong.me/blog/categories/DevOps/"/>
    
    
      <category term="CI/CD" scheme="http://waterstrong.me/blog/tags/CI-CD/"/>
    
      <category term="持续集成" scheme="http://waterstrong.me/blog/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
      <category term="持续部署" scheme="http://waterstrong.me/blog/tags/%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2/"/>
    
      <category term="Concourse" scheme="http://waterstrong.me/blog/tags/Concourse/"/>
    
      <category term="Jenkins" scheme="http://waterstrong.me/blog/tags/Jenkins/"/>
    
      <category term="Travis CI" scheme="http://waterstrong.me/blog/tags/Travis-CI/"/>
    
      <category term="GoCD" scheme="http://waterstrong.me/blog/tags/GoCD/"/>
    
      <category term="Tool" scheme="http://waterstrong.me/blog/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>AWS EC2搭建VPN服务器</title>
    <link href="http://waterstrong.me/blog/aws-ec2-vpn/"/>
    <id>http://waterstrong.me/blog/aws-ec2-vpn/</id>
    <published>2016-04-13T15:30:52.000Z</published>
    <updated>2016-04-17T04:09:36.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;主要介绍如何在12个月免费的AWS EC2中搭建基于PPTP协议的VPN服务用于翻越GFW，平时Google搜索一下也很方便，会涉及CentOS, RedHat和Ubuntu操作系统。虽然自己有用其他翻Wall软件，也有我司的VPN服务帐号，但还是想折腾一下，说不定还可以出售给小白同学。&lt;/p&gt;
&lt;p&gt;而且自己搭建VPN有诸多好处:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;暂时免费，只要不超出AWS免费流量和时间限制;&lt;/li&gt;
&lt;li&gt;速度有保障，可以选择最快地区的AWS EC2进行搭建;&lt;/li&gt;
&lt;li&gt;自己的帐号自己管理，流量也自己控制，安全有保障。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;AWS EC2已经在另一篇Blog中有相关介绍，有兴趣可以参见&lt;a href=&quot;/blog/aws-ec2-basic&quot;&gt;AWS EC2入门篇&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;VPN: Virtual Private Network, 虚拟专用网络，是一种远程访问技术，主要功能是在公用网络上建立专用网络，进行加密通讯，支持跨平台。&lt;br&gt;PPTP: Point to Point Tunneling Protocol, 点对点隧道协议，是PPP协议的基础上的增强型安全协议，支持多协议VPN，默认端口号1723。利于PPTP可以快速搭建自己的VPN，并且在很多的移动设备上也支持PPTP，同时PPTP速度也较快，资源消耗也小。&lt;/p&gt;
&lt;p&gt;简单介绍了之后，可以尝试以下步骤在服务器上搭建一个VPN服务。&lt;/p&gt;
&lt;h3 id=&quot;Step1-安装PPTP&quot;&gt;&lt;a href=&quot;#Step1-安装PPTP&quot; class=&quot;headerlink&quot; title=&quot;Step1 - 安装PPTP&quot;&gt;&lt;/a&gt;Step1 - 安装PPTP&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;On Ubuntu 14.04 x64:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo su  # 登录服务器后切换到超级管理员&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;apt-get update -y  # 更新源&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;apt-get install pptpd -y  # 安装pptpd, 同时会自动安装依赖组件ppp和iptables&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;On CentOS or Red Hat Linux 6.x x64:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo su  # 登录服务器后切换到超级管理员&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum update -y  # 更新源&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum install pptpd -y  # 安装pptpd, 同时会自动安装依赖组件ppp和iptables&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;如果找不到源，返回&lt;code&gt;No package pptpd available&lt;/code&gt;，如Amazon AMI Linux，可以采用以下方法解决: &lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;方法一: 下载rpm包直接安装（推荐）&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 针对EL6.x版本:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wget -c http://poptop.sourceforge.net/yum/stable/packages/pptpd-1.4.0-1.el6.x86_64.rpm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 针对EL7.x版本:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wget -c http://dl.fedoraproject.org/pub/epel/7/x86_64/p/pptpd-1.4.0-2.el7.x86_64.rpm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rpm -ivh pptpd-1.4.0-1.el6.x86_64.rpm  # 安装显示安装进度--install--verbose--hash&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;方法二: 需要添加新的源&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum repolist  # 查看yum源列表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 只针对EL7版本:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum localinstall http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-5.noarch.rpm -y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum makecache  # 将服务器上的软件包信息下载到本地缓存, 以提高搜索和安装软件的速度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum repolist  # 可以再次查看新加入的列表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum install pptpd -y  # 再次执行安装pptpd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 可用 yum-config-manager --disable &amp;lt;repoid&amp;gt; 删除源&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Step2-配置PPTP&quot;&gt;&lt;a href=&quot;#Step2-配置PPTP&quot; class=&quot;headerlink&quot; title=&quot;Step2 - 配置PPTP&quot;&gt;&lt;/a&gt;Step2 - 配置PPTP&lt;/h3&gt;&lt;p&gt;编辑&lt;code&gt;/etc/pptpd.conf&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vim /etc/pptpd.conf&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;搜索&lt;code&gt;localip&lt;/code&gt;并去掉以下字段前的注释符&lt;code&gt;#&lt;/code&gt;，保存并退出&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;localip 192.168.0.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remoteip 192.168.0.234-238,192.168.0.245&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;localip&lt;/code&gt;表示VPN服务器使用的地址，而&lt;code&gt;remoteip&lt;/code&gt;表示分配给VPN客户端的地址范围，当然也可以自定义设置范围。&lt;/p&gt;
&lt;h3 id=&quot;Step3-添加DNS解析&quot;&gt;&lt;a href=&quot;#Step3-添加DNS解析&quot; class=&quot;headerlink&quot; title=&quot;Step3 - 添加DNS解析&quot;&gt;&lt;/a&gt;Step3 - 添加DNS解析&lt;/h3&gt;&lt;p&gt;针对&lt;code&gt;Ubuntu&lt;/code&gt;系统，编辑&lt;code&gt;/etc/ppp/pptpd-options&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vim /etc/ppp/pptpd-options&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;针对&lt;code&gt;CentOS/RedHat&lt;/code&gt;，编辑&lt;code&gt;/etc/ppp/options.pptpd&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vim /etc/ppp/options.pptpd&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在文件中搜索&lt;code&gt;ms-dns&lt;/code&gt;，去掉以下字段前的注释符&lt;code&gt;#&lt;/code&gt;，并修改为以下值后保存退出&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ms-dns 8.8.8.8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ms-dns 8.8.4.4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上两条配置指定了使用Google Public DNS服务器。&lt;/p&gt;
&lt;h3 id=&quot;Step4-添加VPN用户&quot;&gt;&lt;a href=&quot;#Step4-添加VPN用户&quot; class=&quot;headerlink&quot; title=&quot;Step4 - 添加VPN用户&quot;&gt;&lt;/a&gt;Step4 - 添加VPN用户&lt;/h3&gt;&lt;p&gt;编辑&lt;code&gt;/etc/ppp/chap-secrets&lt;/code&gt;，添加用户名和密码条目，格式为&lt;code&gt;[username] [service] [password] [ip]&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# client	server  	secret		IP addresses&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vpnuser01	pptpd   	123456		*&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中，用户名和密码可自行设置，服务名应为&lt;code&gt;pptpd&lt;/code&gt;，IP表明允许登录的ip列表，如果允许所有ip可以设置为&lt;code&gt;*&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;Step5-开启IPv4转发&quot;&gt;&lt;a href=&quot;#Step5-开启IPv4转发&quot; class=&quot;headerlink&quot; title=&quot;Step5 - 开启IPv4转发&quot;&gt;&lt;/a&gt;Step5 - 开启IPv4转发&lt;/h3&gt;&lt;p&gt;为了支持IP数据包的转发，需要开启IPv4转发功能。&lt;br&gt;编辑&lt;code&gt;/etc/sysctl.conf&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vim /etc/sysctl.conf&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;搜索并找到以下字段，去掉注释并修改为以下值：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;net.ipv4.ip_forward = 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;= 1&lt;/code&gt;表明开启了服务器内核支持IP数据包转发功能，允许通过PPTP协议在公有IP和私有IPs之间进行数据包转发。&lt;/p&gt;
&lt;p&gt;使得修改生效，需要执行：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sysctl -p&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Step6-创建NAT规则&quot;&gt;&lt;a href=&quot;#Step6-创建NAT规则&quot; class=&quot;headerlink&quot; title=&quot;Step6 - 创建NAT规则&quot;&gt;&lt;/a&gt;Step6 - 创建NAT规则&lt;/h3&gt;&lt;p&gt;创建网络地址转换，添加防火墙规则到iptables中，在终端执行以下命令&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE  # 将所有目标IP包转向eth0接口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;service iptables save  # 添加规则后重启会失效，所以需要保存，若不支持，可添加到rc.local文件中开机自动设置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 也可使用命令 iptables-save&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;service iptables restart  # 重启iptables，貌似针对Ubuntu无效(忽略)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;pptpd默认监听1723端口，可以通过以下命令查看：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;netstat -nap | grep pptpd&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(可选)如果端口没有开启则开启相关端口:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;iptables -I INPUT -p tcp –dport 1723 -j ACCEPT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iptables -I INPUT -p tcp –dport 47 -j ACCEPT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iptables -I INPUT -p UDP --dport 53 -j ACCEPT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iptables -I INPUT -p gre -j ACCEPT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;service iptables save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Step7-启动PPTP服务&quot;&gt;&lt;a href=&quot;#Step7-启动PPTP服务&quot; class=&quot;headerlink&quot; title=&quot;Step7 - 启动PPTP服务&quot;&gt;&lt;/a&gt;Step7 - 启动PPTP服务&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;chkconfig pptpd on  # 设置开机启动VPN服务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;service pptpd restart  # 重启VPN服务, 当然可以用stop/start来停止/启动服务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;service pptpd status  # 查看VPN服务当前运行状态&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到服务已经启动:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-vpn/linux_pptpd_started.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;针对Ubuntu，即使运行start命令，但查看status还是显示&lt;code&gt;pptpd is not running&lt;/code&gt;，可以编辑&lt;code&gt;/etc/init.d/pptpd&lt;/code&gt;文件，搜索&lt;code&gt;status&lt;/code&gt;找到该行&lt;code&gt;status_of_proc &amp;quot;$PIDFILE&amp;quot; &amp;quot;$DAEMON&amp;quot; &amp;quot;$NAME&amp;quot; &amp;amp;&amp;amp; exit 0 || exit $?&lt;/code&gt;，并添加&lt;code&gt;-p&lt;/code&gt;参数：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;status_of_proc -p &amp;quot;$PIDFILE&amp;quot; &amp;quot;$DAEMON&amp;quot; &amp;quot;$NAME&amp;quot; &amp;amp;&amp;amp; exit 0 || exit $?&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;针对VPN日志，在CentOS中，VPN服务器默认会写日志到&lt;code&gt;/var/log/messages&lt;/code&gt;中; 在Ubuntu中，VPN服务器默认会写日志到&lt;code&gt;/var/log/syslog&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;以上步骤完成配置正确后，可以利用自己的终端设备连接到VPN上网了。&lt;/p&gt;
&lt;h3 id=&quot;Step8-使用VPN服务&quot;&gt;&lt;a href=&quot;#Step8-使用VPN服务&quot; class=&quot;headerlink&quot; title=&quot;Step8 - 使用VPN服务&quot;&gt;&lt;/a&gt;Step8 - 使用VPN服务&lt;/h3&gt;&lt;h4 id=&quot;在Mac-OS-X上配置VPN&quot;&gt;&lt;a href=&quot;#在Mac-OS-X上配置VPN&quot; class=&quot;headerlink&quot; title=&quot;在Mac OS X上配置VPN&quot;&gt;&lt;/a&gt;在Mac OS X上配置VPN&lt;/h4&gt;&lt;p&gt;System Preferences(系统设置) -&amp;gt; Network(网络):&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-vpn/mac_system_network.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;选择左下角的&lt;code&gt;+&lt;/code&gt;号添加VPN，选择PPTP类型，点击create创建:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-vpn/mac_new_vpn.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Advanced(高级) -&amp;gt; Options(选项) -&amp;gt; 勾选Session Options中的所有项 -&amp;gt; OK保存:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-vpn/mac_vpn_options.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;填写VPN相关服务器地址、用户名、密码等信息 -&amp;gt; 点击Apply应用所有修改 -&amp;gt; 点击connect连接VPN服务:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-vpn/mac_vpn_connected.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中Server Address绑定了子域名&lt;code&gt;aws.vpn.xxx&lt;/code&gt;，在需要更改服务主机时只需要重定位DNS即可，Client终端配置不需要更改，当然要做负载时也很方便，同时也利用记忆。&lt;/p&gt;
&lt;h4 id=&quot;在iPhone-6s上配置VPN&quot;&gt;&lt;a href=&quot;#在iPhone-6s上配置VPN&quot; class=&quot;headerlink&quot; title=&quot;在iPhone 6s上配置VPN&quot;&gt;&lt;/a&gt;在iPhone 6s上配置VPN&lt;/h4&gt;&lt;p&gt;首先进入Settings设置，选择VPN项（也可以借助第三方软件，如AnyConnect）:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-vpn/6s_vpn_setting.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;选择PPTP类型，填写服务器地址、用户名、密码等，然后保存:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-vpn/6s_new_vpn.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;点击connect连接VPN服务:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-vpn/6s_vpn_connected.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;进入已连接的VPN查看分配的IP，连接时间等详细信息，当然也可以删除VPN:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-vpn/6s_vpn_detail.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;测试访问Google，在手机浏览器输入&lt;code&gt;www.google.com&lt;/code&gt;，使用4G数据流量，连接正常，速度没有明显差异:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-vpn/6s_test_vpn.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当然，其他设备上也是类似配置，都是一些基础的操作，也该收工了。OK, Just Enjoy~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      主要介绍如何在12个月免费的AWS EC2中搭建基于PPTP协议的VPN服务用于翻越GFW，平时Google搜索一下也很方便，会涉及CentOS, RedHat和Ubuntu操作系统。
    
    </summary>
    
      <category term="DevOps" scheme="http://waterstrong.me/blog/categories/DevOps/"/>
    
    
      <category term="Linux" scheme="http://waterstrong.me/blog/tags/Linux/"/>
    
      <category term="AWS" scheme="http://waterstrong.me/blog/tags/AWS/"/>
    
      <category term="EC2" scheme="http://waterstrong.me/blog/tags/EC2/"/>
    
      <category term="VPN" scheme="http://waterstrong.me/blog/tags/VPN/"/>
    
      <category term="PPTP" scheme="http://waterstrong.me/blog/tags/PPTP/"/>
    
      <category term="CentOS" scheme="http://waterstrong.me/blog/tags/CentOS/"/>
    
      <category term="RedHat" scheme="http://waterstrong.me/blog/tags/RedHat/"/>
    
      <category term="Ubuntu" scheme="http://waterstrong.me/blog/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>AWS EC2入门篇</title>
    <link href="http://waterstrong.me/blog/aws-ec2-basic/"/>
    <id>http://waterstrong.me/blog/aws-ec2-basic/</id>
    <published>2016-04-11T04:00:08.000Z</published>
    <updated>2016-04-19T05:11:06.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;h4 id=&quot;什么是Amazon-EC2&quot;&gt;&lt;a href=&quot;#什么是Amazon-EC2&quot; class=&quot;headerlink&quot; title=&quot;什么是Amazon EC2&quot;&gt;&lt;/a&gt;什么是Amazon EC2&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Amazon Elastic Compute Cloud (Amazon EC2) provides scalable computing capacity in the Amazon Web Services (AWS) cloud.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Amazon EC2是一个IaaS云服务，主要提供弹性的计算资源，通俗地讲，就是提供多种类型的虚拟机。EC2也是整个AWS最核心的组成部分，AWS中有许多的服务需要依赖它。在EC2环境中，虚拟机被称为实例，实例的镜像被称为AMI(Amazon Machine Image)。使用AWS EC2有如下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可避免前期的硬件投入，因此能够快速开发和部署应用程序&lt;/li&gt;
&lt;li&gt;可根据自身需要快速启动任意数量的虚拟服务器、配置安全和网络以及管理存储&lt;/li&gt;
&lt;li&gt;允许根据需要进行缩放以应对需求变化或流行高峰，降低流量预测需求&lt;/li&gt;
&lt;li&gt;主要是根据类型和使用时间收费，即使用多少收多少的费用&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;相关概念和名词解释&quot;&gt;&lt;a href=&quot;#相关概念和名词解释&quot; class=&quot;headerlink&quot; title=&quot;相关概念和名词解释&quot;&gt;&lt;/a&gt;相关概念和名词解释&lt;/h4&gt;&lt;p&gt;Instance: 实例，在EC2环境中，虚拟计算环境被称为实例。&lt;br&gt;AMI: Amazon Machine Image，亚马逊系统映像，即实例的预配置模板，其中包含服务器需要的程序包（包括操作系统和其他软件）。&lt;/p&gt;
&lt;p&gt;IaaS: Infrastructure as a Service, 基础设施即服务。消费者通过Internet可以从完善的计算机基础设施获得服务，这类服务称为基础设施即服务(IaaS)，基于Internet的服务（如存储和数据库）是IaaS的一部分。&lt;/p&gt;
&lt;p&gt;IaaS通常分为三种用法：公有云、私有云和混合云。Amazon EC2在基础设施云中使用公共服务器池(公有云)，更加私有化的服务会使用企业内部数据中心的一组公用或私有服务器池(私有云)，如果在企业数据中心环境中开发软件，那么这两种类型公有云、私有云都能使用(混合云)。&lt;/p&gt;
&lt;p&gt;Internet上其他类型的服务包括平台即服务(Platform as a Service, PaaS)和软件即服务(Software as a Service, SaaS)。PaaS提供了用户可以访问的完整或部分的应用程序开发，SaaS则提供了完整的可直接使用的应用程序，比如通过 Internet管理企业资源。&lt;/p&gt;
&lt;h3 id=&quot;注册并创建EC2实例&quot;&gt;&lt;a href=&quot;#注册并创建EC2实例&quot; class=&quot;headerlink&quot; title=&quot;注册并创建EC2实例&quot;&gt;&lt;/a&gt;注册并创建EC2实例&lt;/h3&gt;&lt;p&gt;若没有帐号可进入&lt;a href=&quot;http://aws.amazon.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AWS主页&lt;/a&gt;选择&lt;code&gt;Create an AWS Account&lt;/code&gt;注册:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-basic/aws_homepage.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;大概需要填写用户名密码,联系人信息,信用卡信息等，信用卡会被扣掉1美元:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-basic/register_in_process.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后进入AWS控制台选择EC2:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-basic/aws_overview.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了选择最近的地区，可以在&lt;a href=&quot;http://www.cloudping.info/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CloudPing&lt;/a&gt;上测试一下Ping速度，选择最快的Singapore:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-basic/choose_location_area.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-basic/cloud_ping.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;点击&lt;code&gt;Launch Instance&lt;/code&gt;创建一个实例，可以选择&lt;code&gt;Community AMIs&lt;/code&gt;进行筛选，也可能直接选择Amazon的Linux AMI，据说是速度和性能都进行过优化:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-basic/launch_choose_ami.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;一定只选择标记为&lt;code&gt;Free tier eligible&lt;/code&gt;的免费类型，否则运行一段时间就等着哭吧:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-basic/launch_choose_instance_type.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;根据步骤和提示一步步完成即可，最后启动会选择Key Pair。当系统提示提供密钥时，选择Choose an existing key pair，然后选择已创建的密钥对。另外，也可以新建密钥对，选择Create a new key pair，输入密钥对的名称，然后选择Download Key Pair。这是保存私有密钥文件的唯一机会，因此务必单击进行下载，将私有密钥文件保存在安全位置。当启动实例时，需要提供密钥对的名称，当每次连接到实例时，需要提供相应的私有密钥。&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-basic/launch_select_key_pair.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最后就可以看到Instances页面出现了已创建成功的实例。如果需要SSH到实例，可以点击&lt;code&gt;Instances -&amp;gt; 选择Instance -&amp;gt; Connect&lt;/code&gt;查看，Shell Command如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh -i &amp;lt;key.pem&amp;gt; &amp;lt;username&amp;gt;@&amp;lt;instance-address&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;更多说明请参见&lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/get-set-up-for-amazon-ec2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Amazon EC2 的设置&lt;/a&gt;和&lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/managing-users.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在 Linux 实例上管理用户账户&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Instances-Management-实例管理&quot;&gt;&lt;a href=&quot;#Instances-Management-实例管理&quot; class=&quot;headerlink&quot; title=&quot;Instances Management 实例管理&quot;&gt;&lt;/a&gt;Instances Management 实例管理&lt;/h3&gt;&lt;p&gt;实例(Instance), 即虚拟计算环境。实例的预配置模板，也称为亚马逊系统映像(AMI)，其中包含服务器需要的程序包(包括操作系统和其他软件)。实例CPU、内存、存储和网络容量的多种配置，也称为实例类型。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Instances&lt;/code&gt;栏中可以对实例进行Reboot, Stop, Start, Terminate(永久删除)以及其他的网络,安全,卷等设置。&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-basic/instances.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Resource-amp-Tags-资源-amp-标签&quot;&gt;&lt;a href=&quot;#Resource-amp-Tags-资源-amp-标签&quot; class=&quot;headerlink&quot; title=&quot;Resource &amp;amp; Tags 资源 &amp;amp; 标签&quot;&gt;&lt;/a&gt;Resource &amp;amp; Tags 资源 &amp;amp; 标签&lt;/h3&gt;&lt;p&gt;Amazon EC2提供可创建和使用的不同资源，这些资源中的一部分资源包括映像、实例、卷和快照，在创建某个资源时，该资源会被分配一个唯一资源 ID。可以定义某个值标记某些资源，来帮助组织和识别这些资源，即Tags。&lt;/p&gt;
&lt;p&gt;标签(Tag)为了&lt;code&gt;方便管理实例、映像以及其他Amazon EC2资源&lt;/code&gt;，可通过标签的形式为每个资源分配元数据(Meta Data)。&lt;code&gt;标签可按各种标准(例如用途、所有者或环境)对AWS资源进行分类&lt;/code&gt;，每个标签都包含定义的一个键和一个可选值，例如下图所示：&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-basic/tag_example.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Volumes-卷&quot;&gt;&lt;a href=&quot;#Volumes-卷&quot; class=&quot;headerlink&quot; title=&quot;Volumes 卷&quot;&gt;&lt;/a&gt;Volumes 卷&lt;/h3&gt;&lt;p&gt;卷是一种数据块级存储设备，可以连接到单个EC2实例，可以像使用其他物理硬盘一样使用它。使用Amazon Elastic Block Store(Amazon EBS)的数据的持久性存储卷，也称为Amazon EBS卷，提供了三种卷类型：通用型SSD、Provisioned IOPS和磁介质，各卷类型特点可参见: &lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/EBSVolumeTypes.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Amazon EBS 卷类型&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;除了EBS，还有提供临时性块级存储&lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/InstanceStorage.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实例存储&lt;/a&gt;和存储Internet数据的Amazon Simple Storage Service (&lt;a href=&quot;http://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/AmazonS3.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Amazon S3&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;卷存储的架构如下图所示:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-basic/architecture_storage.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以选择&lt;code&gt;elastic block store -&amp;gt; Volumes -&amp;gt; Create Volume&lt;/code&gt;创建一个新卷:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-basic/create_volume.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;选择Volumes中的一个条目，通过&lt;code&gt;Actions或右键 -&amp;gt; Attach Volume&lt;/code&gt;连接到某个Instance上:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-basic/attach_volume.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Instance上通过以下命令实现Mount(挂载)创建的卷:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df -h  # 查看已挂载的卷&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;df -T  # 可以查看挂载卷的类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo fdisk -l  # 查看连接到的卷&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 当确定卷的名称为 /dev/xvdf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo mkfs.ext4 /dev/xvdf  # 格式化卷类型为ext4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir /mnt/ebs  # 创建文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo mount /dev/xvdf /mnt/ebs  # 挂载卷到ebs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;df -T  # 再次查看挂载情况&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 若需要卸载卷&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo umount /dev/xvdf&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Snapshots-快照&quot;&gt;&lt;a href=&quot;#Snapshots-快照&quot; class=&quot;headerlink&quot; title=&quot;Snapshots 快照&quot;&gt;&lt;/a&gt;Snapshots 快照&lt;/h3&gt;&lt;p&gt;每个快照代表一个卷在一个特定时间点的状态。快照属于增量备份，这意味着仅保存设备上在最新快照之后更改的数据块。相对容易理解，此处不再赘述。&lt;/p&gt;
&lt;h3 id=&quot;Security-Groups-安全组&quot;&gt;&lt;a href=&quot;#Security-Groups-安全组&quot; class=&quot;headerlink&quot; title=&quot;Security Groups 安全组&quot;&gt;&lt;/a&gt;Security Groups 安全组&lt;/h3&gt;&lt;p&gt;可以使用安全组来控制实例的访问权限，这些安全组类似于一个传入网络防火墙，可以指定允许访问实例的协议、端口和源IP范围。可以创建多个安全组，并给每个安全组指定不同的规则，然后可以给每个实例分配一个或多个安全组，通过这些规则规则确定允许哪些流量可访问实例。&lt;/p&gt;
&lt;p&gt;Security Group安全组架构如图所示:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-basic/architecture_security_group.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;创建新的安全组，选择&lt;code&gt;Network &amp;amp; Security -&amp;gt; Security Groups -&amp;gt; Create Security Group&lt;/code&gt;进行创建:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-basic/create_security_group.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图显示下拉列表中，可以根据需要选择如SSH,TCP,UDP等，也可以选择Customer Rule来自定义端口号等，还可指定来源IP范围。&lt;/p&gt;
&lt;p&gt;选择Security Groups中一个条目，通过&lt;code&gt;Actions或右键 -&amp;gt; Edit inbound rules或Edit outbound rules&lt;/code&gt;来添加流量流入和流出限制规则:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-basic/edit_inbound_rules.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以根据实际需要添加规则，如果对安全性没有需求，可以不设置防火墙限制(但不推荐)，可直接选择&lt;code&gt;type&lt;/code&gt;为&lt;code&gt;All traffic&lt;/code&gt;，选择&lt;code&gt;source&lt;/code&gt;为&lt;code&gt;Anywhere&lt;/code&gt;，这样就允许所有类型和源的流量流入。&lt;/p&gt;
&lt;h3 id=&quot;Key-Pairs-密钥对&quot;&gt;&lt;a href=&quot;#Key-Pairs-密钥对&quot; class=&quot;headerlink&quot; title=&quot;Key Pairs 密钥对&quot;&gt;&lt;/a&gt;Key Pairs 密钥对&lt;/h3&gt;&lt;p&gt;Amazon EC2使用公有密钥密码术加密和解密登录信息。公有密钥密码术使用公有密钥加密某个数据(如一个密码)，然后收件人可以使用私有密钥解密数据，公有和私有密钥被称为密钥对。AWS存储公有密钥，个人在安全位置存储私有密钥。如果经常使用SSH那就比较清楚了。&lt;/p&gt;
&lt;p&gt;选择&lt;code&gt;Network &amp;amp; Security -&amp;gt; Key Pairs -&amp;gt; Import Key Pair&lt;/code&gt;可以导入本机的公钥，当然也可以创建Key Pair:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-basic/create_key_pair.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Placement-Groups-置放群组&quot;&gt;&lt;a href=&quot;#Placement-Groups-置放群组&quot; class=&quot;headerlink&quot; title=&quot;Placement Groups 置放群组&quot;&gt;&lt;/a&gt;Placement Groups 置放群组&lt;/h3&gt;&lt;h3 id=&quot;Elastic-IPs-弹性IP&quot;&gt;&lt;a href=&quot;#Elastic-IPs-弹性IP&quot; class=&quot;headerlink&quot; title=&quot;Elastic IPs 弹性IP&quot;&gt;&lt;/a&gt;Elastic IPs 弹性IP&lt;/h3&gt;&lt;p&gt;弹性IP地址是专为动态云计算设计的静态IP地址。&lt;code&gt;实例在重启后会自动重新分配一个与原实例不同的公有IP地址&lt;/code&gt;，如果应用程序需要一个静态IP地址，可以使用弹性IP地址关联到实例，并且在实例发生故障的情况下能够将该地址映射到另一实例，并能够将 DNS主机名用于所有其他节点间通信，从而屏蔽实例故障。&lt;/p&gt;
&lt;p&gt;如下图所示选择&lt;code&gt;Network &amp;amp; Security -&amp;gt; Elastic IPs -&amp;gt; Allocate New Address&lt;/code&gt;分配一个新的EIP:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-basic/new_elastic_ip.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;选择Elastic IPs中一个条目，通过&lt;code&gt;Actions或右键 -&amp;gt; Associate Address&lt;/code&gt;输入需要关联的Instance:&lt;br&gt;&lt;img src=&quot;../images/aws-ec2-basic/associate_elastic_ip.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;此时可以通过EIP访问关联到的Instance了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;特别注意:&lt;/code&gt; 为确保弹性IP地址的有效使用，如果弹性IP地址未与正在运行的实例关联，或者它已与停止的实例或未连接的网络接口关联，Amazon将强制收取小额的小时费用，每小时是$0.005。当实例正在运行时，无需为与该实例关联的某个弹性IP地址付费。当重新映射弹性IP地址次数一个月内超过了100次将收取$0.10费用。在默认情况下，所有AWS账户最多可拥有5个EIP。&lt;/p&gt;
&lt;h3 id=&quot;Network-Interfaces-网络接口&quot;&gt;&lt;a href=&quot;#Network-Interfaces-网络接口&quot; class=&quot;headerlink&quot; title=&quot;Network Interfaces 网络接口&quot;&gt;&lt;/a&gt;Network Interfaces 网络接口&lt;/h3&gt;&lt;p&gt;您可以创建的虚拟网络，这些网络与其余 AWS 云在逻辑上隔离，并且您可以选择连接到您自己的网络，也称为Virtual Private Cloud(VPC)。&lt;/p&gt;
&lt;h3 id=&quot;Load-Banlancers-负载均衡&quot;&gt;&lt;a href=&quot;#Load-Banlancers-负载均衡&quot; class=&quot;headerlink&quot; title=&quot;Load Banlancers 负载均衡&quot;&gt;&lt;/a&gt;Load Banlancers 负载均衡&lt;/h3&gt;&lt;p&gt;可以跨越多个Amazon EC2实例自动分配应用程序的传入流量。&lt;/p&gt;
&lt;h3 id=&quot;Auto-Scaling&quot;&gt;&lt;a href=&quot;#Auto-Scaling&quot; class=&quot;headerlink&quot; title=&quot;Auto Scaling&quot;&gt;&lt;/a&gt;Auto Scaling&lt;/h3&gt;&lt;p&gt;根据定义的条件自动扩展Amazon EC2容量。&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;p&gt;[1] &lt;a href=&quot;http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/concepts.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Amazon EC2 User Guide for Linux Instances&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      Amazon EC2是一个IaaS云服务，主要提供弹性的计算资源，EC2是整个AWS最核心的组成部分，可以在很短的时间内创建、启动和运行不同的类型和大小的EC2实例。
    
    </summary>
    
      <category term="DevOps" scheme="http://waterstrong.me/blog/categories/DevOps/"/>
    
    
      <category term="AWS" scheme="http://waterstrong.me/blog/tags/AWS/"/>
    
      <category term="EC2" scheme="http://waterstrong.me/blog/tags/EC2/"/>
    
      <category term="IaaS" scheme="http://waterstrong.me/blog/tags/IaaS/"/>
    
      <category term="云服务" scheme="http://waterstrong.me/blog/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="SSH" scheme="http://waterstrong.me/blog/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://waterstrong.me/blog/hello-world/"/>
    <id>http://waterstrong.me/blog/hello-world/</id>
    <published>2016-03-19T16:00:00.000Z</published>
    <updated>2016-04-17T04:08:17.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;Hello-World-Let’s-Begin&quot;&gt;&lt;a href=&quot;#Hello-World-Let’s-Begin&quot; class=&quot;headerlink&quot; title=&quot;Hello World, Let’s Begin!&quot;&gt;&lt;/a&gt;Hello World, Let’s Begin!&lt;/h4&gt;&lt;p&gt;&lt;em&gt;This is a test!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://waterstrong.me&quot;&gt;http://waterstrong.me&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;../images/hello-world/nature.jpg&quot; alt=&quot;Hello Nature&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Hello-World-Let’s-Begin&quot;&gt;&lt;a href=&quot;#Hello-World-Let’s-Begin&quot; class=&quot;headerlink&quot; title=&quot;Hello World, Let’s Begin!&quot;&gt;&lt;/a&gt;Hello World, Let’s Begin!&lt;/h4&gt;&lt;p&gt;&lt;em&gt;This is a test!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://waterstrong.me&quot;&gt;http://waterstrong.me&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://waterstrong.me/blog/categories/Tech/"/>
    
    
      <category term="Tech" scheme="http://waterstrong.me/blog/tags/Tech/"/>
    
      <category term="Life" scheme="http://waterstrong.me/blog/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>事务处理机制与协议</title>
    <link href="http://waterstrong.me/blog/transactional-mechanism-protocol/"/>
    <id>http://waterstrong.me/blog/transactional-mechanism-protocol/</id>
    <published>2016-02-04T11:11:03.000Z</published>
    <updated>2016-04-19T13:50:51.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;事务定义及其特性&quot;&gt;&lt;a href=&quot;#事务定义及其特性&quot; class=&quot;headerlink&quot; title=&quot;事务定义及其特性&quot;&gt;&lt;/a&gt;事务定义及其特性&lt;/h2&gt;&lt;h3 id=&quot;什么是事务？&quot;&gt;&lt;a href=&quot;#什么是事务？&quot; class=&quot;headerlink&quot; title=&quot;什么是事务？&quot;&gt;&lt;/a&gt;什么是事务？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;A transaction is a unit of work that you want to treat as “a whole”. It has to either happen in full, or not at all.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直接地讲，就是事务是一个整体，其中的若干处理要么都做，要么都不做。接下来我们就详细地聊聊事务。&lt;/p&gt;
&lt;h3 id=&quot;事务的ACID特性&quot;&gt;&lt;a href=&quot;#事务的ACID特性&quot; class=&quot;headerlink&quot; title=&quot;事务的ACID特性&quot;&gt;&lt;/a&gt;事务的ACID特性&lt;/h3&gt;&lt;p&gt;事务的四大特性分别为原子性、一致性、隔离性和永久性，称为ACID特性，也称酸性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;原子性（Atomicity）&lt;/strong&gt;&lt;br&gt;一个事务中所有操作是一个不可分割的操作序列，要么全做，要么全不做。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性（Consistency）&lt;/strong&gt;&lt;br&gt;数据不会因为事务的执行而遭到破坏，一致性保证了这个事务所包含的一系列的操作完成后系统仍然在一个一致的状态，侧重点在于，事务执行前后在某种程度上是等价的，从一个一致状态到另一个一致状态。例如，对银行转帐事务，不管事务成功还是失败，应该保证事务结束后两人存款总额为定值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离性（Isolation）&lt;/strong&gt;&lt;br&gt;一个事务的执行，不受其他事务（进程）的干扰，既并发执行的个事务之间互不干扰，每个事务都有各自的完整数据空间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;永久性（Durability）&lt;/strong&gt;&lt;br&gt;一个事务一旦提交，它对数据库所作的改变将是永久的，使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;数据库事务管理&quot;&gt;&lt;a href=&quot;#数据库事务管理&quot; class=&quot;headerlink&quot; title=&quot;数据库事务管理&quot;&gt;&lt;/a&gt;数据库事务管理&lt;/h3&gt;&lt;p&gt;对于数据库来说，事务的ACID特性是由关系数据库管理系统（RDBMS，数据库系统）来实现的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DBMS采用&lt;strong&gt;日志&lt;/strong&gt;来保证事务的原子性、一致性和持久性。&lt;ul&gt;
&lt;li&gt;日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DBMS采用&lt;strong&gt;锁机制&lt;/strong&gt;来实现事务的隔离性。&lt;ul&gt;
&lt;li&gt;每个事务对所依赖的资源（如行、页或表）请求不同类型的锁，当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。锁可以阻止其他事务以某种可能会导致事务请求锁出错的方式修改资源，当事务不再依赖锁定的资源时，它将释放锁。通常会有共享(S)锁、排它(X)锁、更新(U)锁等，各锁的解释、并发效率、锁冲突及其防止办法不在本文范围，有兴趣可以自行了解。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除了锁定外，也可能采用&lt;strong&gt;行版本控制&lt;/strong&gt;来实现事务隔离性。&lt;ul&gt;
&lt;li&gt;当启用了基于行版本控制的隔离级别时，数据库引擎将维护修改的每一行的版本，应用程序可以指定事务使用行版本查看事务或查询开始时存在的数据，而不是使用锁保护所有读取。通过使用行版本控制，读取操作阻止其他事务的可能性将大大降低，锁数量减少，死锁可能性降低，有效减少了管理锁的开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;锁定和行版本控制可以防止用户读取未提交的数据，还可以防止多个用户尝试同时更改同一数据。如果不进行锁定或行版本控制，对数据执行的查询可能会返回数据库中尚未提交的数据，从而产生意外的结果。&lt;/p&gt;
&lt;p&gt;在了解数据库保证事务ACID特性的基本原理后，那么……对程序提供的数据库编程接口，如何实现事务的呢？接下来介绍本地事务。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;本地事务（Local-Transaction）&quot;&gt;&lt;a href=&quot;#本地事务（Local-Transaction）&quot; class=&quot;headerlink&quot; title=&quot;本地事务（Local Transaction）&quot;&gt;&lt;/a&gt;本地事务（Local Transaction）&lt;/h2&gt;&lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;本地事务(Local Transaction)主要指限制在单个进程内的事务，不涉及多个数据库源，通常会有Begin Transaction … End Transaction来控制事务的开始与结束。以对数据库访问为例，接下来用伪代码实现事务的提交/回滚。&lt;/p&gt;
&lt;h3 id=&quot;本地事务-模型1&quot;&gt;&lt;a href=&quot;#本地事务-模型1&quot; class=&quot;headerlink&quot; title=&quot;本地事务 模型1&quot;&gt;&lt;/a&gt;本地事务 模型1&lt;/h3&gt;&lt;p&gt;设置自动提交的情况：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;conn = getConnection(“url&amp;quot;,&amp;quot;user&amp;quot;,&amp;quot;pwd&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conn.setAutoCommit(true);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;try&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn.execute(...);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;catch(Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;finally &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;本地事务-模型2&quot;&gt;&lt;a href=&quot;#本地事务-模型2&quot; class=&quot;headerlink&quot; title=&quot;本地事务 模型2&quot;&gt;&lt;/a&gt;本地事务 模型2&lt;/h3&gt;&lt;p&gt;设置非自动提交情况：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;conn = getConnection(“url&amp;quot;,&amp;quot;user&amp;quot;,&amp;quot;pwd&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conn.setAutoCommit(false);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;try&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn.execute(…);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn.commit();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;catch(Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn.rollback();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;finally &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    conn.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这也是最早的访问方式，相信你也发现一些问题了，如果设置为自动提交，当某个操作需要多个执行序列完成时，那么每次execute时都会commit，在很程度上降低了执行效率。若设置为非自动提交，虽然解决了多次execute的问题，但直接暴露conn并不是理想的做法，同时还需要手动close连接。因此，有没有更好地方式呢？答案是肯定的，接下来就看看编程式事务的实现方式。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;编程式事务（Programmatic-Transaction）&quot;&gt;&lt;a href=&quot;#编程式事务（Programmatic-Transaction）&quot; class=&quot;headerlink&quot; title=&quot;编程式事务（Programmatic Transaction）&quot;&gt;&lt;/a&gt;编程式事务（Programmatic Transaction）&lt;/h2&gt;&lt;h3 id=&quot;基本介绍-1&quot;&gt;&lt;a href=&quot;#基本介绍-1&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;编程式事务(Programmatic Transaction)通过编程语言提供的事务API和事务服务提供者进行事务控制。通常的做法是在代码中直接加入处理事务的逻辑，显式地调用其commit()、rollback()等事务管理相关方法。&lt;/p&gt;
&lt;h3 id=&quot;编程式事务-模型&quot;&gt;&lt;a href=&quot;#编程式事务-模型&quot; class=&quot;headerlink&quot; title=&quot;编程式事务 模型&quot;&gt;&lt;/a&gt;编程式事务 模型&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;userTransaction.begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    doSomething();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    doAnotherThing();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    userTransaction.commit();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; catch (Exception ex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    userTransaction.rollback();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;与Local事务的区别&quot;&gt;&lt;a href=&quot;#与Local事务的区别&quot; class=&quot;headerlink&quot; title=&quot;与Local事务的区别&quot;&gt;&lt;/a&gt;与Local事务的区别&lt;/h3&gt;&lt;p&gt;Programmatic与Local Transaction的区别在于Programmatic把Local方式下的conn封装起来，并且手动控制commit和rollback，在一定程序上简化了编程的繁琐性，更加关注事务开始、提交与回滚。你觉得这种方式就已经很棒了么，再想想还有没有更好更创新的方法呢，声明式事务会给你想要的答案。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;声明式事务（Declarative-Transaction）&quot;&gt;&lt;a href=&quot;#声明式事务（Declarative-Transaction）&quot; class=&quot;headerlink&quot; title=&quot;声明式事务（Declarative Transaction）&quot;&gt;&lt;/a&gt;声明式事务（Declarative Transaction）&lt;/h2&gt;&lt;h3 id=&quot;基本介绍-2&quot;&gt;&lt;a href=&quot;#基本介绍-2&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;声明式事务(Declarative Transaction)对目标方法上添加注解(Annotation)或在配置文件中定义，通过对方法前后拦截添加事务处理逻辑。虽然XML配置的方式在前几年很受欢迎，也是具有里程碑的意义，但小编我更青睐注解的方式，况且目前主流的IoC框架也都支持注解方式并且推荐使用。接下来将给出Java形式的伪代码进行解释。&lt;/p&gt;
&lt;h3 id=&quot;声明式事务-模型&quot;&gt;&lt;a href=&quot;#声明式事务-模型&quot; class=&quot;headerlink&quot; title=&quot;声明式事务 模型&quot;&gt;&lt;/a&gt;声明式事务 模型&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@Transaction&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void doSomething() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    process1();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    process2();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    repository.save();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中的@Transaction就是一个注解(Annotation)，其内部实现原理通常采用的是&lt;a href=&quot;/blog/aspect-oriented-programming&quot;&gt;AOP(面向切面编程)&lt;/a&gt;的方式进行方法的拦截。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Object intercept(proxy, method, args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    trans.begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	method.invoke(target, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	trans.commit();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; catch (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	trans.rollback();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以上所有的事务实现方式都主要集中在单一数据库情况，那么对于多数据库协调或者混合数据源情形，如数据库加消息队列等，又如何保证事务正确有效地执行呢？答案是分布式事务，也称全局事务来管理了。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;全局-分布式事务（Global-Distributed-Transaction）&quot;&gt;&lt;a href=&quot;#全局-分布式事务（Global-Distributed-Transaction）&quot; class=&quot;headerlink&quot; title=&quot;全局/分布式事务（Global/Distributed Transaction）&quot;&gt;&lt;/a&gt;全局/分布式事务（Global/Distributed Transaction）&lt;/h2&gt;&lt;h3 id=&quot;基本介绍-3&quot;&gt;&lt;a href=&quot;#基本介绍-3&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;全局/分布式事务(Global/Distributed Transaction)也称XA事务，主要处理跨越多个数据库或进程，多资源协调的情形（例如：访问多个数据库，或数据库加消息队列，又或是多个消息队列等）。其中核心概念包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务管理器（Transaction Manager）&lt;/li&gt;
&lt;li&gt;资源管理器（Resource Manager）&lt;/li&gt;
&lt;li&gt;XA协议标准（eXtended Architecture Standard）&lt;/li&gt;
&lt;li&gt;两阶段提交（Two-Phase Commit）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先来看一个关于JMS Message触发数据库更新操作的实例。&lt;/p&gt;
&lt;h3 id=&quot;JMS触发DB更新的实例&quot;&gt;&lt;a href=&quot;#JMS触发DB更新的实例&quot; class=&quot;headerlink&quot; title=&quot;JMS触发DB更新的实例&quot;&gt;&lt;/a&gt;JMS触发DB更新的实例&lt;/h3&gt;&lt;h4 id=&quot;DB-JMS-伪代码&quot;&gt;&lt;a href=&quot;#DB-JMS-伪代码&quot; class=&quot;headerlink&quot; title=&quot;DB+JMS 伪代码&quot;&gt;&lt;/a&gt;DB+JMS 伪代码&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@JMSListener(...)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void onMessage(...) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    service.merge(...);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Transaction&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void merge(…) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    repository.update(…);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ……&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;成功调用过程&quot;&gt;&lt;a href=&quot;#成功调用过程&quot; class=&quot;headerlink&quot; title=&quot;成功调用过程&quot;&gt;&lt;/a&gt;成功调用过程&lt;/h4&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Start messaging transaction&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Receive message&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Start database transaction&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Update database&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Commit database transaction&lt;/li&gt;
&lt;li&gt;Commit messaging transaction&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;成功调用Happy Pass当然没有什么问题，正常提交到数据库，也完成消息提交，但在实际情况中往往不是所期望的。&lt;/p&gt;
&lt;h4 id=&quot;可能失败的情形&quot;&gt;&lt;a href=&quot;#可能失败的情形&quot; class=&quot;headerlink&quot; title=&quot;可能失败的情形&quot;&gt;&lt;/a&gt;可能失败的情形&lt;/h4&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Start messaging transaction&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Receive message&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Start database transaction&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Update database, fail!&lt;/strong&gt; &amp;lt;–&lt;/li&gt;
&lt;li&gt;Roll back database transaction&lt;/li&gt;
&lt;li&gt;Roll back messaging transaction&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到第4步更新数据库时由于某种外键或唯一键约束导致数据库更新失败，这时需要回滚数据库操作以及消息提交，而如何保证Database和JMS之间能够正确工作是首要问题。同理，针对多个数据库或多个消息队列(Queue)/主题(Topic)，Transaction是如何协调多资源的呢？&lt;/p&gt;
&lt;h3 id=&quot;XA事务多资源协调&quot;&gt;&lt;a href=&quot;#XA事务多资源协调&quot; class=&quot;headerlink&quot; title=&quot;XA事务多资源协调&quot;&gt;&lt;/a&gt;XA事务多资源协调&lt;/h3&gt;&lt;h4 id=&quot;X-Open-XA规范接口&quot;&gt;&lt;a href=&quot;#X-Open-XA规范接口&quot; class=&quot;headerlink&quot; title=&quot;X/Open XA规范接口&quot;&gt;&lt;/a&gt;X/Open XA规范接口&lt;/h4&gt;&lt;p&gt;XA协议采用两阶段提交方式来管理分布式事务，XA接口提供资源管理器(RM)与事务管理器(TM)之间进行通信的标准接口。下图来自网络，大致描述了RM和TM的关系以及XA工作范畴，资源管理器管理着多个资源，事务管理器与资源管理器通过XA进行双向通信。&lt;br&gt;&lt;img src=&quot;../images/transactional-mp/XA_standard_interface.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;XA事务实现原理主要是针对每一个XA资源给全局事务和本地事务分配一个xid，每一个XA资源都被加入的XA的管理器中，通过某个方法来决定XA资源已经被加入到事务中并且已经准备就绪，最后统一提交，也就是所谓的两阶段提交。&lt;/p&gt;
&lt;h4 id=&quot;XA两阶段提交协议&quot;&gt;&lt;a href=&quot;#XA两阶段提交协议&quot; class=&quot;headerlink&quot; title=&quot;XA两阶段提交协议&quot;&gt;&lt;/a&gt;XA两阶段提交协议&lt;/h4&gt;&lt;p&gt;两阶段提交协议（The two-phase commit protocol，2PC）是XA用于在全局事务中协调多个资源的机制。两阶段提交协议包含了两个阶段：准备阶段(Prepare)和提交阶段(Commit)。准备阶段需要检查资源的状态(READY, READ_ONLY, NOT_READY)，当且仅当所有资源都是READY状态，准备阶段完成，否则进行Rollback操作。下图来自网络，大致描述了2PC的工作流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/transactional-mp/XA_two_phase_commit.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;TM可以向RM查询事务的状态，RM必须要返回一系列事务的XID，表明事务是prepared状态，还是已经commit的状态。TM会把XID,已完成的RM等这样的事务信息保存起来的，只有当全部的RM提交或者回滚完后，才能丢弃这些事务的信息。&lt;strong&gt;XA事务都假定了TM和RM都是有牢靠的存储，所以也保证了TM重启后可以从日志里恢复还未处理完的事务。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TM/RM初始化和XA两阶段提交伪代码如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// TM/RM Init 伪代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TransactionManager() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xaResourceManager = new XAResourceManager(gtrid);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bool enlistResource(xaResource) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xaResourceHolder = findXAResourceHolder(xaResource);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xaResourceHolderState = new XAResourceHolderState(xaResourceHolder);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xaResourceHolderState.setTransactionTimeoutDate(timeout);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xaResourceManager.enlist(xaResourceHolderState);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;////////////////////////////////&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// XA 2PC 伪代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;XAResourceHolderState&amp;gt; interestedResources;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;try &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    interestedResources = preparer.prepare(this); //Get resources and check their states&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; catch(RollbackException ex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rollbackPrepareFailure(ex); // If one of the resources is not ready&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;committer.commit(this, interestedResources); // All resources are ready and commit all at once&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;…… // Other code goes here&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;////////////////////////////////&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 备注:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// preparer.prepare(this) is to get the resources and check their states&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// should call resource manager: transaction.getResourceManager().getAllResources();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;XA事务问题与优化策略&quot;&gt;&lt;a href=&quot;#XA事务问题与优化策略&quot; class=&quot;headerlink&quot; title=&quot;XA事务问题与优化策略&quot;&gt;&lt;/a&gt;XA事务问题与优化策略&lt;/h2&gt;&lt;p&gt;对于非XA事务，范围仅限于单个可识别数据资源的事务操作。对于XA事务，可能出现timeout问题，连锁反应导致系统变慢，同时XA事务也会消耗更多性能资源。因此，仅在同一个事务上下文中需要协调多种资源时，才有必要使用XA，也就是说仅当多个资源必须在同一个事务范畴内被协调时，才有必要用XA。&lt;/p&gt;
&lt;p&gt;针对XA事务可能出现的问题，目前常用的优化策略:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;最后资源提交优化（Last Resource Commit Optimization）&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;最后资源提交优化允许有且仅有一个资源是非XA资源，不必进入到准备阶段而可以直接提交或回滚，如果有这样的一个资源存在XA事务中，那首先应该尝试准备其他XA的资源，然后提交该非XA资源，如果成功，提交其他XA资源，否则回滚所有资源。通常的场景是当如JDBC这样的Driver不支持XA时，可以将其配置成最后参与者(资源)，然后就可以和XA资源进行协作了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一阶段提交优化（One-Phase Commit Optimization）&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;如果使用了XA事务，但资源只有一个，为了节省不必要的开销，XA不会执行两阶段提交，准确地说是没有准备阶段，而是当作单个资源处理并直接提交。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;经验异常（Heuristic Exception）处理&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;在两阶段提交的过程，资源管理器可能会使用“经验化决策”的策略，提交或者回滚，而不受事务管理器的控制。“经验化决策”是指根据多种内部和外部因素做出智能决定的过程，当资源管理器这么做了，它会向客户端报上一个经验异常（Heuristic Exception）。在XA环境下，两阶段提交的过程中，特别是事务参与者在第一阶段产生了响应之后，经验异常最常见的原因是第一阶段和第二阶段之间的超时情况，当网络延迟或故障、资源锁定以及资源使用过量时，资源管理器或许要做出提交或回滚其工作的决定，以释放资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;学海无涯-Keep-Learning&quot;&gt;&lt;a href=&quot;#学海无涯-Keep-Learning&quot; class=&quot;headerlink&quot; title=&quot;学海无涯 Keep Learning&quot;&gt;&lt;/a&gt;学海无涯 Keep Learning&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1. 可以研究下Java中Spring JTA Transaction Manager, 如Bitronix, Atomikos, etc.
2. 可以研究下各数据库如何开启和关闭支持XA事务，如何设置同时处于&amp;quot;准备好&amp;quot;状态的事务的最大数目（max_prepared_transactions）.
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      事务(Transaction)作为一个整体，其中的若干处理要么都做，要么都不做。主要涉及事务的定义及特性、本地事务、编程式事务、声明式事务、分布式事务、XA事务问题与优化策略等。
    
    </summary>
    
      <category term="Transaction" scheme="http://waterstrong.me/blog/categories/Transaction/"/>
    
    
      <category term="数据库" scheme="http://waterstrong.me/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="事务" scheme="http://waterstrong.me/blog/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="ACID特性" scheme="http://waterstrong.me/blog/tags/ACID%E7%89%B9%E6%80%A7/"/>
    
      <category term="XA协议" scheme="http://waterstrong.me/blog/tags/XA%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="分布式事务" scheme="http://waterstrong.me/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="锁机制" scheme="http://waterstrong.me/blog/tags/%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    
      <category term="行版本控制" scheme="http://waterstrong.me/blog/tags/%E8%A1%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>AOP面向切面编程</title>
    <link href="http://waterstrong.me/blog/aspect-oriented-programming/"/>
    <id>http://waterstrong.me/blog/aspect-oriented-programming/</id>
    <published>2016-01-20T05:45:32.000Z</published>
    <updated>2016-04-19T13:50:05.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;What-is-AOP&quot;&gt;&lt;a href=&quot;#What-is-AOP&quot; class=&quot;headerlink&quot; title=&quot;What is AOP ?&quot;&gt;&lt;/a&gt;What is AOP ?&lt;/h2&gt;&lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;p&gt;AOP(Aspect Oriented Programming)，即面向切面编程，是一种设计思想，通过预编译方式或运行时动态代理实现为程序统一添加功能的技术。&lt;/p&gt;
&lt;p&gt;AOP可以理解为OOP(面向对象编程)里程碑式的补充。OOP是从静态角度考虑程序结构，从横向上区分出类，AOP是从动态角度考虑程序运行过程，从纵向上向对象中加入特定的代码，加上时间维度，AOP使得OOP从二维变成三维，由平面变成立体。常常通过AOP来处理一些具有横切性质的系统性服务，如&lt;a href=&quot;/blog/transactional-mechanism-protocol&quot;&gt;事务处理&lt;/a&gt;、安全检查、缓存、对象池管理等。&lt;/p&gt;
&lt;p&gt;通常做法，是在运行时动态地将代码切入到类的指定方法、指定位置上，而切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点，采用AOP可以把几个类共有的代码抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。接下来将详解AOP中的几个核心概念。&lt;/p&gt;
&lt;h3 id=&quot;AOP相关概念&quot;&gt;&lt;a href=&quot;#AOP相关概念&quot; class=&quot;headerlink&quot; title=&quot;AOP相关概念&quot;&gt;&lt;/a&gt;AOP相关概念&lt;/h3&gt;&lt;h4 id=&quot;Aspect（切面-方面）&quot;&gt;&lt;a href=&quot;#Aspect（切面-方面）&quot; class=&quot;headerlink&quot; title=&quot;Aspect（切面/方面）&quot;&gt;&lt;/a&gt;Aspect（切面/方面）&lt;/h4&gt;&lt;p&gt;需要切入到指定类指定方法的代码片段称为切面，包含定义的额外功能的某个模块，相当于OOP中定义的类，但代表的更多是对象间横向的关系，如日志切面、权限切面、事务切面等。&lt;/p&gt;
&lt;h4 id=&quot;Joinpoint（连接点）&quot;&gt;&lt;a href=&quot;#Joinpoint（连接点）&quot; class=&quot;headerlink&quot; title=&quot;Joinpoint（连接点）&quot;&gt;&lt;/a&gt;Joinpoint（连接点）&lt;/h4&gt;&lt;p&gt;程序执行过程中精确执行点，如类中的方法调用、异常抛出等。&lt;/p&gt;
&lt;h4 id=&quot;Advice（通知-增强）&quot;&gt;&lt;a href=&quot;#Advice（通知-增强）&quot; class=&quot;headerlink&quot; title=&quot;Advice（通知/增强）&quot;&gt;&lt;/a&gt;Advice（通知/增强）&lt;/h4&gt;&lt;p&gt;在切面的某个特定的连接点(Joinpoint)上执行的动作，是执行切面的具体逻辑，包括Before，AfterReturning，AfterThrowing，After，Around等Advice。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Before Advice: 前置通知，在方法执行前执行&lt;/li&gt;
&lt;li&gt;AfterReturning: 后置返回通知，在方法执行正常返回后执行，方法没有抛出任何异常&lt;/li&gt;
&lt;li&gt;AfterThrowing Advice: 后置异常通知，在方法执行过程中抛出异常的时候执行&lt;/li&gt;
&lt;li&gt;After Advice: 后置通知/后置最终通知，在方法执行完成后执行，不论是正常返回还是异常退出&lt;/li&gt;
&lt;li&gt;Around Advice: 环绕通知，在方法执行前后和抛出异常时执行，环绕通知可以在方法调用前后完成自定义的行为&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Pointcut（切入点）&quot;&gt;&lt;a href=&quot;#Pointcut（切入点）&quot; class=&quot;headerlink&quot; title=&quot;Pointcut（切入点）&quot;&gt;&lt;/a&gt;Pointcut（切入点）&lt;/h4&gt;&lt;p&gt;匹配连接点(Joinpoint)的断言，通知(Advice)和切入点(Pointcut)表达式关联，并在满足该切入点(Pointcut)的连接点(Joinpoint)上运行，可以认为是连接点的集合，本质是一个捕获连接点的结构，通常可用正则表达式来找到那些匹配的连接点。&lt;/p&gt;
&lt;h4 id=&quot;Target（目标对象）&quot;&gt;&lt;a href=&quot;#Target（目标对象）&quot; class=&quot;headerlink&quot; title=&quot;Target（目标对象）&quot;&gt;&lt;/a&gt;Target（目标对象）&lt;/h4&gt;&lt;p&gt;包含连接点的对象，即被通知或被代理的实际对象。&lt;/p&gt;
&lt;h4 id=&quot;Proxy（代理对象）&quot;&gt;&lt;a href=&quot;#Proxy（代理对象）&quot; class=&quot;headerlink&quot; title=&quot;Proxy（代理对象）&quot;&gt;&lt;/a&gt;Proxy（代理对象）&lt;/h4&gt;&lt;p&gt;通过代理模式创建的对象，从而实现在目标对象连接点处插入切面，代理对象对使用者透明，是程序运行中间产物。&lt;/p&gt;
&lt;h4 id=&quot;Weaving（织入）&quot;&gt;&lt;a href=&quot;#Weaving（织入）&quot; class=&quot;headerlink&quot; title=&quot;Weaving（织入）&quot;&gt;&lt;/a&gt;Weaving（织入）&lt;/h4&gt;&lt;p&gt;织入是一个过程，将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期(Complie)、类装载期(Classload)、运行期(Runtime)进行。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;How-does-it-wok&quot;&gt;&lt;a href=&quot;#How-does-it-wok&quot; class=&quot;headerlink&quot; title=&quot;How does it wok ?&quot;&gt;&lt;/a&gt;How does it wok ?&lt;/h2&gt;&lt;p&gt;AOP技术可以通过反射机制与动态代理机制实现，业务逻辑组件在运行过程中，动态创建一个代理对象供使用者调用，该代理对象已经将切面成功切入到目标方法的连接点上，从而使切面的功能与业务逻辑的功能同时得以执行。当然也可以通过静态织入的方式，引入特定的语法，在编译期间织入有关切面代码。&lt;/p&gt;
&lt;p&gt;反射机制被视为动态（或准动态）语言的一个关键性质，它允许取得任何一个已知名称的class的内部信息，并能直接操作程序的内部属性。&lt;br&gt;动态代理机制指在程序运行时运用反射机制动态创建代理类，后续会有举例讲解到。&lt;/p&gt;
&lt;p&gt;从网络图库中收割到一幅关于AOP理解的图例，表达得非常到位，可以参见一下:&lt;br&gt;&lt;img src=&quot;../images/aop/aop_diagram.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;图中的切入箭头代表切入的动作，而切入的动作是依赖于称为切入点(Pointcut)的表达式规则匹配找到应该切入到哪些连接点(Joinpoint)上。从图解中可以大致了解到AOP的工作原理和过程，同时加强了对切面、连接点和切入点区别和关系的进一步理解。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Why-AOP&quot;&gt;&lt;a href=&quot;#Why-AOP&quot; class=&quot;headerlink&quot; title=&quot;Why AOP ?&quot;&gt;&lt;/a&gt;Why AOP ?&lt;/h2&gt;&lt;p&gt;OOP引入封装、继承和多态来建立对象层次结构，从而模拟公共行为的一个集合，当需要为分散的对象引入公共行为的时候，OOP则显得无能为力，如日志、权限、事务等功能。这种与主要业务处理流程（核心关注点）关系不大的代码被称为横切（cross cutting），在OO设计中会导致大量重复代码，也不利于模块重用和维护。&lt;/p&gt;
&lt;p&gt;因此需要AOP作为OOP的补充和完善来解决上述问题，AOP的优势主要表现在以下方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解决核心业务逻辑共有代码冗余问题，使代码变更简洁优雅&lt;/li&gt;
&lt;li&gt;只需关心核心的业务逻辑处理，能够提高编写工作效率&lt;/li&gt;
&lt;li&gt;核心关注点和横切关注点分离开来，共有代码集中存放，使得维护工作更加简单轻松&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;When-AOP&quot;&gt;&lt;a href=&quot;#When-AOP&quot; class=&quot;headerlink&quot; title=&quot;When AOP?&quot;&gt;&lt;/a&gt;When AOP?&lt;/h2&gt;&lt;p&gt;其实之前多次提到，当需要为分散的对象引入公共行为的时候，需要处理一些具有横切性质的系统性服务的时候，就可以使用AOP，以下列举了常见的几种应用范围和场合:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Authentication 权限检查&lt;/li&gt;
&lt;li&gt;logging / tracing 日志/跟踪&lt;/li&gt;
&lt;li&gt;Transactions 事务处理&lt;/li&gt;
&lt;li&gt;Exception Handling 异常处理&lt;/li&gt;
&lt;li&gt;profiling / monitoring　分析/监控&lt;/li&gt;
&lt;li&gt;Caching 缓存&lt;/li&gt;
&lt;li&gt;Debugging 调试&lt;/li&gt;
&lt;li&gt;Performance Optimization 性能优化&lt;/li&gt;
&lt;li&gt;Persistence 持久化&lt;/li&gt;
&lt;li&gt;Resource Pooling 资源池&lt;/li&gt;
&lt;li&gt;Synchronization 同步&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;AOP-in-Practice&quot;&gt;&lt;a href=&quot;#AOP-in-Practice&quot; class=&quot;headerlink&quot; title=&quot;AOP in Practice&quot;&gt;&lt;/a&gt;AOP in Practice&lt;/h2&gt;&lt;p&gt;主要针对AOP在Java中的实现，并解读在Spring中AOP的伪代码实现。&lt;/p&gt;
&lt;h3 id=&quot;代理设计模式&quot;&gt;&lt;a href=&quot;#代理设计模式&quot; class=&quot;headerlink&quot; title=&quot;代理设计模式&quot;&gt;&lt;/a&gt;代理设计模式&lt;/h3&gt;&lt;p&gt;首先来回顾一下设计模式中的代理模式:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代理模式(Proxy Design Pattern)，为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是如下图所示的关系，代理对象通过调用实际对象的方法来控制对该实际对象的访问。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/aop/proxy_dp.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;以下简单给出以Hello类为例的伪代码，通过代理对象调用实际对象的sayHello方法，并且在该方法的实际调用前后增加打印记录行为，模拟了拦截方法的过程。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public interface IHello &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void sayHello(String name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 实际的类，已有的操作和行为&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Hello implements IHello &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void sayHello(String name) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         println(“Hello &amp;quot;+name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 代理类，通过调用代理方法访问实际方法并且添加新的职责&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class HelloProxy implements IHello &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private IHello hello = new Hello(); // 指向目标对象,通常在用构造方法传值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void sayHello(String name) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println(&amp;quot;before....&amp;quot;); // 实际调用前添加新的行为&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        hello.sayHello(name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        println(&amp;quot;after....&amp;quot;); // 实际调用后添加新的行为&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在回顾了代理模式后，那么进一步了解如何结合代理模式在运行时通过反射机制动态创建代理类，即动态代理技术。&lt;/p&gt;
&lt;h3 id=&quot;JDK动态代理&quot;&gt;&lt;a href=&quot;#JDK动态代理&quot; class=&quot;headerlink&quot; title=&quot;JDK动态代理&quot;&gt;&lt;/a&gt;JDK动态代理&lt;/h3&gt;&lt;p&gt;主要针对JDK动态代理方式，使用接口实现，给出核心部分伪代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class DynamicProxyHello implements InvocationHandler &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Object target; // 目标对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public Object bind(Object target)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.target = target;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 通过目标类和接口来生成代理类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return Proxy.newProxyInstance(target.getClass().getClassLoader(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                      target.getClass().getInterfaces(), this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override // 代理类中拦截了目标对象的方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public Object invoke(Object proxy, Method method, Object[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        do(&amp;quot;before..... &amp;quot;); // 代理类中Advice&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Object result = method.invoke(target, args); // 目标对象的实际方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        do(&amp;quot;after.....&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;特别注意: JDK动态代理只能基于接口动态代理。一般默认情况下，如果目标类是接口，则使用JDK动态代理技术，否则只能使用CGLib来生成代理。&lt;/p&gt;
&lt;h3 id=&quot;CGLib代理&quot;&gt;&lt;a href=&quot;#CGLib代理&quot; class=&quot;headerlink&quot; title=&quot;CGLib代理&quot;&gt;&lt;/a&gt;CGLib代理&lt;/h3&gt;&lt;p&gt;CGLIB方式，使用继承实现：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 主要了解以下几个类, 代码在相应的库中都可以找到, 此处不再赘述&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MethodInterceptor // 方法拦截类, 定义的代理类需要实现该接口以调用intercept方法添加Advice&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Enhancer // 增强类, 继承至AbstractClassGenerator, 主要用于生成目标类的子类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MethodProxy // 生成的子类, 可以在intercept中通过调用proxy.invokeSuper()来调用目标对象的实际方法&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;特别注意: CGLib代理基于接口和非final类代理，不能代理static方法。&lt;/p&gt;
&lt;p&gt;之前有用Java实现过简单的IoC和AOP，有兴趣可以参见工程: &lt;a href=&quot;https://github.com/Waterstrong/summarine&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;summarine&lt;/a&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      AOP(Aspect Oriented Programming)，即面向切面编程，是一种设计思想，通过预编译方式或运行时动态代理实现为程序统一添加功能的技术。
    
    </summary>
    
      <category term="AOP" scheme="http://waterstrong.me/blog/categories/AOP/"/>
    
    
      <category term="Java" scheme="http://waterstrong.me/blog/tags/Java/"/>
    
      <category term="面向切面编程" scheme="http://waterstrong.me/blog/tags/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    
      <category term="反射机制" scheme="http://waterstrong.me/blog/tags/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    
      <category term="代理模式" scheme="http://waterstrong.me/blog/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Proxy" scheme="http://waterstrong.me/blog/tags/Proxy/"/>
    
      <category term="CGLib" scheme="http://waterstrong.me/blog/tags/CGLib/"/>
    
  </entry>
  
  <entry>
    <title>MySQL在Linux下默认区分大小写</title>
    <link href="http://waterstrong.me/blog/mysql-case-sensitive-linux/"/>
    <id>http://waterstrong.me/blog/mysql-case-sensitive-linux/</id>
    <published>2015-12-20T14:28:42.000Z</published>
    <updated>2016-03-29T15:47:25.000Z</updated>
    
    <content type="html">&lt;p&gt;前段时间遇到一个Hibernate/JPA自动映射MySQL Schema时报错问题，然后查了一下官方文档，原来是MySQL在Linux下默认区分大小写导致的，大致了解了一下，主要涉及两个变量lower_case_file_system和lower_case_table_names。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;默认大小写敏感&quot;&gt;&lt;a href=&quot;#默认大小写敏感&quot; class=&quot;headerlink&quot; title=&quot;默认大小写敏感&quot;&gt;&lt;/a&gt;默认大小写敏感&lt;/h4&gt;&lt;p&gt;MySQL数据库名、表名、别名在Linux下默认区分大小写，root登录通过命令查看其配置：&lt;br&gt;mysql&amp;gt; show variables like ‘lower%’;&lt;br&gt;+————————+——-+&lt;br&gt;| Variable_name          | Value |&lt;br&gt;+————————+——-+&lt;br&gt;| lower_case_file_system | OFF   |&lt;br&gt;| lower_case_table_names | 0     |&lt;br&gt;+————————+——-+&lt;/p&gt;
&lt;h4 id=&quot;变量名和值解释&quot;&gt;&lt;a href=&quot;#变量名和值解释&quot; class=&quot;headerlink&quot; title=&quot;变量名和值解释&quot;&gt;&lt;/a&gt;变量名和值解释&lt;/h4&gt;&lt;p&gt;lower_case_file_system为只读属性，显示出系统的文件系统是否大小写敏感，OFF表示大小写敏感，ON表示大小写不敏感。&lt;br&gt;lower_case_table_names默认为0，表示大小写敏感；设置1表示大小写不敏感，创建的表/数据库以小写形式存放在磁盘上，对于sql语句转换为小写操作；设置2表示创建的表/数据库依据语句上格式存放，但查找都是转换为小写进行。&lt;/p&gt;
&lt;p&gt;lower_case_file_system解释可参见&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_lower_case_file_system&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This variable describes the case sensitivity of file names on the file system where the data directory is located. OFF means file names are case sensitive,ON means they are not case sensitive. This variable is read only because it reflects a file system attribute and setting it would have no effect on the file system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;lower_case_table_names解释可参见&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_lower_case_table_names&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;的说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_lower_case_table_names&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;lower_case_table_names&lt;/a&gt;, If set to 0, table names are stored as specified and comparisons are case sensitive. If set to 1, table names are stored in lowercase on disk and comparisons are not case sensitive. If set to 2, table names are stored as given but compared in lowercase. This option also applies to database names and table aliases. For additional information, see &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.6/en/identifier-case-sensitivity.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Section 9.2.2&lt;/a&gt;, “Identifier Case Sensitivity”.&lt;/p&gt;
&lt;p&gt;On Windows the default value is 1. On OS X, the default value is 2.&lt;/p&gt;
&lt;p&gt;You should &lt;em&gt;not&lt;/em&gt; set &lt;strong&gt;lower_case_table_names&lt;/strong&gt; to 0 if you are running MySQL on a system where the data directory resides on a case-insensitive file system (such as on Windows or OS X). It is an unsupported combination that could result in a hang condition when running an INSERT INTO … SELECT … FROM &lt;strong&gt;tbl_name&lt;/strong&gt; operation with the wrong &lt;strong&gt;tbl_name&lt;/strong&gt; letter case. With MyISAM, accessing table names using different letter cases could cause index corruption.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h4&gt;&lt;p&gt;关于Hibernate/JPA数据库schema自动映射时，对于Linux上MySQL大小写敏感解决方案为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方案一: 设计时在数据库中命名都采用 小写字母或小写字母+下划线 的方式。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方案二: 用root登录，修改/etc/mysql/my.cnf, 在[mysqld]下加入一行：lower_case_table_names=1，重启数据库。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;但是特别注意：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As of MySQL 5.6.27, an error message is printed and the server exits if you attempt to start the server with –lower_case_table_names=0 on a case-insensitive file system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若需要设置lower_case_table_names = 1时，在重启数据库实例之前就需要将原来的数据库和表转换为小写，否则将找不到数据库名。而数据库名无法直接更名，可以新建一个小写的数据库名，然后rename table到新的数据库，完成表的迁移。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间遇到一个Hibernate/JPA自动映射MySQL Schema时报错问题，然后查了一下官方文档，原来是MySQL在Linux下默认区分大小写导致的，大致了解了一下，主要涉及两个变量lower_case_file_system和lower_case_table_names。&lt;/p&gt;
    
    </summary>
    
      <category term="Database" scheme="http://waterstrong.me/blog/categories/Database/"/>
    
    
      <category term="Linux" scheme="http://waterstrong.me/blog/tags/Linux/"/>
    
      <category term="数据库" scheme="http://waterstrong.me/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://waterstrong.me/blog/tags/MySQL/"/>
    
      <category term="Hibernate" scheme="http://waterstrong.me/blog/tags/Hibernate/"/>
    
      <category term="JPA" scheme="http://waterstrong.me/blog/tags/JPA/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个简单的IoC容器</title>
    <link href="http://waterstrong.me/blog/code-your-ioc/"/>
    <id>http://waterstrong.me/blog/code-your-ioc/</id>
    <published>2015-12-20T12:41:09.000Z</published>
    <updated>2016-04-17T09:30:09.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;h3 id=&quot;Let’s-Code-a-IoC-Container&quot;&gt;&lt;a href=&quot;#Let’s-Code-a-IoC-Container&quot; class=&quot;headerlink&quot; title=&quot;Let’s Code a IoC Container&quot;&gt;&lt;/a&gt;Let’s Code a IoC Container&lt;/h3&gt;&lt;p&gt;How to define a bean ?&lt;br&gt;How to store data collection ?&lt;br&gt;How to load component and bean ?&lt;br&gt;How to define a annotation ?&lt;br&gt;How to handle the annotation ?&lt;br&gt;How to create an Object ?&lt;br&gt;How to invoke a Method ?&lt;br&gt;How to initialize the container ?&lt;/p&gt;
&lt;p&gt;之前自己写了一个小的IoC Demo: &lt;a href=&quot;https://github.com/Waterstrong/summarine&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IoC Demo&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      IoC容器是依赖注入的框架，用来映射依赖，管理对象创建和生存周期（DI框架）。通过学习IoC可以简单实现一个IoC容器，同时加深对IoC的理解。
    
    </summary>
    
      <category term="Design Pattern" scheme="http://waterstrong.me/blog/categories/Design-Pattern/"/>
    
    
      <category term="Java" scheme="http://waterstrong.me/blog/tags/Java/"/>
    
      <category term="控制反转" scheme="http://waterstrong.me/blog/tags/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    
      <category term="依赖倒置" scheme="http://waterstrong.me/blog/tags/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE/"/>
    
      <category term="依赖注入" scheme="http://waterstrong.me/blog/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
      <category term="SOLID原则" scheme="http://waterstrong.me/blog/tags/SOLID%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis入门与实践</title>
    <link href="http://waterstrong.me/blog/mybatis-in-practice/"/>
    <id>http://waterstrong.me/blog/mybatis-in-practice/</id>
    <published>2015-10-12T04:52:44.000Z</published>
    <updated>2016-04-17T09:12:26.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;What-is-MyBatis&quot;&gt;&lt;a href=&quot;#What-is-MyBatis&quot; class=&quot;headerlink&quot; title=&quot;What is MyBatis?&quot;&gt;&lt;/a&gt;What is MyBatis?&lt;/h3&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;MyBatis is a first class persistence framework with support for custom SQL, stored procedures and advanced mappings.&lt;/li&gt;
&lt;li&gt;MyBatis eliminates almost all of the JDBC code and manual setting of parameters and retrieval of results.&lt;/li&gt;
&lt;li&gt;MyBatis can use simple XML or Annotations for configuration and map primitives, Map interfaces and Java POJOs (Plain Old Java Objects) to database records.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.mybatis.org/mybatis-3/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MyBatis 3 Introduction&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还没有时间去总结，不过相对来说不是太难，理论可以错过，但实践部分一定不能错过，之前写过一个Demo: &lt;a href=&quot;https://github.com/Waterstrong/demo-mybatis&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Demo-Mybatis&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      MyBatis是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以对配置和原生Map使用简单的XML或注解，将接口和Java的POJOs(Plain Old Java Objects,普通的Java对象)映射成数据库中的记录。
    
    </summary>
    
      <category term="Database" scheme="http://waterstrong.me/blog/categories/Database/"/>
    
    
      <category term="数据库" scheme="http://waterstrong.me/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="持久层框架" scheme="http://waterstrong.me/blog/tags/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"/>
    
      <category term="动态SQL" scheme="http://waterstrong.me/blog/tags/%E5%8A%A8%E6%80%81SQL/"/>
    
      <category term="Java" scheme="http://waterstrong.me/blog/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>C++单例模式实现</title>
    <link href="http://waterstrong.me/blog/cpp-singleton/"/>
    <id>http://waterstrong.me/blog/cpp-singleton/</id>
    <published>2011-12-27T16:00:00.000Z</published>
    <updated>2016-04-17T10:35:51.000Z</updated>
    
    <content type="html">&lt;p&gt;之前遇到关于C++实现单例模式的问题，并非那么简单，主要有部分问题要解决，现在和大家分享一下。我们都知道在Java/C#中实现起来相当容易，但C++确实是有点绕，不过这正是其魅力所在，现在直接上代码，有注释。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using namespace std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Singleton&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static Singleton* sin;//如果定义为static Singleton sin;在C++里这句话相当于有对象产生，还调用了构造函数，而此时此刻的Singleton 还没有创造出来，所以调用里就会有无法解析的外部符号的编译错误&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Singleton() //阻止创建实例&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt;&amp;quot;con&amp;quot;&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static Singleton* GetInstance()//返回实例，要么返回指针，要么返回引用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt;&amp;quot;ins&amp;quot;&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return sin;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static void Destroy()//应该显式释放sin，如果不显式释放，或者直接在析构函数里delete，当然在外部显式访问析构函数访问没问题，但是在delete sin时会再次调用析构函数，这样将造成不断地循环调用析构函数，这是非常可怕的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt;&amp;quot;destroy&amp;quot;&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(sin)//显式释放&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            delete sin;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sin = NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ~Singleton()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt;&amp;quot;descon&amp;quot;&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Singleton* Singleton::sin = new Singleton();//全局初始化, 必须new出来，在编译时就初始化了，如果出现派生的情况也只会有一个惟一的实例，而且构造函数声明为private后，派生类也没法写出构造函数，要注意的一点就是如果只有一个文件就可以直接写在后面，如果有.h和.cpp两个文件，那初始化应该写在.cpp文件中，否则可能会重定义错误。如果初始化为null,下次用时再判断并new的话必须要加双重锁定，消耗比较大，所以就采用这种方式了，不过这种消耗只有第一次才会出现，以后都不会new，但每次都要判断是否为null,也是很不爽的事。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int _tmain(int argc, _TCHAR* argv[])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Singleton* sin1 = Singleton::GetInstance();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Singleton* sin2 = Singleton::GetInstance();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (sin1 == sin2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt;&amp;quot;the same&amp;quot;&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt;&amp;quot;not the same&amp;quot;&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Singleton::Destroy();//一定要显式调用释放sin，可能还有其方法，但暂时还没有想到，最好能隐式释放，毕竟让客户端负责释放是不太明智的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    system(&amp;quot;pause&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;补充：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;process.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;Windows.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HANDLE mutex = CreateMutex(NULL,FALSE,NULL); //创建互斥量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;WaitForSingleObject(mutex,INFINITE);//等待互斥量&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;//……互斥代码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ReleaseMutex(mutex);//释放权限，让下一个线程可以进入&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CloseHandle(mutex);//关闭创建的mutex句柄&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mutex = NULL;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;双重锁定，当然要先创建互斥量并初始化，最后要清除。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static Singleton* GetInstance()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(!sin)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        WaitForSingleObject(mutex,INFINITE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (!sin)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sin = new Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ReleaseMutex(mutex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sin = new Singleton();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return sin;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;之前遇到关于C++实现单例模式的问题，并非那么简单，主要有部分问题要解决，现在和大家分享一下。我们都知道在Java/C#中实现起来相当容易，但C++确实是有点绕，不过这正是其魅力所在，现在直接上代码，有注释。&lt;/p&gt;
    
    </summary>
    
      <category term="Design Pattern" scheme="http://waterstrong.me/blog/categories/Design-Pattern/"/>
    
    
      <category term="C++" scheme="http://waterstrong.me/blog/tags/C/"/>
    
      <category term="设计模式" scheme="http://waterstrong.me/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Singleton" scheme="http://waterstrong.me/blog/tags/Singleton/"/>
    
  </entry>
  
  <entry>
    <title>DirectShow获取摄像头图像</title>
    <link href="http://waterstrong.me/blog/directshow-graphics/"/>
    <id>http://waterstrong.me/blog/directshow-graphics/</id>
    <published>2011-12-27T16:00:00.000Z</published>
    <updated>2016-03-29T15:50:03.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;在Windows下配置DirectX-Aug09-DShow获取摄像头图像&quot;&gt;&lt;a href=&quot;#在Windows下配置DirectX-Aug09-DShow获取摄像头图像&quot; class=&quot;headerlink&quot; title=&quot;在Windows下配置DirectX Aug09 DShow获取摄像头图像:&quot;&gt;&lt;/a&gt;在Windows下配置DirectX Aug09 DShow获取摄像头图像:&lt;/h4&gt;&lt;p&gt;1、首先带例子安装DXSDK_Aug09.exe，可在&lt;a href=&quot;http://msdn.microsoft.com/directx/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网&lt;/a&gt;下载&lt;a href=&quot;http://download.microsoft.com/download/4/C/F/4CFED5F5-B11C-4159-9ADC-E133B7E42E5C/DXSDK_Aug09.exe&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DirectX August 2009&lt;/a&gt;。假设安装路径为：D:\Program Files\Microsoft DirectX SDK (August 2009)。&lt;/p&gt;
&lt;p&gt;2、将strmbasd+&amp;amp;+strmbase文件夹中的两个dll文件拷到D:\Program Files\Microsoft DirectX SDK (August 2009)\Lib\x86下(64位机到x64下)。&lt;/p&gt;
&lt;p&gt;3、将DShow文件拷到D:\Program Files\Microsoft DirectX SDK (August 2009)\sample\C++下。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;4、Visual Studio中包含文件D:\Program Files\Microsoft DirectX SDK (August 2009)\Include和D:\Program Files\Microsoft DirectX SDK (August 2009)\Samples\C++\DirectShow\BaseClasses。&lt;/p&gt;
&lt;p&gt;5、添加库文件D:\Program Files\Microsoft DirectX SDK (August 2009)\Lib\x86到最顶端。&lt;/p&gt;
&lt;p&gt;6、添加strmbase.lib strmbasd.lib到lib链接器中。&lt;/p&gt;
&lt;p&gt;7、将ARFrameGrabber文件夹中的ARFrameGrabber.h 和 ARFrameGrabber.cpp 拷贝到到自己工程中（自己修改一下，加了些逻辑判断），再添加进来。测试一下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include&amp;lt;iostream&amp;gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;highgui.h&amp;gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;ARFrameGrabber.h&amp;quot;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;Windows.h&amp;gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;using namespace std;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int _tmain(int argc, _TCHAR* argv[])  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static ARFrameGrabber frameGrabber;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    IplImage ds_frame;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int stride;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BYTE* myBuffer;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    frameGrabber.Init(0, true); //设置支持directshow的设备编号，从0开始  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    frameGrabber.SetFlippedImage(true); //图像是否翻转  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    IplImage* frame=NULL;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cvNamedWindow(&amp;quot;test&amp;quot;,0);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while (true)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        frame = NULL;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        frameGrabber.GrabByteFrame(); //获取一帧  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        myBuffer = frameGrabber.GetByteBuffer(); //得到图像的缓冲  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(!myBuffer)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            UINT nRet=MessageBox(0,&amp;quot;警告：\n\n摄像头正被其他程序占用，请关闭可能使用摄像头的程序后重试！&amp;quot;,&amp;quot;启动出错&amp;quot;,MB_RETRYCANCEL|MB_ICONEXCLAMATION);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(nRet==IDRETRY)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                frameGrabber.GrabByteFrame(); //获取一帧  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                myBuffer = frameGrabber.GetByteBuffer(); //得到图像的缓冲  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            else  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                cvDestroyAllWindows();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                exit(0);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int width = frameGrabber.GetWidth();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int height = frameGrabber.GetHeight();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        stride  = (width * sizeof( RGBTRIPLE ) + 3) &amp;amp; -4;//图像每行所占的字节数，4的倍数，对齐  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cvInitImageHeader( &amp;amp;ds_frame, cvSize(width, height), 8, 3,IPL_ORIGIN_BL, 4 ); //创建IplImage  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ds_frame.widthStep = stride;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cvSetData( &amp;amp;ds_frame, myBuffer, stride ); //copy数据  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        frame = &amp;amp;ds_frame;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cvShowImage(&amp;quot;test&amp;quot;,frame);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (cvWaitKey(3)==27)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cvDestroyAllWindows();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h4 id=&quot;遇到问题一：&quot;&gt;&lt;a href=&quot;#遇到问题一：&quot; class=&quot;headerlink&quot; title=&quot;遇到问题一：&quot;&gt;&lt;/a&gt;遇到问题一：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;如果报错: &amp;quot;dxtrans.h&amp;quot;: No such file or directory&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在qedit.h 中添加如下&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define __IDxtCompositor_INTERFACE_DEFINED__   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define __IDxtAlphaSetter_INTERFACE_DEFINED__   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define __IDxtJpeg_INTERFACE_DEFINED__   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define __IDxtKey_INTERFACE_DEFINED__&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再修改qedit.h 中引用 dxtrans.h 的部分，要求注释掉&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;oaidl.h&amp;quot;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;ocidl.h&amp;quot;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//#include &amp;quot;dxtrans.h&amp;quot;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;amstream.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h4 id=&quot;遇到问题二：&quot;&gt;&lt;a href=&quot;#遇到问题二：&quot; class=&quot;headerlink&quot; title=&quot;遇到问题二：&quot;&gt;&lt;/a&gt;遇到问题二：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//#include &amp;lt;qedit.h&amp;gt; 出现问题，或者找不到了什么基类可以直接用下面方式  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define __IDxtCompositor_INTERFACE_DEFINED__   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define __IDxtAlphaSetter_INTERFACE_DEFINED__   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define __IDxtJpeg_INTERFACE_DEFINED__   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define __IDxtKey_INTERFACE_DEFINED__   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;qedit.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;注：以上除DXSDK_Aug09.exe安装文件外(553MB)，其他都可在资源《&lt;a href=&quot;http://download.csdn.net/download/waterstrong/3981334&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;配置DX_Aug09_DShow获取摄像头图像&lt;/a&gt;》中下载。&lt;/em&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;在Windows下配置DirectX-Aug09-DShow获取摄像头图像&quot;&gt;&lt;a href=&quot;#在Windows下配置DirectX-Aug09-DShow获取摄像头图像&quot; class=&quot;headerlink&quot; title=&quot;在Windows下配置DirectX Aug09 DShow获取摄像头图像:&quot;&gt;&lt;/a&gt;在Windows下配置DirectX Aug09 DShow获取摄像头图像:&lt;/h4&gt;&lt;p&gt;1、首先带例子安装DXSDK_Aug09.exe，可在&lt;a href=&quot;http://msdn.microsoft.com/directx/&quot;&gt;官网&lt;/a&gt;下载&lt;a href=&quot;http://download.microsoft.com/download/4/C/F/4CFED5F5-B11C-4159-9ADC-E133B7E42E5C/DXSDK_Aug09.exe&quot;&gt;DirectX August 2009&lt;/a&gt;。假设安装路径为：D:\Program Files\Microsoft DirectX SDK (August 2009)。&lt;/p&gt;
&lt;p&gt;2、将strmbasd+&amp;amp;+strmbase文件夹中的两个dll文件拷到D:\Program Files\Microsoft DirectX SDK (August 2009)\Lib\x86下(64位机到x64下)。&lt;/p&gt;
&lt;p&gt;3、将DShow文件拷到D:\Program Files\Microsoft DirectX SDK (August 2009)\sample\C++下。&lt;/p&gt;
    
    </summary>
    
      <category term="Graphics" scheme="http://waterstrong.me/blog/categories/Graphics/"/>
    
    
      <category term="图形图像" scheme="http://waterstrong.me/blog/tags/%E5%9B%BE%E5%BD%A2%E5%9B%BE%E5%83%8F/"/>
    
      <category term="DirectX" scheme="http://waterstrong.me/blog/tags/DirectX/"/>
    
      <category term="C++" scheme="http://waterstrong.me/blog/tags/C/"/>
    
      <category term="OpenCV" scheme="http://waterstrong.me/blog/tags/OpenCV/"/>
    
  </entry>
  
</feed>
