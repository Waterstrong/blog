<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Waterstrong Blog</title>
  <subtitle>Enjoy this moment!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.waterstrong.me/"/>
  <updated>2017-06-11T13:31:42.000Z</updated>
  <id>https://blog.waterstrong.me/</id>
  
  <author>
    <name>Waterstrong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最佳编程体验之旅 - 成都现场活动回顾</title>
    <link href="https://blog.waterstrong.me/tw-pair-programming-chengdu/"/>
    <id>https://blog.waterstrong.me/tw-pair-programming-chengdu/</id>
    <published>2017-06-08T13:10:12.000Z</published>
    <updated>2017-06-11T13:31:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="活动介绍"><a href="#活动介绍" class="headerlink" title="活动介绍"></a>活动介绍</h2><p><strong>Thought</strong>Works举办的最佳编程体验之旅结对编程活动，主要面向在校学生，旨在将一些好的实践以更加轻松有趣地方式分享给同学们，并且在体验结对编程乐趣的同时，更有机会获得超值大奖。<br><img src="/assets/2017-06-03/intro.png" alt="活动宣传页"></p>
<p>本次活动主要分为线上和现场，活动详情可参阅 <a href="https://school.thoughtworks.cn/pair-programming/" target="_blank" rel="external">ThoughtWorks最佳编程体验之旅 SEASON 2</a>，有兴趣可以进一步阅读 <a href="https://mp.weixin.qq.com/s?__biz=MzI0MDUyNDAxMQ==&amp;mid=2247483829&amp;idx=1&amp;sn=a4ee3f5ee47560cd3234f22ae8e94727&amp;chksm=e918ce31de6f472754691287e5d0430017c86d43f85eb0d7b7b06b9a60ae9ef575344496c6c3&amp;mpshare=1&amp;scene=1&amp;srcid=0516GqFBnZkePblBpz0eye1s#rd" target="_blank" rel="external">1+1&gt;2的编程验证？</a>。本次回顾主要是针对现场活动，不过还是需要介绍一下活动的整体周期安排：</p>
<ul>
<li>2017年05月20日 - 05月22日，有2个等级的挑战：挑战快捷键和挑战编程题，根据要求提交代码作业，根据第一关答题总和评定，解锁下一关。</li>
<li>2017年05月25日 晚8点，<a href="http://m.bilibili.com/video/av10847419.html" target="_blank" rel="external">ThoughtWorks最佳编程体验之旅Coding直播</a>，所有提交代码作业的同学均会邀请观看代码作业的结对编程直播。</li>
<li>2017年06月02日 - 06月04日，3天结对编程深入体验，一边写代码，一边学编程（结合第一轮&amp;第二轮评分、筛选、通知），每个城市前50位的同学将会前往<strong>Thought</strong>Works四地办公室（北京、西安、成都、武汉）参与结对编程深入体验。</li>
</ul>
<p><strong>现场活动时间:</strong><br>本次活动主要分为线上和现场活动，本次回顾主要是针对成都办公室现场活动，现场活动时间为2017年06月02日 - 06月04日。</p>
<p><strong>现场流程安排：</strong></p>
<ul>
<li>06月02日下午 主要是开场介绍、破冰、概念引入以及环境搭建</li>
<li>06月03日 公布题目、结对编程、现场指导、提交代码</li>
<li>06月04日 进行Showcase、总结点评、颁奖、合影</li>
</ul>
<p><strong>现场活动地点:</strong></p>
<ul>
<li>成都市高新区天府大道中段1268号 天府软件园E1-1栋7楼，ThoughtWorks办公室。</li>
</ul>
<h2 id="活动回顾"><a href="#活动回顾" class="headerlink" title="活动回顾"></a>活动回顾</h2><p>首先来一组豪华奖品照片，本次活动的奖品是印有Logo的大疆 Phantom 3 Standard 航拍无人机、斐尔可(FILCO) FKBN87ML/EB2 机械键盘以及主题T恤等。</p>
<div class="figure " style="width:;"><a class="fancybox" href="/assets/2017-06-03/award1.jpg" title="" data-fancybox-group="award"><img class="fig-img" src="/assets/2017-06-03/award1.jpg" alt=""></a></div><div style="clear:both;"></div>
<div class="figure fig-50" style="width:;"><a class="fancybox" href="/assets/2017-06-03/award2.jpg" title="" data-fancybox-group="award"><img class="fig-img" src="/assets/2017-06-03/award2.jpg" alt=""></a></div>
<div class="figure fig-50" style="width:;"><a class="fancybox" href="/assets/2017-06-03/award3.jpg" title="" data-fancybox-group="award"><img class="fig-img" src="/assets/2017-06-03/award3.jpg" alt=""></a></div><div style="clear:both;"></div>
<p>在3号(周六)，活动现场大家沉浸在结对编程的乐趣中，同时Coach参与指导每组学生结对过程，即使到了午饭时间大家还在很投入地编码。</p>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-06-03/onsite1.jpg" title="" data-fancybox-group="onsite"><img class="fig-img" src="/assets/2017-06-03/onsite1.jpg" alt=""></a></div>
<div class="figure fig-50" style="width:;"><a class="fancybox" href="/assets/2017-06-03/onsite2.jpg" title="" data-fancybox-group="onsite"><img class="fig-img" src="/assets/2017-06-03/onsite2.jpg" alt=""></a></div><div style="clear:both;"></div>
<p>在4号(周天)，一共有20队伍，每个队伍依次进行现场Showcase，大家热情非常高涨。</p>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-06-03/showcase1.jpg" title="" data-fancybox-group="showcase"><img class="fig-img" src="/assets/2017-06-03/showcase1.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-06-03/showcase2.jpg" title="" data-fancybox-group="showcase"><img class="fig-img" src="/assets/2017-06-03/showcase2.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-06-03/showcase3.jpg" title="" data-fancybox-group="showcase"><img class="fig-img" src="/assets/2017-06-03/showcase3.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-06-03/showcase4.jpg" title="" data-fancybox-group="showcase"><img class="fig-img" src="/assets/2017-06-03/showcase4.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-06-03/showcase5.jpg" title="" data-fancybox-group="showcase"><img class="fig-img" src="/assets/2017-06-03/showcase5.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-06-03/showcase6.jpg" title="" data-fancybox-group="showcase"><img class="fig-img" src="/assets/2017-06-03/showcase6.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-06-03/showcase7.jpg" title="" data-fancybox-group="showcase"><img class="fig-img" src="/assets/2017-06-03/showcase7.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-06-03/showcase8.jpg" title="" data-fancybox-group="showcase"><img class="fig-img" src="/assets/2017-06-03/showcase8.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-06-03/showcase9.jpg" title="" data-fancybox-group="showcase"><img class="fig-img" src="/assets/2017-06-03/showcase9.jpg" alt=""></a></div><div style="clear:both;"></div>
<p>Coach们在前一天(周六)晚上加紧评审所有组的代码和效果，再结合第二天的Showcase，最后当天(周天)中午再集中讨论，然后可以给出一个相对公平的综合排名，最后确定了前三名，不过没有获奖的同学也一定收获了不少干货。</p>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-06-03/prize1.jpg" title="" data-fancybox-group="prize"><img class="fig-img" src="/assets/2017-06-03/prize1.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-06-03/prize2.jpg" title="" data-fancybox-group="prize"><img class="fig-img" src="/assets/2017-06-03/prize2.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-06-03/prize3.jpg" title="" data-fancybox-group="prize"><img class="fig-img" src="/assets/2017-06-03/prize3.jpg" alt=""></a></div><div style="clear:both;"></div>
<p>最后大家非常开心，总结点评、颁奖之后，大家一起合照，至次，本次最佳编程体验之旅圆满结束。<br><img src="/assets/2017-06-03/all.jpg" alt=""></p>
<h2 id="活动小结"><a href="#活动小结" class="headerlink" title="活动小结"></a>活动小结</h2><p>本次活动很圆满成功，相对于去年的『男神女神活动』，今年参加的人数明显增多，而且效果也非常不错，当然去年的效果也很不错(学生少，Coach多，学生得到的指导也更多)。今年唯一需要吐槽一下的就是Coach太少了(40+学生，4位Coach)，这样连续两天半下来Coach和所有工作人员也都会感觉非常疲惫，不过大家一起将活动推向成功，相信每一个人内心也是非常高兴和满足的！</p>
]]></content>
    
    <summary type="html">
    
      ThoughtWorks举办的最佳编程体验之旅结对编程活动，主要面向在校学生，一边写代码，一边学编程，旨在将一些好的实践以更加轻松有趣地方式分享给同学们，并且在体验结对编程乐趣的同时，更有机会获得超值大奖。
    
    </summary>
    
      <category term="Community" scheme="https://blog.waterstrong.me/categories/Community/"/>
    
    
      <category term="Chengdu" scheme="https://blog.waterstrong.me/tags/Chengdu/"/>
    
      <category term="Pair" scheme="https://blog.waterstrong.me/tags/Pair/"/>
    
      <category term="TDD" scheme="https://blog.waterstrong.me/tags/TDD/"/>
    
      <category term="University" scheme="https://blog.waterstrong.me/tags/University/"/>
    
  </entry>
  
  <entry>
    <title>开发者关系大会 | 成都分会场 活动回顾</title>
    <link href="https://blog.waterstrong.me/DevRelCon2017-Chengdu/"/>
    <id>https://blog.waterstrong.me/DevRelCon2017-Chengdu/</id>
    <published>2017-05-08T13:20:37.000Z</published>
    <updated>2017-05-21T05:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p><em>中国首届开发者关系大会</em> 于5月6日在北京举行，16位来自欧美、中国、日本的开发者关系领域资深演讲嘉宾共聚北京，邀请大家共同探讨如何围绕产品和服务建立活跃的开发者社区、打造优质的开发者体验、维护良好的开发者关系，更多内容可以了解 <a href="http://weibo.com/ttarticle/p/show?id=2309404097576856093949" target="_blank" rel="external">微博</a>。为了不让成都的小伙伴错过这一次精彩的演讲，<em><acronym title="Free Code Camp">FCC</acronym>成都社区</em> 在5月6日当天组织了直播观影活动&amp;线下分享活动。</p>
<h2 id="活动介绍"><a href="#活动介绍" class="headerlink" title="活动介绍"></a>活动介绍</h2><p>本次是成都分会场的活动，除了直接观影外，还包括线下分享交流，主办方为：</p>
<ul>
<li>FCC成都社区</li>
<li>猿生态开发者社群</li>
</ul>
<p><strong>活动时间:</strong> </p>
<ul>
<li>2017年05月06日（周六），09:30-17:00</li>
</ul>
<p><strong>活动地点:</strong></p>
<ul>
<li>成都市高新区天府大道中段1268号 天府软件园E1-1栋7楼，ThoughtWorks办公室</li>
</ul>
<p><strong>活动流程:</strong> </p>
<ul>
<li>09:45-12:15 主会场直播观影</li>
<li>12:15-14:00 午餐 自由交流</li>
<li>14:00-15:00《生活的智慧 程序员的起源》—— Akagilnc</li>
<li>15:00-16:00《了解敏捷实践 感受敏捷文化》—— Waterstrong</li>
<li>16:00-17:00《工匠 重复中的精进》—— 水歌</li>
<li>17:00-17:05 反馈 合影</li>
</ul>
<h2 id="活动回顾"><a href="#活动回顾" class="headerlink" title="活动回顾"></a>活动回顾</h2><p>早上九点半左右，大家开始陆续签到入场。</p>
<div class="figure fig-100" style="width:;"><a class="fancybox" href="clear" title="" data-fancybox-group="live"><img class="fig-img" src="/assets/2017-05-06/sign_in.jpg" alt=""></a></div>
<p>已经远程接入直播观影中，不过远程的音质效果实在想吐槽一下了，最后不得不决定，提前开始线下的分享。</p>
<div class="figure fig-50" style="width:;"><a class="fancybox" href="/assets/2017-05-06/live1.jpg" title="" data-fancybox-group="live"><img class="fig-img" src="/assets/2017-05-06/live1.jpg" alt=""></a></div>
<div class="figure fig-50" style="width:;"><a class="fancybox" href="/assets/2017-05-06/live2.jpg" title="" data-fancybox-group="live"><img class="fig-img" src="/assets/2017-05-06/live2.jpg" alt=""></a></div><div style="clear:both;"></div>
<p>讲师精彩分享中，首先，由 <em>Ak</em> 分享了 <em>生活的智慧 程序员的起源</em>，然后，由我给大家分享了 <em>了解敏捷实践 感受敏捷文化</em>，最后，<em>水歌</em> 为大家分享了 <em>工匠 重复中的精进</em>，在此过程中，大家都在积极地参与讨论和提问，一起交流分享。</p>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-05-06/ak.jpg" title="" data-fancybox-group="speaker"><img class="fig-img" src="/assets/2017-05-06/ak.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-05-06/water.jpg" title="" data-fancybox-group="speaker"><img class="fig-img" src="/assets/2017-05-06/water.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-05-06/shuige.jpg" title="" data-fancybox-group="speaker"><img class="fig-img" src="/assets/2017-05-06/shuige.jpg" alt=""></a></div><div style="clear:both;"></div>
<p>最后大家一起合影，结束一天的活动，最后当然少不了吃顿好的，就不上图了，大家意会就可以了。<br><img src="/assets/2017-05-06/all.jpg" alt="活动合影"></p>
<h2 id="活动小结"><a href="#活动小结" class="headerlink" title="活动小结"></a>活动小结</h2><p>本次活动报名人数不算多，由于上午的远程直播音频声音太小，音质太差，因此临时决定将下午的分享提前到上午开始，在总体时间上还需要进一步控制。不过整体上活动还是不错的，虽然人数不多，但都是社区活跃者，大家都很投入，也得到了充分地沟通和交流，活动结束后大家也一起去聚了餐，感谢 <em>姜姜姜</em> 同学的盛情款待^_^。</p>
<div class="figure fig-33 right" style="width:;"><a class="fancybox" href="/assets/2017-05-06/certificate.jpg" title="" data-fancybox-group=""><img class="fig-img" src="/assets/2017-05-06/certificate.jpg" alt=""></a></div>
<p><strong>另外，开发者大会组委会还特意制作了精美证书，非常感谢！</strong></p>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
]]></content>
    
    <summary type="html">
    
      为了不让成都的小伙伴错过中国首届开发者关系大会精彩的演讲，FCC成都社区 在5月6日当天组织了直播观影活动&amp;线下分享活动。
    
    </summary>
    
      <category term="Community" scheme="https://blog.waterstrong.me/categories/Community/"/>
    
    
      <category term="Chengdu" scheme="https://blog.waterstrong.me/tags/Chengdu/"/>
    
      <category term="FCC" scheme="https://blog.waterstrong.me/tags/FCC/"/>
    
  </entry>
  
  <entry>
    <title>漫谈敏捷软件开发实践与文化</title>
    <link href="https://blog.waterstrong.me/understanding-agile/"/>
    <id>https://blog.waterstrong.me/understanding-agile/</id>
    <published>2017-04-30T07:37:05.000Z</published>
    <updated>2017-05-26T12:04:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>就在上月底，<em>MD</em> 发了一封关于敏捷实践的讨论到 <em>China</em> 邮件组，场面是非常激烈，当时并没有参与讨论，但回顾看了每一个人的讨论和观点，我自己也在思考，为什么现在大家的认知和理解产生了如此的分歧，我个人觉得这在某种程度上算一种“橙色”信号，有时候自己都开始怀疑之前的认知，都会变得不确定和不自信了。好在已经有了争论，有争论就要反思找到问题的根源，那就要有实际的行动来解决问题，达成统一的认知基准，不过在组织大面积实施 <em>Action</em> 之前，就我个人而言，决定好好回顾一下之前在入职前和 <acronym title="ThoughtWorks University">TWU</acronym> 时受到的敏捷文化熏陶和洗礼，同时结合书籍文章及在项目日常工作中遵循的敏捷实践来总结一下，正所谓是温故而知新。</p>
<p>刚好最近也受到好友 <abbr title="FCC成都社区负责人">姜姜姜</abbr> 之邀，希望在5月6号的『中国开发者关系大会』成都分会场线下分享一个话题，想来想去，那就分享关于敏捷实践和文化的话题吧，正好最近也在思考这个问题，而且自己对于敏捷实践和文化还是有一定理解的，也希望用通俗易懂的表达来阐述一下我理解的敏捷实践和文化，同时也想与大家一起交流探讨，或许我的理解也并不完整，因此，除了准备 <em>Keynote</em>，还是打算写这一篇博客，也好从整体上捋一捋自己的思路，多一些探讨和交流。</p>
<h2 id="敏捷开发是什么？"><a href="#敏捷开发是什么？" class="headerlink" title="敏捷开发是什么？"></a>敏捷开发是什么？</h2><p>敏捷(Agile)不是指某一种具体的方法论、过程或框架，而是一组价值观和原则。符合敏捷价值观和原则的开发方法包括：<em>极限编程(XP, Extreme Programming)</em>, <em>Scrum</em>, <em>精益软件开发(Lean Software Development)</em>, <em>动态系统开发方法(DSDM, Dynamic Systems Development Method)</em>, <em>特征驱动开发(FDD, Feature Driver Development)</em>，<em>水晶开发(Crystal)</em>等，不过最为常用的当属 <em>Scrum</em> 和 <em>XP</em> 了。<br><img src="/assets/agile/agile.jpg" alt="图片来自网络"></p>
<p>敏捷开发(Agile Development)是一种以人为核心、迭代、循序渐进的开发方法，即把以人为本、团队合作、快速响应变化和可工作的软件作为宗旨。敏捷开发的特征包括：迭代式开发、增量交付、开发团队和用户反馈推动产品开发、持续集成和开发团队自我管理。敏捷开发具体实践通常采用 <em>Scrum</em> 和 <em><acronym title="Extreme Programming">XP</acronym>(极限编程)</em>，在后续内容中会进行详细的介绍。</p>
<p>谈到了敏捷开发，不得不提到敏捷软件开发宣言(简称敏捷宣言)，敏捷开发是需要遵循一些共同的价值观和原则的。</p>
<h4 id="敏捷软件开发宣言"><a href="#敏捷软件开发宣言" class="headerlink" title="敏捷软件开发宣言"></a>敏捷软件开发宣言</h4><p>2001年，在美国犹他州瓦萨奇山雪鸟滑雪胜地，由17位专家组成的代表团制定并宣布了 <a href="http://agilemanifesto.org/" target="_blank" rel="external">敏捷软件开发宣言</a>。<br><img src="/assets/agile/manifesto.jpg" alt=""></p>
<p>官方翻译如下：</p>
<blockquote><p>我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：</p>
<p><strong>个体和互动</strong> 高于 流程和工具<br><strong>工作的软件</strong> 高于 详尽的文档<br><strong>客户合作</strong> 高于 合同谈判<br><strong>响应变化</strong> 高于 遵循计划</p>
<p>也就是说，尽管右项有其价值，我们更重视左项的价值。</p>
</blockquote> 
<p>特别要提醒的是，敏捷宣言一共是6句，而并不只是中间4句价值观，第一句很重要，最后一句更加重要。从第一句中可以体会到，敏捷宣言是通过不断实践总结出的价值观，是一种思维的导向和转变，是能够影响我们所做的每一件事情。而最后一句传递的意思是，敏捷宣言并不是否定右项的价值，并不是表达舍弃右项实施左项，而是在承认右项价值的同时更重视左项的价值，它们是可以共存的，为了树立正确的敏捷价值观，千万不可断章取义错误地传递了敏捷宣言。</p>
<p>敏捷宣言遵循的十二条原则:<br><blockquote><p><sub>我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。<br>欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。<br>经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。<br>业务人员和开发人员必须相互合作，项目中的每一天都不例外。<br>激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。<br>不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。<br>可工作的软件是进度的首要度量标准。<br>敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。<br>坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。<br>以简洁为本，它是极力减少不必要工作量的艺术。<br>最好的架构、需求和设计出自自组织团队。<br>团队定期地反思如何能提高成效，并依此调整自身的举止表现。</sub></p>
</blockquote> </p>
<p>需要强调的是，敏捷的价值观应遵照敏捷宣言，而不是简单粗暴地指向具体实践的价值观，通过实践来把握和体会敏捷宣言的价值观及其遵循的十二条原则，从而在不同的上下文和团队中达到一个有效的共识。</p>
<h2 id="为什么要敏捷开发？"><a href="#为什么要敏捷开发？" class="headerlink" title="为什么要敏捷开发？"></a>为什么要敏捷开发？</h2><p>长期以来，满足用户不断变化的需求是软件开发的难题之一。软件开发是一个复杂的活动，其过程中存在着需求的不确定性，也存在着技术的不确定性，更存在着团队和人员因素，软件开发方法一直处在不断发展过程中。<br><img src="/assets/agile/project_complex.png" alt="图片来自 scrumcn.com"></p>
<p>经典的瀑布模式把整个开发过程分为收集需求、定义、设计、编码、测试、发布等阶段，每个阶段设定明确的目标和标准，然后一步步按可预测计划实施，最终交付产品，但一旦需求变化，特别是在项目后期，瀑布模式显得力不从心了，因此，需要新的方法来解决这一问题。</p>
<p>而敏捷开发模式通过迭代来适应需求变化，每一次迭代周期结束后都可以生产或开发出一个可交付的软件产品，用户使用并体验，从而能够更早及时地收集用户反馈并处理需求变化，即从 <em>计划驱动</em> 转向为 <em>价值驱动</em>，这是一个新的软件开发趋势。敏捷开发注重的是人与人之间的交流，强调以人为核心，在高度协作的环境下，不断的通过反馈来进行自我调整和完善，从而能够全面提升团队的效率，敏捷开发以其能持续满足不断变化的用户需求的优势，已成为众多高效开发团队的制胜之道。</p>
<p>不过也不要对敏捷开发产生误解，敏捷开发不是银弹，它不是一个普适的方法，而是具有一定语境和背景的。如果当团队连 <em>自己要做什么事、为什么这样做、这样做为了解决什么问题</em> 都搞不清楚的情况下，那么敏捷开发不适合这样的团队，同时团队还要依赖于 <em>成员之间是否相互信任、是否与管理层之间建立了信任、是否与客户之间建立了信任</em> 等等因素。敏捷转型有很多成功的案例，当然也有很多失败的，敏捷开发的成功前提是其方法本身的适用性和团队对它的深入理解和合理运用。</p>
<h2 id="如何实践敏捷开发？"><a href="#如何实践敏捷开发？" class="headerlink" title="如何实践敏捷开发？"></a>如何实践敏捷开发？</h2><p>敏捷开发具体实践通常采用 <em>Scrum</em> 和 <em><acronym title="Extreme Programming">XP</acronym>(极限编程)</em>，通常的做法是，在管理模式上启用 <em>Scrum</em>，而在实践中，创造一个适合自己团队的 <em>XP</em>。那接下来就分别进行详细介绍。</p>
<h4 id="敏捷实践之-Scrum"><a href="#敏捷实践之-Scrum" class="headerlink" title="敏捷实践之 Scrum"></a>敏捷实践之 Scrum</h4><p><em>Scrum</em> 是一个用于开发和维持复杂产品的框架，是一种增量的、迭代的开发过程，通常用于敏捷软件开发，它并不等同于敏捷，Scrum一种流程，而敏捷是一种理念，<em>Scrum</em> 非常突出团队自组织能力。</p>
<p><img src="/assets/agile/scrum_origin.jpg" alt="图片来自网络"></p>
<p><em>Scrum</em> 是橄榄球运动的一个专业术语，原始含义是指英式橄榄球次要犯规时在犯规地点对阵争球。比喻在 <em>Scrum</em> 敏捷开发流程中，开发团队在开发一个项目时，大家像打橄榄球一样迅速敏捷，富有战斗激情、人人你争我抢的拼搏精神，可以看到一个兴奋的团队作为一个整体在高效地工作。</p>
<p>在 <em>Scrum</em> 框架中，整个开发过程由若干个短的迭代周期组成，一个短的迭代周期称为一个 <em>Sprint</em>，每个 <em>Sprint</em> 的建议长度是2到4周，互联网产品研发可使用1周的 <em>Sprint</em>。在 <em>Scrum</em> 中，使用 <em>Product Backlog</em> 来管理产品的需求，<em>Product Backlog</em> 是一个按照商业价值排序的需求列表，列表条目的体现形式通常为 <em>用户故事</em>。在 <em>Sprint</em> 中，<em>Scrum</em> 团队从 <em>Product Backlog</em> 中挑选对客户具有较高业务价值的需求作为最高优先级进行开发，挑选的需求在 <em>Sprint</em> 计划会议上经过讨论、分析和 <em>估算</em> 得到相应的任务列表，称之为 <em>Sprint Backlog</em> 。在每个迭代结束时，<em>Scrum</em> 团队将递交潜在可交付的产品增量，<em>Scrum</em> 适用于复杂的或创新性的项目。<br><img src="/assets/agile/scrum1.jpg" alt="Scrum框架 (图片来自网络)"></p>
<p>通常，在 <em>Product Backlog</em> 之前还会有更大粒度的产品需求形式 <em><a href="https://www.atlassian.com/agile/delivery-vehicles" target="_blank" rel="external">Epics</a></em>，包含了 <em>用户故事</em>。另外，在每天同一时间，在可视化的任务板前面召开10分钟左右的 <em>每日站会</em>，通常针对故事卡更新 <em>昨天完成了什么任务、今天打算做什么任务、遇到了哪些障碍或困难</em>，所有人都可以看到当前每个任务的状态和 <em>燃尽图(Burn Down Chart)</em>，在每个迭代结束时，还要 <em>Sprint Retrospective</em> 回顾上个迭代并提出改进。</p>
<p>一个 <em>Scrum</em> 团队是自组织、跨职能的完整团队，团队自己决定如何最好地完成工作，其包含三个角色:</p>
<ul>
<li>Product Owner: 即产品负责人，负责最大化产品以及开发团队工作的价值。</li>
<li>Scrum Master: 负责确保 <em>Scrum</em> 被理解并实施，并服务于产品负责人、开发团队和组织。</li>
<li>开发团队: 负责交付潜在可发布的产品增量，成员有5-10人，通常包含 <em>PM/BA/UX/DEV/QA</em>。</li>
</ul>
<p>Scrum的五个价值观：</p>
<ul>
<li>专注(Focus) – 一次只关注一小部分事情，把心思和能力用到团队工作上，输出价值</li>
<li>勇气(Courage) – 有勇气做出承诺，履行承诺，接受挑战，作为一个团队相互支持</li>
<li>开放(Openness) – 以开放地心态一起工作，全方位展现出工作的做事方式和关注点</li>
<li>承诺(Commitment) – 愿意对目标做出承诺，愿意一起付出，更致力于成功</li>
<li>尊重(Respect) – 每个人都有他独特的背景和经验，一起分享成功，承担责任，相互尊重</li>
</ul>
<p>但仅仅在软件开发部门实施 <em>Scrum</em> 是不够的，这不足以达成真正的敏捷，很多公司忽视了在企业文化、管理风格、流程以及项目执行方法上的必要改变，如果理解和使用不当，可能会更加低效。</p>
<h4 id="敏捷实践之-XP-极限编程"><a href="#敏捷实践之-XP-极限编程" class="headerlink" title="敏捷实践之 XP 极限编程"></a>敏捷实践之 XP 极限编程</h4><p><em><acronym title="Extreme Programming">XP</acronym></em> 是一种灵巧的轻量级软件开发方法，它强调把列出的每个方法和思想做到极限、做到最好，是敏捷软件开发中很著名的一个，<em>XP</em> 是针对业务和软件开发的规则，注重严格的工程实践约束。</p>
<p>极限编程和传统方法学的本质不同在于它更强调可适应性而不是可预测性，软件需求的不断变化是很自然的、不可避免的现象，极限编程的主要目标在于降低因需求变更而带来的成本，一个应用了极限编程方法的系统开发项目在应对需求变更时将显得更为灵活。<br><img src="/assets/agile/xp_circles.jpg" alt="极限编程实践 (图片来自网络)"></p>
<p>极限编程有如下一些核心实践，但并不要求满足所有，通常会根据团队情况进行一些裁剪和自定义：</p>
<ul>
<li>完整团队(Whole Team): 项目的所有参与者(开发人员、客户、测试人员等)工作在一起，是同一个团队的成员。</li>
<li>计划游戏(Planning Game): 结合项目进展和技术情况，根据商业价值确定下一阶段要开发与发布的系统范围，计划是持续的、循序渐进的，随着细节的不断变化而完善。</li>
<li>小型发布(Small Release): 采用迭代的交付方式，每个迭代1-3周时间，在每个迭代结束的时，团队交付可运行的经过测试的功能，及时处理用户反馈。</li>
<li>客户测试(Customer Tests): 客户可以根据脚本语言定义出自动验收测试来验证功能正常运行。</li>
<li>编码规范(Coding Standard): 开发人员都遵循统一的编码标准和规范，每个开发人员更易读懂别人的代码，尽可能减少不必要的文档，这也是实现代码集体所有的重要前提之一。</li>
<li>可持续的速度(Sustainable Pace): 以能够长期维持的速度和精力努力工作，把项目看作是马拉松长跑，而不是全速短跑，团队只有持久才有获胜的希望。</li>
<li>系统隐喻(System metaphor): 用普通语言和术语的集合来预见项目中的功能，通过隐喻来描述系统如何运作、新的功能以何种方式加入到系统。</li>
<li>持续集成(Continuous Integration): 频繁地通过自动化的构建(包括编译，发布，自动化测试)提供可运行的版本进行集成验证，从而尽快地发现项目风险和集成错误。</li>
<li>代码集体所有权(Collective Code Ownership): 每个成员都有更改任意部分代码的权利，所有的人对于全部代码负责。</li>
<li>测试驱动(Test-Driven Development, TDD): 在开发功能代码之前，先编写测试代码，然后只编写使测试通过的功能代码，从而以测试来驱动整个开发过程的进行。</li>
<li>重构(Refactoring): 在不改变系统行为的前提下，重新调整、优化系统的内部结构以减少复杂性、消除冗余、增加灵活性和提高设计的可重用性。</li>
<li>简单设计(Simple Design): 只处理当前的需求使设计保持尽可能简单，这些设计将在后续的开发过程中就被不断地重整和优化，整个设计过程是个螺旋式的、不断前进和发展的过程。</li>
<li>结对编程(Pair Programming): 由两位成员在同一台电脑上共同编写解决同一问题的代码，形式有多种，可以通过参考 <em>扩展阅读</em> 了解更多。</li>
</ul>
<p>除了最佳实践，极限编程还提倡四大价值：</p>
<ul>
<li>沟通(Communication)</li>
<li>简单(Simplicity)</li>
<li>反馈(Feedback)</li>
<li>勇气(Courage)</li>
</ul>
<p>极限编程是一种近螺旋式的开发方法，它将复杂的开发过程分解为一个个相对比较简单的小周期，通过积极的交流、反馈以及其它一系列的方法，团队和客户能够非常清楚掌握开发进度、变化、待解决的问题和潜在的困难等，并根据实际情况及时地调整开发过程。</p>
<p>关于 <em>Scrum</em> 和 <em>XP</em> 的区别可参阅『<a href="http://www.mountaingoatsoftware.com/blog/differences-between-scrum-and-extreme-programming" target="_blank" rel="external">Differences Between Scrum and Extreme Programming</a>』。</p>
<h2 id="敏捷实践与文化的融合"><a href="#敏捷实践与文化的融合" class="headerlink" title="敏捷实践与文化的融合"></a>敏捷实践与文化的融合</h2><h4 id="人就是核心，筑成优秀的团队"><a href="#人就是核心，筑成优秀的团队" class="headerlink" title="人就是核心，筑成优秀的团队"></a>人就是核心，筑成优秀的团队</h4><p>拥有一个积极的、自我管理的、具备自由交流风格的开发团队，是每个敏捷项目必不可少的条件。在平时的日常工作中，会根据每个项目情况而为团队分配有不同的角色人员，针对国内和国外项目的人员分配也会有一些调整，通常的角色包括: <em>PO、PM、IM、BA、DEV、UX、QA</em> 等，一般10个人左右。而大家最重要的目标是，通过持续不断地及早交付有价值的软件使客户满意，欣然面对需求变化，帮助客户提升竞争优势。</p>
<div class="figure center" style="width:80%;"><img class="fig-img" src="/assets/agile/roles.jpg" style="width:80%;" alt=""></div><div style="clear:both;"></div>
<h4 id="扁平化结构管理-amp-开放式办公环境"><a href="#扁平化结构管理-amp-开放式办公环境" class="headerlink" title="扁平化结构管理 &amp; 开放式办公环境"></a>扁平化结构管理 &amp; 开放式办公环境</h4><p>只有打造一个相对扁平的组织，给予充分的信任和自由度，才有利于敏捷的实施，换句话说，这就要求团队中的每个人有高度的自律性。在公司内部管理上，采用的是扁平化结构管理，开放式办公环境，每个人处于一种平等状态，每个人都可以面对面自由地交流，鼓励并引导大家相互主动给反馈(Feedback)、寻求反馈、接受反馈，同时针对反馈付出行动进行自我调整和完善，通过双向反馈机制让每个人每天都正面面对工作和生活，团队与成员都可以保持提升，形成良性循环。</p>
<div class="figure center" style="width:75%;"><img class="fig-img" src="/assets/agile/feedback.png" style="width:75%;" alt=""></div><div style="clear:both;"></div>
<h4 id="用户故事-amp-持续集成-持续交付"><a href="#用户故事-amp-持续集成-持续交付" class="headerlink" title="用户故事 &amp; 持续集成/持续交付"></a>用户故事 &amp; 持续集成/持续交付</h4><p>敏捷开发的日常实践已经形成一种常态，在工作中，每天都会看到的 <em>看板/故事墙、燃尽图(Burndown Chart)、CI/CD Pipeline</em> 等。通常会借助一些工具来辅助可视化，对于故事墙，根据不同项目的性质会选择采用不同的形式，大多情况优先选择使用物理墙，而对于一些海外交付项目会考虑选择使用电子墙，如 <em>Jira</em>、<em>Mingle</em>、<em>Trello</em> 等，目标都是更好地管理项目和跟踪任务，能够清晰地展示出当前迭代的进度和团队成员工作状态；对于 <em>CI/CD</em> 工具，可以选择使用 <em>GoCD</em> 、<em>Jenkins</em> 等，通过持续集成工具可以实现快速自动化构建、部署以及状态反馈，包括代码质量、自动化测试等。</p>
<div class="figure fig-50" style="width:;"><img class="fig-img" src="/assets/agile/story_wall.jpg" alt="故事墙示意图"><span class="caption">故事墙示意图</span></div>
<div class="figure fig-50" style="width:;"><img class="fig-img" src="/assets/agile/pipeline.jpg" alt="CI/CD示意图"><span class="caption">CI/CD示意图</span></div><div style="clear:both;"></div>
<h4 id="结对编程-amp-测试驱动开发"><a href="#结对编程-amp-测试驱动开发" class="headerlink" title="结对编程 &amp; 测试驱动开发"></a>结对编程 &amp; 测试驱动开发</h4><p>结对编程在工作中运用得非常普遍，从团队长期发展来看，确实有很多优势，可以保持更加专注，提高解决问题的效率，促进沟通与协作，传递知识和共享信息等，帮助提升团队整体能力和凝聚力。测试驱动开发(<acronym title="Test-Driven Development">TDD</acronym>)也是在项目开发很常用的一项实践，而且也是我司非常推崇的其中一项实践，是进入公司后必备的技能之一，通常对于新人的培训都会从 <em>TDD</em> 和 <em>Pair</em> 开始，<em>TDD</em> 的好处我就不想在这里讨论，倒是可以单独起一个话题讨论的，不过很多人一直对 <em>TDD</em> 和 <em>Pair</em> 有一些争论，但我一定投赞成票的，我相信当你尝试之后会乐此不疲的。</p>
<div class="figure center" style="width:85%;"><img class="fig-img" src="/assets/agile/pair.png" style="width:85%;" alt=""></div><div style="clear:both;"></div>
<h4 id="持续学习与分享，满腔热情突破自我"><a href="#持续学习与分享，满腔热情突破自我" class="headerlink" title="持续学习与分享，满腔热情突破自我"></a>持续学习与分享，满腔热情突破自我</h4><blockquote>
<p>Our mission is to better humanity through software and help drive the creation of a socially and economically just world.  —— <a href="https://www.thoughtworks.com/about-us" target="_blank" rel="external">www.thoughtworks.com</a></p>
</blockquote>
<p><em>We ThoughtWorkers</em> 满怀激情的汇聚在一起，以引导软件创新、设计和交付的革命为己任，助推全球社会变革。每个人都拥有一颗追求软件卓越的心，保持高涨的学习热情，持续不断地学习，乐于分享，敢于突破自我，在这样的团队中工作是一种相互促进，共同进步！<br><div class="figure center" style="width:;"><img class="fig-img" src="/assets/agile/passion.jpg" alt=""></div><div style="clear:both;"></div></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文中主要介绍了什么是敏捷、敏捷软件开发宣言、为什么要敏捷开发以及如何实践敏捷开发，针对敏捷开发实践详细介绍了 <em>Scrum</em> 和 <em>XP(极限编程)</em>，同时也结合平时的工作概括介绍了敏捷实践与文化的融合，最后再来谈一下自己的一些观点。</p>
<p>首先，不要对敏捷产生误解，敏捷不是一个普适的方法，并不适合所有团队，敏捷开发的适用范围主要包括：团队规模相对较小、项目经常发生变更、高风险的项目实施、开发人员可以参与决策、团队成员能够自组织等。敏捷转型有很多成功的案例，当然也有很多失败的，敏捷的成功前提是其方法本身的适用性和团队对它的深入理解和合理运用。</p>
<p>另外，拥有一个积极的、自我管理的、具备自由交流风格的开发团队，是每个敏捷项目必不可少的条件，只有打造一个相对扁平的组织，给予充分的信任和自由度，才有利于敏捷的实施。人是敏捷开发的核心，敏捷开发总是以人为中心建立开发的过程和机制，在团队中，每个人有高度的自律性，无论是团队还是个人都应坚持做到持续反馈、拥抱变化。</p>
<p>最后，在敏捷实践过程中，要因时而变，拒绝盲目套用方法论，但更要多实践，多反思，多分享，让敏捷成为一种习惯和基因，一句话高度概括为：<code>Being Agile rather than only doing Agile!</code>。在平时的工作中，我们所提倡的敏捷实践还是要做的，而且还要用心做好，不能只谈“心法”，如果基本的敏捷实践都做不好，那就更难达到敏捷的精神，就好像是一位剑客连剑都拿不起用不好，又何谈手中无剑心中有剑，又如何达到无招胜有招的境界呢！</p>
<p>敏捷提倡的以价值为导向的高响应力小团队结构，而针对大型组织里如何落地，有兴趣的朋友可以进一步了解 <em>扩展阅读</em> 中的 <em>精益企业</em> 相关内容。</p>
<hr>
<p>References</p>
<ul>
<li><a href="https://www.agilealliance.org/" target="_blank" rel="external">敏捷联盟官网</a></li>
<li><a href="http://agilemanifesto.org/iso/zhchs/manifesto.html" target="_blank" rel="external">敏捷软件开发宣言</a></li>
<li><a href="http://insights.thoughtworkers.org/how-many-words-in-agile-manifesto/" target="_blank" rel="external">敏捷宣言到底有几句</a></li>
<li><a href="http://www.scrumcn.com/agile/scrum-knowledge-library/agile-development.html" target="_blank" rel="external">敏捷开发简史</a></li>
<li><a href="http://www.scrumcn.com/agile/scrum-knowledge-library/scrum.html" target="_blank" rel="external">Scrum中文网</a></li>
<li><a href="https://www.scrumalliance.org/why-scrum/core-scrum-values-roles" target="_blank" rel="external">Scrum Alliance</a></li>
<li><a href="https://en.wikipedia.org/wiki/Extreme_programming" target="_blank" rel="external">Extreme programming</a></li>
<li><a href="http://www.mountaingoatsoftware.com/blog/differences-between-scrum-and-extreme-programming" target="_blank" rel="external">Differences Between Scrum and Extreme Programming</a></li>
<li><a href="http://www.360logica.com/blog/the-importance-of-different-agile-methodologies-included-in-agile-manifesto/" target="_blank" rel="external">The Importance of Different Agile Methodologies Included in Agile Manifesto</a></li>
</ul>
<hr>
<p><strong>扩展阅读:</strong></p>
<ul>
<li><a href="https://www.agilealliance.org/glossary/pairing/" target="_blank" rel="external">Pair Programming</a> | <a href="http://insights.thoughtworkers.org/pair-programming/" target="_blank" rel="external">结对编程的正确姿势，你会了吗？</a> | <a href="http://www.jianshu.com/p/d79cef4296b8" target="_blank" rel="external">如何爱上结对编程</a></li>
<li><a href="https://www.agilealliance.org/glossary/tdd/" target="_blank" rel="external">TDD</a> | <a href="http://insights.thoughtworkers.org/talk-about-tdd-again/" target="_blank" rel="external">让我们再聊聊TDD</a> | <a href="http://insights.thoughtworkers.org/talk-about-tdd-again-2/" target="_blank" rel="external">让我们再聊聊TDD 续</a> | <a href="http://www.jianshu.com/p/62f16cd4fef3" target="_blank" rel="external">深度解读 - TDD</a> | <a href="http://www.jianshu.com/p/971ae289e408" target="_blank" rel="external">推行TDD的思考</a></li>
<li><a href="http://insights.thoughtworkers.org/purpose-estimation/" target="_blank" rel="external">估算的目的</a> | <a href="http://insights.thoughtworkers.org/story-point/" target="_blank" rel="external">点之殇</a> | <a href="http://www.scrumcn.com/agile/scrum/8230.html" target="_blank" rel="external">做敏捷估算，请忘掉人/天</a></li>
<li><a href="http://insights.thoughtworkers.org/desk-check/" target="_blank" rel="external">敏捷实践之Desk Check</a> | <a href="http://insights.thoughtworkers.org/agile-showcase-se7en/" target="_blank" rel="external">敏捷实践Showcase的七宗罪</a> | <a href="http://insights.thoughtworkers.org/hl-kanban-task-management/" target="_blank" rel="external">看板任务管理</a></li>
<li><a href="http://insights.thoughtworkers.org/7-step-agenda-effective-retrospective/" target="_blank" rel="external">高效回顾会议的七步议程</a> | <a href="http://insights.thoughtworkers.org/engage-stakeholders-in-agile-development-project/" target="_blank" rel="external">敏捷实践中的利益相关者管理</a></li>
<li><a href="http://insights.thoughtworkers.org/agile-qa/" target="_blank" rel="external">敏捷QA，从入门到放弃</a> | <a href="http://insights.thoughtworkers.org/team-culture-building/" target="_blank" rel="external">变中求生——频繁变化的团队如何打造团队文化</a></li>
<li><a href="http://insights.thoughtworkers.org/from-agile-transformation-to-lean-enterprise/" target="_blank" rel="external">从敏捷转型到精益企业</a> | <a href="http://insights.thoughtworkers.org/lean-enterprise-principal/" target="_blank" rel="external">精益企业原则之：以产品为中心，而非交付项目</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      回顾受到的敏捷文化熏陶和洗礼，结合书籍文章及项目日常工作中遵循的敏捷实践，希望用通俗易懂的表达来阐述一下我理解的敏捷实践和文化，同时也想与大家一起交流探讨，正所谓是温故而知新。
    
    </summary>
    
      <category term="Methodology" scheme="https://blog.waterstrong.me/categories/Methodology/"/>
    
    
      <category term="Agile" scheme="https://blog.waterstrong.me/tags/Agile/"/>
    
      <category term="Scrum" scheme="https://blog.waterstrong.me/tags/Scrum/"/>
    
      <category term="XP" scheme="https://blog.waterstrong.me/tags/XP/"/>
    
  </entry>
  
  <entry>
    <title>第一期Docker工作坊活动回顾【多图】</title>
    <link href="https://blog.waterstrong.me/docker-workshop-part1/"/>
    <id>https://blog.waterstrong.me/docker-workshop-part1/</id>
    <published>2017-04-23T10:40:32.000Z</published>
    <updated>2017-05-30T00:29:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>IT行业近年来进入了飞速发展的时代，颠覆行业的IT产品层出不穷，从而造就的独角兽公司也一个接一个。软件开发领域不断演进的生态圈是支撑这些变革的重要基础。持续交付、云计算、微服务、DevOps…各种颠覆性的技术和概念层出不穷。</p>
<p>以Docker为首的容器技术也是近几年来非常火热的技术之一。Docker自从2014年发布1.0版本以后，容器技术终于走上了大规模商用的正轨。其带来的秒级启动、环境封装、安全隔离、高效迁移等优势对传统的持续集成及部署方式带来了巨大的冲击。如今，很多公司都已经在使用Docker了，并带来了良好的经济效益。</p>
<h2 id="活动介绍"><a href="#活动介绍" class="headerlink" title="活动介绍"></a>活动介绍</h2><p>此次『Docker In Production工作坊』将带你进入Docker的世界，通过动手练习快速掌握Docker基本技术和高阶使用，为在生产环境中使用Docker打下坚实的基础。</p>
<p>本次工作坊由 <em>ThoughtWorks成都Cloud&amp;DevOps社区</em> 组织，<em>Marketing团队</em>大力支持，非常感谢。活动总共包含两期，本次第一期内容包括：</p>
<ul>
<li>准备：环境搭建</li>
<li>第1章：容器介绍</li>
<li>第2章：了解Docker</li>
<li>第3章：卷和网络基础</li>
</ul>
<h2 id="活动日程"><a href="#活动日程" class="headerlink" title="活动日程"></a>活动日程</h2><p><strong>时间:</strong> 2017年4月22日（周六），10:00—16:30<br><strong>地点:</strong> 成都市高新区天府大道中段1268号 天府软件园E1-1栋7楼，ThoughtWorks办公室。<br><strong>活动流程:</strong> </p>
<hr>
<div class="figure right fig-25" style="width:;"><a class="fancybox" href="/assets/2017-04-22/agenda2.jpg" title="" data-fancybox-group=""><img class="fig-img" src="/assets/2017-04-22/agenda2.jpg" alt=""></a></div>
<p>10:00-10:30 介绍&amp;破冰<br>10:30-11:00 环境准备<br>11:00-12:00 容器介绍<br>12:00-13:00 午餐<br>13:00-14:30 了解Docker<br>14:30-14:40 茶歇<br>14:40-16:50 卷和网络基础</p>
<hr>
<p>由于本次活动场地及活动规模限制，为了更好地交流体验，本次活动人数限制到20人。<br>本工作坊需要大量的动手练习，参加的同学每人会携带笔记本一台(Windows、Mac、Linux操作系统均可)，为了让大家的环境统一，节省准备环境的时间，都会提前通知安装Vagrant和Virtualbox最新版本。</p>
<h2 id="活动回顾"><a href="#活动回顾" class="headerlink" title="活动回顾"></a>活动回顾</h2><p>大家经历一天的实战练习，都非常好地坚持下来了，而且还是热情高涨，首先来一张合照吧。<br><img src="/assets/2017-04-22/all_us.jpg" alt=""></p>
<p>那接下来就一起回顾一下本次活动吧。</p>
<p>参会人员陆续到达，开始签到啦，工作人员在前台进行引导入场。</p>
<div class="figure fig-50" style="width:;"><a class="fancybox" href="/assets/2017-04-22/sign_in_1.jpg" title="" data-fancybox-group="signin"><img class="fig-img" src="/assets/2017-04-22/sign_in_1.jpg" alt=""></a></div>
<div class="figure fig-50" style="width:;"><a class="fancybox" href="/assets/2017-04-22/sign_in_2.jpg" title="" data-fancybox-group="signin"><img class="fig-img" src="/assets/2017-04-22/sign_in_2.jpg" alt=""></a></div><div style="clear:both;"></div>
<p>大家开始拷贝相关资料，提前准备搭建环境。</p>
<div class="figure fig-50" style="width:;"><a class="fancybox" href="/assets/2017-04-22/prepare_1.jpg" title="" data-fancybox-group="prepare"><img class="fig-img" src="/assets/2017-04-22/prepare_1.jpg" alt=""></a></div>
<div class="figure fig-50" style="width:;"><a class="fancybox" href="/assets/2017-04-22/prepare_2.jpg" title="" data-fancybox-group="prepare"><img class="fig-img" src="/assets/2017-04-22/prepare_2.jpg" alt=""></a></div><div style="clear:both;"></div>
<p>主持人带领大家一起进入自我介绍环节，以小组的形式交流。</p>
<div class="figure fig-50" style="width:;"><a class="fancybox" href="/assets/2017-04-22/self_intro_0.jpg" title="" data-fancybox-group="selfintro"><img class="fig-img" src="/assets/2017-04-22/self_intro_0.jpg" alt=""></a></div>
<div class="figure fig-25" style="width:;"><a class="fancybox" href="/assets/2017-04-22/self_intro_1.jpg" title="" data-fancybox-group="selfintro"><img class="fig-img" src="/assets/2017-04-22/self_intro_1.jpg" alt=""></a></div>
<div class="figure fig-25" style="width:;"><a class="fancybox" href="/assets/2017-04-22/self_intro_2.jpg" title="" data-fancybox-group="selfintro"><img class="fig-img" src="/assets/2017-04-22/self_intro_2.jpg" alt=""></a></div>
<div class="figure fig-25" style="width:;"><a class="fancybox" href="/assets/2017-04-22/self_intro_3.jpg" title="" data-fancybox-group="selfintro"><img class="fig-img" src="/assets/2017-04-22/self_intro_3.jpg" alt=""></a></div>
<div class="figure fig-25" style="width:;"><a class="fancybox" href="/assets/2017-04-22/self_intro_4.jpg" title="" data-fancybox-group="selfintro"><img class="fig-img" src="/assets/2017-04-22/self_intro_4.jpg" alt=""></a></div><div style="clear:both;"></div>
<p>来看看讲师风采，非常地接地气，大家也都在认真地听讲。</p>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-04-22/course_1.jpg" title="" data-fancybox-group="course"><img class="fig-img" src="/assets/2017-04-22/course_1.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-04-22/course_2.jpg" title="" data-fancybox-group="course"><img class="fig-img" src="/assets/2017-04-22/course_2.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-04-22/course_3.jpg" title="" data-fancybox-group="course"><img class="fig-img" src="/assets/2017-04-22/course_3.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-04-22/course_4.jpg" title="" data-fancybox-group="course"><img class="fig-img" src="/assets/2017-04-22/course_4.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-04-22/course_5.jpg" title="" data-fancybox-group="course"><img class="fig-img" src="/assets/2017-04-22/course_5.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-04-22/course_11.jpg" title="" data-fancybox-group="course"><img class="fig-img" src="/assets/2017-04-22/course_11.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-04-22/course_22.jpg" title="" data-fancybox-group="course"><img class="fig-img" src="/assets/2017-04-22/course_22.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-04-22/course_44.jpg" title="" data-fancybox-group="course"><img class="fig-img" src="/assets/2017-04-22/course_44.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-04-22/course_55.jpg" title="" data-fancybox-group="course"><img class="fig-img" src="/assets/2017-04-22/course_55.jpg" alt=""></a></div><div style="clear:both;"></div>
<p>茶歇和午餐肯定是少不了的啦，免费的活动还提供零食，更能学到知识，实在太值了。</p>
<div class="figure fig-50" style="width:;"><a class="fancybox" href="/assets/2017-04-22/break_2.jpg" title="" data-fancybox-group="break"><img class="fig-img" src="/assets/2017-04-22/break_2.jpg" alt=""></a></div>
<div class="figure fig-50" style="width:;"><a class="fancybox" href="/assets/2017-04-22/break_1.jpg" title="" data-fancybox-group="break"><img class="fig-img" src="/assets/2017-04-22/break_1.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-04-22/fruit_1.jpg" title="" data-fancybox-group="break"><img class="fig-img" src="/assets/2017-04-22/fruit_1.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-04-22/food_1.jpg" title="" data-fancybox-group="break"><img class="fig-img" src="/assets/2017-04-22/food_1.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-04-22/fruit_2.jpg" title="" data-fancybox-group="break"><img class="fig-img" src="/assets/2017-04-22/fruit_2.jpg" alt=""></a></div><div style="clear:both;"></div>
<p>大家一起完成练习，非常地投入，热情洋溢。</p>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-04-22/practice_1.jpg" title="" data-fancybox-group="practice"><img class="fig-img" src="/assets/2017-04-22/practice_1.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-04-22/practice_2.jpg" title="" data-fancybox-group="practice"><img class="fig-img" src="/assets/2017-04-22/practice_2.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-04-22/practice_3.jpg" title="" data-fancybox-group="practice"><img class="fig-img" src="/assets/2017-04-22/practice_3.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-04-22/practice_4.jpg" title="" data-fancybox-group="practice"><img class="fig-img" src="/assets/2017-04-22/practice_4.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-04-22/practice_5.jpg" title="" data-fancybox-group="practice"><img class="fig-img" src="/assets/2017-04-22/practice_5.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-04-22/practice_6.jpg" title="" data-fancybox-group="practice"><img class="fig-img" src="/assets/2017-04-22/practice_6.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-04-22/practice_7.jpg" title="" data-fancybox-group="practice"><img class="fig-img" src="/assets/2017-04-22/practice_7.jpg" alt=""></a></div>
<div class="figure fig-33" style="width:;"><a class="fancybox" href="/assets/2017-04-22/practice_8.jpg" title="" data-fancybox-group="practice"><img class="fig-img" src="/assets/2017-04-22/practice_8.jpg" alt=""></a></div><div style="clear:both;"></div>
<p>最后活动结束了，讲师和志愿者们一起进行Retro，回顾这一天的活动。</p>
<div class="figure fig-50" style="width:;"><a class="fancybox" href="/assets/2017-04-22/retro_1.jpg" title="" data-fancybox-group="retro"><img class="fig-img" src="/assets/2017-04-22/retro_1.jpg" alt=""></a></div>
<div class="figure fig-50" style="width:;"><a class="fancybox" href="/assets/2017-04-22/retro_2.jpg" title="" data-fancybox-group="retro"><img class="fig-img" src="/assets/2017-04-22/retro_2.jpg" alt=""></a></div><div style="clear:both;"></div>
<h2 id="活动小结"><a href="#活动小结" class="headerlink" title="活动小结"></a>活动小结</h2><p>本次活动得到了Marketing团队的大力支持，同时组织者们也精心准备，经历内部多次的Rehearsal演练给大家分享了精彩的内容，得到了很多同学的好评。不过在过程中也遇到了很多问题，比如某些电脑配置不高，导致没有办法完成后续练习，体验效果不好，还有Windows电脑在安装环境时出现了一些问题，比如内存和空间不足，配置不正确等。实在没有办法的情况下，只能让两个人Pair练习了，而且讲师们也贡献出了自己的电脑帮助大家练习。</p>
<p>总得来说，这次活动还是很成功的，期待第二期内容。这里做一下第二期的广告，时间待定，主要内容包括：</p>
<ul>
<li>服务注册发现(Consul的使用)</li>
<li>多主机部署(Docker Swarm应用)</li>
<li>Docker日志监控(ELASTICSEARCH, FLUENTD, AND KIBANA)</li>
<li>应用和服务管理(监控和报警, 自定义Dashboard)</li>
<li>…</li>
</ul>
<hr>
<p><strong>特此致谢</strong></p>
<p><sub>志愿者及负责人</sub></p>
<blockquote>
<p>Zhenghe Yu, Zejiang Yu, Chen Lin, Junyao Yu, Xiaoman Ou, Ying He, Yixiu Tang</p>
</blockquote>
<p><sub>讲师</sub></p>
<blockquote>
<p>Bowen Huang, Pei Xu, Yidong Du, Qinmu Xie, Shuiqiang Lin</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      此次『Docker In Production工作坊』将带你进入Docker的世界，通过动手练习快速掌握Docker基本技术和高阶使用。本次工作坊由 ThoughtWorks成都DevOps社区 组织，Marketing团队大力支持。
    
    </summary>
    
      <category term="Community" scheme="https://blog.waterstrong.me/categories/Community/"/>
    
    
      <category term="Docker" scheme="https://blog.waterstrong.me/tags/Docker/"/>
    
      <category term="DevOps" scheme="https://blog.waterstrong.me/tags/DevOps/"/>
    
      <category term="Workshop" scheme="https://blog.waterstrong.me/tags/Workshop/"/>
    
      <category term="Chengdu" scheme="https://blog.waterstrong.me/tags/Chengdu/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习与实践 - 安全篇</title>
    <link href="https://blog.waterstrong.me/docker-security/"/>
    <id>https://blog.waterstrong.me/docker-security/</id>
    <published>2017-04-08T12:17:16.000Z</published>
    <updated>2017-05-30T00:40:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在多数情况下，启动Docker容器时都以root用户权限在运行，那么如果有ROOT权限可以做什么呢？当然可以做很多的事情，比如：访问所有信息、修改任何内容、关闭机器、结束进程以及安装各种软件等。</p>
<p>容器的安全性问题的根源在于容器和宿主机共享内核，如果容器里的应用导致Linux内核崩溃，那么整个系统可能都会崩溃。与虚拟机是不同的，虚拟机并没有与主机共享内核，虚拟机崩溃一般不会导致宿主机崩溃。</p>
<p>Docker的安全性主要体现在如下几个方面：</p>
<ul>
<li>Docker容器安全性，如：是否会危害到宿主机或其他容器；</li>
<li>镜像的安全性，如：如何确保下载的镜像是可信的、未被篡改过的；</li>
<li>Docker守护进程安全性，如：如何确保发送给Daemon的命令是由可信用户发起的。</li>
</ul>
<p>接下来会通过一些简单的操作来验证一些安全问题，同时会提出一些安全上的实践和原则。</p>
<h2 id="Docker访问主机系统"><a href="#Docker访问主机系统" class="headerlink" title="Docker访问主机系统"></a>Docker访问主机系统</h2><ul>
<li><p>首先来验证一下，能否访问主机上的存储密码相关的 <a href="http://www.tldp.org/LDP/lame/LAME/linux-admin-made-easy/shadow-file-formats.html" target="_blank" rel="external">/etc/shadow</a> 文件？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/shadow  <span class="comment"># 使用普通用户访问</span></div><div class="line">cat: /etc/shadow: Permission denied</div><div class="line"></div><div class="line">$ who am i; groups;  <span class="comment"># 查看当前的用户和组</span></div><div class="line">vagrant  pts/0  (10.0.2.2)</div><div class="line">vagrant docker</div><div class="line"></div><div class="line">$ sudo cat /etc/shadow  <span class="comment"># 使用管理员用户访问</span></div><div class="line">root:<span class="variable">$6</span><span class="variable">$HmunRCSU</span><span class="variable">$YXNgf</span>...bnj2AVtjAFfmh0:16744:0:99999:7:::</div><div class="line">daemon:*:16744:0:99999:7:::</div><div class="line">vagrant:<span class="variable">$6</span><span class="variable">$55jH0QFsuLa</span>...vGb8lH/9jQy4r0:16744:0:99999:7:::</div><div class="line">...</div></pre></td></tr></table></figure>
</li>
<li><p>再来验证一下，能否在 Docker 容器中访问<code>/etc/shadow</code>文件呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ docker run -v /:/hostfs busybox cat /hostfs/etc/shadow</div><div class="line">root:<span class="variable">$6</span><span class="variable">$HmunRCSU</span><span class="variable">$YXNgf</span>...bnj2AVtjAFfmh0:16744:0:99999:7:::</div><div class="line">daemon:*:16744:0:99999:7:::</div><div class="line">vagrant:<span class="variable">$6</span><span class="variable">$55jH0QFsuLa</span>...vGb8lH/9jQy4r0:16744:0:99999:7:::</div><div class="line">...</div></pre></td></tr></table></figure>
<p>可以看到，在容器中是可以访问宿主机上只有root用户才能访问的密码敏感文件的，当然也是可以访问其他root权限的文件的。</p>
</li>
<li><p>再来看一下，能否在Docker容器中修改主机文件系统？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ ls / | grep threat</div><div class="line"></div><div class="line">$ docker run -it -v /:/hostfs busybox touch /hostfs/threat-on-the-way</div><div class="line"></div><div class="line">$ ls / | grep threatls / | grep threat</div><div class="line">threat-on-the-way</div></pre></td></tr></table></figure>
<p>可以看到，在 Docker 容器中，能够在宿主机根目录创建文件，并且可以修改主机文件系统。更严重的时，如果是 <a href="https://docs.docker.com/engine/security/security/#kernel-namespaces" target="_blank" rel="external">Privileged</a> 容器，即在运行容器时指定<code>--privileged=true</code>参数，则能够允许容器所有设备执行任意操作，能够读写内核内存<code>/proc/kcore</code>，使用参数<code>--net=host</code>可以嗅探主机所有网络流量。</p>
</li>
<li><p>最后，来查看一下 Docker 容器和<code>Metadata</code>存储在哪儿？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ ls  /var/lib/docker</div><div class="line">aufs  containers  graph  linkgraph.db  network  repositories-aufs  tmp  trust  volumes</div><div class="line"></div><div class="line">$ <span class="built_in">cd</span> /var/lib/docker/; sudo du --max-depth=1</div><div class="line">4	./trust</div><div class="line">88	./network</div><div class="line">5246812	./aufs</div><div class="line">4	./tmp</div><div class="line">579872	./volumes</div><div class="line">1900	./containers</div><div class="line">11740	./graph</div><div class="line">5840444	.</div></pre></td></tr></table></figure>
<p>运行态容器默认都是使用<code>/var/docker/lib</code>目录，容器内部写日志、产生运行时数据等都会影响该目录，并且产生的文件越来越多，占用空间越来越大，因此需要定期清理无用的镜像和容器，应为Docker挂载点<code>/var/docker/lib</code>创建单独的分区，最好是SSD盘。<br>另外，最推荐使用供应商最支持的存储驱动程序，<a href="https://en.wikipedia.org/wiki/Aufs" target="_blank" rel="external">aufs</a>是唯一的允许容器共享执行文件的存储驱动，但可能会导致严重的内核崩溃。</p>
</li>
</ul>
<h2 id="Docker安全最佳实践"><a href="#Docker安全最佳实践" class="headerlink" title="Docker安全最佳实践"></a>Docker安全最佳实践</h2><p>为了保证 Docker 安全性，需要在各方面遵循一些实践和原则，包括宿主机方面、Docker守护进程、使用镜像以及容器运行方面。</p>
<h4 id="在宿主机方面"><a href="#在宿主机方面" class="headerlink" title="在宿主机方面"></a>在宿主机方面</h4><ul>
<li>保持内核及时更新，防止黑客利用未修复的漏洞进行攻击</li>
<li>增强主机安全保护，如果主机不安全了，容器也就谈不上安全了</li>
<li>保持Docker及时更新，特别要关注Docker安全相关方面的更新</li>
</ul>
<h4 id="守护进程方面"><a href="#守护进程方面" class="headerlink" title="守护进程方面"></a>守护进程方面</h4><ul>
<li>只允许受信用户控制Docker守护进程，保证与Daemon的连接是可信的</li>
<li>不使用不受信的镜像仓库，因为镜像可能会被篡改过</li>
<li>必要时请为Docker守护进程应用 <a href="https://docs.docker.com/engine/security/https/" target="_blank" rel="external">TLS</a> 认证网络</li>
<li>限制容器之间的网络通信，如果两个容器之间没有通信的必要就限制其网络通信功能</li>
</ul>
<h4 id="使用镜像方面"><a href="#使用镜像方面" class="headerlink" title="使用镜像方面"></a>使用镜像方面</h4><ul>
<li>在Dockerfile中为容器创建一个非root用户，具体方法可以参阅 <a href="http://www.projectatomic.io/docs/docker-image-author-guidance/" target="_blank" rel="external">文章</a></li>
<li>以非root用户运行容器进程，最大程度控制用户的权限范围</li>
<li>只使用受信的基础镜像，可由最小基础镜像开始(<a href="https://hub.docker.com/_/busybox/" target="_blank" rel="external">Busybox</a>, <a href="https://hub.docker.com/_/alpine/" target="_blank" rel="external">Alpine</a>)，最好是建立<a href="https://docs.docker.com/v1.6/articles/registry_mirror/" target="_blank" rel="external">本地仓库镜像</a></li>
<li>仅安装必要的包，因为可能有些包会有漏洞，一定程度上降低风险</li>
<li>重新构建镜像时需要包含安全补丁，防止黑客利用漏洞实施攻击</li>
</ul>
<h4 id="容器运行时方面"><a href="#容器运行时方面" class="headerlink" title="容器运行时方面"></a>容器运行时方面</h4><ul>
<li>不要到产品环境中使用任何开发者工具(<a href="https://github.com/boot2docker/boot2docker" target="_blank" rel="external">boot2docker</a>, <a href="https://kitematic.com/" target="_blank" rel="external">kinematic</a>)</li>
<li>限制容器使用Linux内核能力和资源使用，为守护进程设置受限的控制资源权限(<a href="https://docs.docker.com/engine/reference/commandline/run/#configure-namespaced-kernel-parameters-sysctls-at-runtime" target="_blank" rel="external">–ulimit</a>)</li>
<li>不要使用 <a href="https://docs.docker.com/engine/security/security/#kernel-namespaces" target="_blank" rel="external">Privileged</a> 容器，如果使用<code>--privileged</code>参数将授予容器与主机几乎相同的权限</li>
<li>指定容器重启策略为<code>on-failure</code>，重启策略有四种，详细可以参阅 <a href="https://docs.docker.com/engine/reference/run/#restart-policies---restart" target="_blank" rel="external">Restart policies</a></li>
<li>使用<em>强制权限控制系统</em> <a href="https://wiki.ubuntu.com/AppArmor" target="_blank" rel="external">AppArmor</a> 和 <em>Linux安全增强工具</em> <a href="http://selinuxproject.org/page/Main_Page" target="_blank" rel="external">SELinux</a> 保证额外的安全层</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Docker安全性主要体现在容器安全性、镜像安全性和守护进程安全性，可以看到在Docker容器中能够访问宿主机的高权限资源，如果管理和使用不得当，将造成严重的后果，因此，在平时使用Docker时应在多方面遵循一些最佳实践和原则，包括宿主机方面、Docker守护进程、使用镜像以及容器运行等方面，尽可能保证 Docker 安全性。</p>
<p><sub>「<em>特此声明: 本文大部分内容译自内部培训资料</em>」</sub></p>
<hr>
<p>References</p>
<ul>
<li><a href="https://docs.docker.com/engine/security/security/" target="_blank" rel="external">Docker security</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/security/kernel_ns.html" target="_blank" rel="external">内核命名空间</a></li>
<li><a href="https://segmentfault.com/a/1190000005794220" target="_blank" rel="external">Docker进阶与实战 - Docker安全</a></li>
<li><a href="http://www.projectatomic.io/docs/docker-image-author-guidance/" target="_blank" rel="external">Guidance for Docker Image Authors</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      Docker安全性主要体现在容器安全性、镜像安全性和守护进程安全性方面，容器的安全性问题的根源在于容器和宿主机共享内核，如果容器里的应用导致Linux内核崩溃，那么整个系统可能都会崩溃。
    
    </summary>
    
      <category term="Platforms" scheme="https://blog.waterstrong.me/categories/Platforms/"/>
    
    
      <category term="Docker" scheme="https://blog.waterstrong.me/tags/Docker/"/>
    
      <category term="容器" scheme="https://blog.waterstrong.me/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Security" scheme="https://blog.waterstrong.me/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习与实践 - 网络篇</title>
    <link href="https://blog.waterstrong.me/docker-networking/"/>
    <id>https://blog.waterstrong.me/docker-networking/</id>
    <published>2017-04-02T13:59:27.000Z</published>
    <updated>2017-05-30T00:40:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>通常来说，要实现网络通信，机器需要至少一个网络接口(物理接口或虚拟接口)来收发数据包，另外，如果不同子网之间要进行通信，还需要路由机制。Docker中的网络接口默认都是虚拟接口，虚拟接口的优势之一是转发效率较高。</p>
<p>Linux通过在内核中进行数据复制来实现虚拟接口之间的数据转发，通俗地讲，<em>发送接口</em>的<em>发送缓存</em>数据包被直接复制到<em>接收接口</em>的<em>接收缓存</em>中，对于本地系统和容器内系统来说，就像是一个正常的以太网卡，但它不需要真正与外部网络设备通信，因此速度快，转发效率高。</p>
<p>Docker的网络实现其实就是利用了该技术，即利用了Linux上的网络命名空间和虚拟网络设备实现的，特别是<code>veth pair</code>，它在宿主机和容器内分别创建虚拟接口，并让它们彼此连通。</p>
<h2 id="Docker网络实现原理"><a href="#Docker网络实现原理" class="headerlink" title="Docker网络实现原理"></a>Docker网络实现原理</h2><p>启动Docker时会在宿主机上创建一个名为<code>docker0</code>的虚拟网桥，Docker启动一个容器时会根据<code>docker0</code>的网段划分容器的虚拟子网和私有IP，容器内的虚拟接口为<code>eth0</code>，各容器的网关则是<code>docker0</code>的IP。<br><img src="/assets/docker-network/docker_bridge.jpg" alt=""></p>
<p>Docker创建一个容器的时候，会执行如下操作：</p>
<ol>
<li>创建一对虚拟接口，即<code>veth pair</code>，分别放到宿主机和容器中;</li>
<li>主机一端桥接到默认的<code>docker0</code>或指定网桥上，具有一个唯一的名字，如<code>veth0ac844e</code>;</li>
<li>另一端放到新容器中，并修改名字为<code>eth0</code>，该接口只在容器的命名空间可见;</li>
<li>从网桥可用地址段中获取一个空闲地址分配给容器的<code>eth0</code>，并配置默认路由到桥接网卡<code>veth0ac844e</code>。</li>
</ol>
<p>这样，该容器就可以使用<code>eth0</code>虚拟网卡来连接其它容器和网络了。当该容器结束后，Docker会清空容器，容器内的<code>eth0</code>会随网络命名空间一起被清除，<code>veth0ac844e</code>接口也被自动从<code>docker0</code>卸载。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">$ ip addr  <span class="comment"># 可以看到网桥docker0分配的子网段是172.17.0.1/16</span></div><div class="line">...</div><div class="line">7: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</div><div class="line">    link/ether 02:42:74:d9:49:de brd ff:ff:ff:ff:ff:ff</div><div class="line">    inet 172.17.0.1/16 scope global docker0</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">    inet6 fe80::42:74ff:fed9:49de/64 scope link</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">...</div><div class="line"></div><div class="line">$ brctl show  <span class="comment"># 可以看到网桥docker0上的虚拟接口</span></div><div class="line">bridge name	bridge id		STP enabled	interfaces</div><div class="line">docker0		8000.024274d949de	no		veth0ac844e</div><div class="line">							veth36e091d</div><div class="line"></div><div class="line">$ brctl showstp docker0  <span class="comment"># 查看网桥docker0的生成树状态</span></div><div class="line">...</div><div class="line"></div><div class="line">$ ethtool -i docker0  <span class="comment"># 查看网桥docker0的网卡驱动类型</span></div><div class="line">driver: bridge</div><div class="line">version: 2.3</div><div class="line">...</div><div class="line"></div><div class="line">$ ethtool -S veth0ac844e  <span class="comment"># 查看该网络接口的唯一识别编号peer_ifindex</span></div><div class="line">NIC statistics:</div><div class="line">     peer_ifindex: 10</div><div class="line"></div><div class="line">$ ip link  <span class="comment"># 进入容器后运行该命令，查看veth编号</span></div><div class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default</div><div class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</div><div class="line">10: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default</div><div class="line">    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff</div></pre></td></tr></table></figure>
<h2 id="Docker容器网络模型"><a href="#Docker容器网络模型" class="headerlink" title="Docker容器网络模型"></a>Docker容器网络模型</h2><h4 id="网络模型基本组件"><a href="#网络模型基本组件" class="headerlink" title="网络模型基本组件"></a>网络模型基本组件</h4><p>在容器网络模型中，通常会包括容器(Container)、沙箱(Sandbox)、端点(Endpoint)、网络(Network)等组件，其中，网络会涉及桥接网(Bridge Network)或重叠网(Overlay Network)。</p>
<p>容器网络模型示意图如下图所示：<br><img src="/assets/docker-network/networking_model.png" alt=""></p>
<ul>
<li>容器(Container): 容器能够作为任意一个或多个网络的一部分，能够同时对接桥接网和重叠网网络。</li>
<li>沙箱(Sandbox): 包含容器网络堆栈配置信息，是一个隔离的环境，可能包含多网络的多个端点。</li>
<li>端点(Endpoint): 连接沙箱和网络的接口，绑定到特定的网络，比如之前提到的<code>veth pair</code>。</li>
<li>网络(Network): 使得一组端点之间能够相互直接交流的，实现可以是Linux网桥或重叠网。</li>
</ul>
<h4 id="容器网络模型优势"><a href="#容器网络模型优势" class="headerlink" title="容器网络模型优势"></a>容器网络模型优势</h4><p>首先，与Docker Links进行简单对比，Docker Links允许容器之间互相发现，并使用容器名作为别名进行互相之间的通信，比DNS或服务发现更容易使用，且不用关心端口映射，但Docker Links有一些限制，比如:</p>
<ul>
<li>只能在同一宿主机内使用，不能跨主机</li>
<li>重新创建容器会移除之前的链接(Links)</li>
<li>被链接的容器必须是一个已经启动的容器</li>
</ul>
<p>因此，在Docker 1.9版本之后，官方推荐使用Docker网络功能代替Docker Links。Docker容器网络模型的主要优势在于:</p>
<ul>
<li>在某个特定网络下的所有容器能自由地相互通信</li>
<li>多个网络有助于分散容器之间的流量传输</li>
<li>多个端点允许一个容器加入到多个网络中</li>
<li>能够支持同主机和跨主机的容器间通信</li>
</ul>
<h4 id="桥接网络与重叠网络"><a href="#桥接网络与重叠网络" class="headerlink" title="桥接网络与重叠网络"></a>桥接网络与重叠网络</h4><p>桥接网络(Bridge Network)，在同一宿主机上的多个容器可以连接到同一桥接网络来实现彼此网络通信，之前提到了Docker默认的虚拟网桥为<code>docker0</code>，当然也可以创建自定义的网络生成新的虚拟网桥，而将容器连接到的该虚拟网桥上形成的网络称为桥接网络。在运行容器时可指定<code>--net=bridge</code>使用桥接模式，将容器桥接到宿主机的虚拟网桥上，从虚拟网桥的空闲网段中划分出一个子网私有IP分配给该容器。</p>
<p>重叠网络(Overly Network，也有的译成叠加或覆盖网络)，在物理网络之上，通过软件定义网络(Software Defined Network, SDN) 创建虚拟网络抽象，使得应用之间在逻辑上彼此隔离，但共享相同的底层物理网络，同时简化网络管理。</p>
<blockquote>
<p>Overlay networking is a method of using software to create layers of network abstraction that can be used to run multiple separate, discrete virtualized network layers on top of the physical network, often providing new applications or security benefits.</p>
</blockquote>
<p><img src="/assets/docker-network/overlay_network.png" alt="图片来自网络"></p>
<p>更通俗地讲，重叠网是一种运行于一个或多个已存在的网络之上的虚拟网络，即在IPv4底层网络的基础上通过节点之间单播机制将主机两两相连，形成一个虚拟、独立的具有星形和环形拓扑的虚拟网络，就好像在原有的网络上叠加了一层新的网络，以提供特定的附加功能。</p>
<p>重叠网技术的基本思路是在互联网承载层和应用层之间增加一个中间层，结合IP承载网技术，为上层业务和应用提供有针对性的服务，对已有的应用和业务进行适当控制，是对现有互联网体系架构的系统性修补。在<em>软件定义网络</em>领域中，重叠网络的实现大多采用隧道(Tunneling)技术实现，它可以基于现行的IP网络进行叠加部署，消除传统二层网络的限制，如<a href="https://en.wikipedia.org/wiki/Virtual_Extensible_LAN" target="_blank" rel="external">VXLAN</a>、<a href="http://www.sdnlab.com/11819.html" target="_blank" rel="external">NVGRE</a>等，都是基于隧道原理实现网络通信，利用叠加在三层网络之上的虚拟网络传递二层数据包，实现了可以跨越三层物理网络进行通信的二层逻辑网络，突破了传统二层网络中存在的物理位置受限、VLAN数量有限等障碍，大幅度降低管理成本和运营风险。</p>
<p>在Docker 1.9之后的版本中，Docker官方集成了重叠网络的特性支持，用户可以在Swarm中使用它或者将其作为Compose工具。通过创建虚拟网络并将其连接到容器上，可实现多个主机上容器相互通信，并且能够实现不同的应用程序或者应用程序不同部分的相互隔离。而在之前的版本中，要实现跨主机的容器间网络通信，需要借助第三方网络插件的实现，可以在后面的章节中了解更多。</p>
<h2 id="Docker四种网络方式"><a href="#Docker四种网络方式" class="headerlink" title="Docker四种网络方式"></a>Docker四种网络方式</h2><p>可以在<code>docker run</code>时通过<code>--net</code>参数来指定容器的网络配置，有4种可选值：<code>bridge</code>, <code>host</code>, <code>container:NAME_or_ID</code>, <code>none</code>。</p>
<h4 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h4><p>使用<code>--net=bridge</code>指定，为默认模式，连接到默认的网桥<code>docker0</code>，此模式会为每个容器分配一个独立的网络命名空间，使用该设置可以看到在容器中创建了<code>eth0</code>。<br>详细举个例子，假如需要创建自定义的网络，命名为<code>web</code>，系统会为其分配一个以<code>br-</code>开头的网桥名，如<code>br-2e9f4f21f001</code>，当指定<code>--net=web</code>时，即连接到对应的网桥上。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">$ docker network create web  <span class="comment"># 默认参数-d, --driver=bridge</span></div><div class="line">2e9f4f21f001fb679b657a9ef020efdd3843d51f7af24a2438114dbcfdd8fce8</div><div class="line"></div><div class="line">$ docker network ls  <span class="comment"># NAME列即为--net参数可选值，DRIVER列为网卡驱动类型</span></div><div class="line">NETWORK ID          NAME                DRIVER</div><div class="line">100cae621cad        bridge              bridge</div><div class="line">2e9f4f21f001        web                 bridge</div><div class="line">a14b172c4c88        none                null</div><div class="line">314ed40a56b6        host                host</div><div class="line"></div><div class="line">$ ip addr  <span class="comment"># 为网桥br-2e9f4f21f001分配的子网段是172.18.0.1/16</span></div><div class="line">...</div><div class="line">17: br-2e9f4f21f001: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</div><div class="line">    link/ether 02:42:72:60:5c:14 brd ff:ff:ff:ff:ff:ff</div><div class="line">    inet 172.18.0.1/16 scope global br-2e9f4f21f001</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">    inet6 fe80::42:72ff:fe60:5c14/64 scope link</div><div class="line">       valid_lft forever preferred_lft forever</div><div class="line">...</div><div class="line"></div><div class="line">$ ethtool -i br-2e9f4f21f001  <span class="comment"># 查看网桥br-2e9f4f21f001的网卡驱动类型</span></div><div class="line">driver: bridge</div><div class="line">version: 2.3</div><div class="line">...</div><div class="line"></div><div class="line">$ modinfo bridge  <span class="comment"># 查看网卡驱动bridge的详细信息</span></div><div class="line">filename:       /lib/modules/3.19.0-32-generic/kernel/net/bridge/bridge.ko</div><div class="line">version:        2.3</div><div class="line">...</div><div class="line"></div><div class="line">$ docker run -itd --net=web --name web_container busybox</div><div class="line">16835c9b647f4e40fb35bfc406e7676280a997d540be2e4a2af5ee6b32a1a10a</div><div class="line"></div><div class="line">$ brctl show  <span class="comment"># 运行容器后可看到已动态创建并关联了接口veth52ab366</span></div><div class="line">bridge name	bridge id		STP enabled	interfaces</div><div class="line">br-2e9f4f21f001	8000.024272605c14	no		veth52ab366</div><div class="line">...</div><div class="line"></div><div class="line">$ brctl showstp br-2e9f4f21f001  <span class="comment"># 也可进一步查看该网桥的生成树状态</span></div><div class="line">...</div><div class="line"></div><div class="line">$ docker network inspect web  <span class="comment"># 可以看到刚创建的容器已关联并分配了IP</span></div><div class="line">[</div><div class="line">  &#123;</div><div class="line">    <span class="string">"Name"</span>: <span class="string">"web"</span>,</div><div class="line">    <span class="string">"Id"</span>: <span class="string">"2e9f4f21f001fb679b657a9ef020efdd3843d51f7af24a2438114dbcfdd8fce8"</span>,</div><div class="line">    <span class="string">"Scope"</span>: <span class="string">"local"</span>,</div><div class="line">    <span class="string">"Driver"</span>: <span class="string">"bridge"</span>,</div><div class="line">    <span class="string">"IPAM"</span>: &#123;</div><div class="line">      <span class="string">"Driver"</span>: <span class="string">"default"</span>,</div><div class="line">      <span class="string">"Config"</span>: [&#123;&#125;]</div><div class="line">    &#125;,</div><div class="line">    <span class="string">"Containers"</span>: &#123;</div><div class="line">      <span class="string">"16835c9b647f4e40fb35bfc406e7676280a997d540be2e4a2af5ee6b32a1a10a"</span>: &#123;</div><div class="line">        <span class="string">"EndpointID"</span>: <span class="string">"878bd0f230a44d5bcddc08f04a659118005cca25e629049f10a87174175ffeb1"</span>,</div><div class="line">        <span class="string">"MacAddress"</span>: <span class="string">"02:42:ac:12:00:02"</span>,</div><div class="line">        <span class="string">"IPv4Address"</span>: <span class="string">"172.18.0.2/16"</span>,</div><div class="line">        <span class="string">"IPv6Address"</span>: <span class="string">""</span></div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">"Options"</span>: &#123;&#125;</div><div class="line">  &#125;</div><div class="line">]</div><div class="line"></div><div class="line">$ docker inspect 16835c9b647f  <span class="comment"># 可进一步查看容器web_container更底层的详细信息</span></div><div class="line">...</div></pre></td></tr></table></figure>
<h4 id="host模式"><a href="#host模式" class="headerlink" title="host模式"></a>host模式</h4><p>使用<code>--net=host</code>指定，Docker使用的网络和宿主机的一样，该方式创建出来的容器，可以看到主机上所有的网络设备，容器中对这些设备有全部的访问权限。<br>容器进程可以与主机其它root进程一样，能打开低范围的端口，可以访问本地网络服务，如 <a href="https://dbus.freedesktop.org/doc/dbus-tutorial.html" target="_blank" rel="external">D-Bus</a>，还可以让容器做一些影响整个主机系统的事情，比如重启主机。<br>因此，使用这个选项的时候要非常小心，在非隔离的环境中使用<code>host模式</code>是不安全的，如果进一步的使用<code>--privileged=true</code>，容器可以直接配置主机的网络堆栈。</p>
<h4 id="container模式"><a href="#container模式" class="headerlink" title="container模式"></a>container模式</h4><p>使用<code>--net=container:CONTAINER_ID/CONTAINER_NAME</code>指定，多个容器使用共同的网络，即两者的网络完全相同。<br>将新建容器的进程放到一个已存在容器的网络栈中，新容器进程有自己的文件系统、进程列表和资源限制，但会和已存在的容器共享IP地址和端口等网络资源，两者进程可以直接通过 <a href="http://www.omnisecu.com/cisco-certified-network-associate-ccna/what-is-loopback-interface-in-a-router.php" target="_blank" rel="external">环回接口</a> 通信。</p>
<h4 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h4><p>使用<code>--net=none</code>指定，这种模式下，将新容器放到隔离的网络栈中，但是不进行网络配置，实际上 <a href="https://wiki.openstack.org/wiki/Docker" target="_blank" rel="external">nova-docker</a> 用的就是这种方式，这种方式将网络配置的责任完全交给用户，可以实现更加灵活复杂的网络。</p>
<h2 id="Docker网络端口映射"><a href="#Docker网络端口映射" class="headerlink" title="Docker网络端口映射"></a>Docker网络端口映射</h2><p>通常来说，容器是用来服务的，这就需要让外部网络能够访问容器，默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。虽然容器本身是有IP地址和端口，但非本地主机是访问不到的，另外，这些IP在容器每次启动时都可能会改变。</p>
<p>Docker给容器内部服务的访问提供了一个简单而可靠的方法，即通过端口绑定主机系统的接口，允许非本地客户端访问容器内部运行的服务，映射容器端口到宿主机的原理是通过在本地的<code>iptables</code>的NAT表中添加相应的规则实现的，可以通过命令<code>sudo iptables -t nat -nL</code>查看，具体可以参阅 <a href="https://yeasy.gitbooks.io/docker_practice/content/advanced_network/port_mapping.html" target="_blank" rel="external">端口映射实现</a> 了解更多细节。</p>
<h3 id="自动映射端口"><a href="#自动映射端口" class="headerlink" title="自动映射端口"></a>自动映射端口</h3><p>使用<code>-P</code>参数(大写)，Docker会自动绑定所有对外提供服务的容器端口，映射的主机端口将会从没有使用的端口池中自动选择。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker run -d -P --name review registry:5000/review</div><div class="line">$ docker ps -l</div><div class="line">CONTAINER ID	...	PORTS			NAMES</div><div class="line">049e50062368	...	0.0.0.0:32774-&gt;8082/tcp	review</div></pre></td></tr></table></figure></p>
<p>若指定<code>--expose</code>选项，表示指定需要对外提供服务的端口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker run -d -P --expose 22 --name server ubuntu:14.04</div><div class="line">$ docker ps -l</div><div class="line">CONTAINER ID	...	PORTS			NAMES</div><div class="line">9a5964ec55d0	...	0.0.0.0:32779-&gt;22/tcp	server</div></pre></td></tr></table></figure></p>
<h4 id="指定映射端口"><a href="#指定映射端口" class="headerlink" title="指定映射端口"></a>指定映射端口</h4><p>使用<code>-p</code>参数(小写)，可以指定要映射的端口，但需要注意的是，在端口映射时应避免主机端口冲突，比如主机的8080端口已经被占用了，那么再映射到该端口就会冲突，即在一个指定端口上只可以绑定一个容器。支持的格式有:</p>
<ul>
<li><p><code>[HOST_PORT:]CONTAINER_PORT</code><br>映射所有接口地址，可以指定单组端口映射，比如<code>-p 5678:8082</code>，也可以指定端口映射范围，比如<code>-p 5678-5679:8082-8083</code>，主机的端口范围和容器的端口范围必须有效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker run -d -p 8082 --name review_0 registry:5000/review</div><div class="line">$ docker run -d -p 8082:8082 --name review_1 registry:5000/review</div><div class="line">$ docker run -d -p 8182-8183:8082-8083 --name review_2 registry:5000/review</div></pre></td></tr></table></figure>
<p>此时，默认会绑定本地所有接口上的所有地址，即监听所有网络接口。另外，<code>-p</code>可以多次使用来绑定多个端口:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -d -p 8382:8082 -p 8383:8083 --name review registry:5000/review</div></pre></td></tr></table></figure>
</li>
<li><p><code>IP:HOST_PORT:CONTAINER_PORT</code><br>映射到指定地址的指定端口，比如这里指定映射使用一个特定地址为localhost地址127.0.0.1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -d -p 127.0.0.1:8282:8082 --name review_3 registry:5000/review</div></pre></td></tr></table></figure>
</li>
<li><p><code>IP::CONTAINER_PORT</code><br>映射到指定地址的任意端口，比如这里绑定localhost的任意端口到容器的8082端口，本地主机会自动分配一个端口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -d -p 127.0.0.1::8082 --name rewew_4 registry:5000/review</div></pre></td></tr></table></figure>
<p>还可以使用<code>udp</code>标记来指定<code>udp</code>端口:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -d -p 127.0.0.1::8082/udp --name review_5 registry:5000/review</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="查看端口配置"><a href="#查看端口配置" class="headerlink" title="查看端口配置"></a>查看端口配置</h4><p>可以通过<code>docker ps</code>、<code>docker inspect &lt;CONTAINER&gt;</code>或<code>docker port &lt;CONTAINER&gt; [PORT]</code>查看具体的绑定端口和IP等信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ docker port review_2  <span class="comment"># 格式为 [container_port] -&gt; [host_ip]:[host_port]</span></div><div class="line">8082/tcp -&gt; 0.0.0.0:8182</div><div class="line">8083/tcp -&gt; 0.0.0.0:8183</div><div class="line"></div><div class="line">$ docker port review_2 8082</div><div class="line">0.0.0.0:8182</div><div class="line"></div><div class="line">$ docker inspect --format &#123;&#123;.NetworkSettings.IPAddress&#125;&#125; review_2</div><div class="line">172.17.0.7</div><div class="line"></div><div class="line">$ ping 172.17.0.7 -c 3</div><div class="line">PING 172.17.0.7 (172.17.0.7) 56(84) bytes of data.</div><div class="line">64 bytes from 172.17.0.7: icmp_seq=1 ttl=64 time=0.045 ms</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>其中，映射的<code>0.0.0.0</code>表示将接受主机来自所有接口的流量，同时，可通过上节中提到的参数指定允许访问容器的主机上的IP、端口等，以制定更严格的规则。如果希望永久绑定到某个固定的IP地址，可以在Docker配置文件<code>/etc/default/docker</code>中指定<code>DOCKER_OPTS=&quot;--ip=IP_ADDRESS&quot;</code>，之后重启Docker服务即可生效。</p>
<h2 id="Docker软件定义网络"><a href="#Docker软件定义网络" class="headerlink" title="Docker软件定义网络"></a>Docker软件定义网络</h2><h4 id="什么是软件定义网络？"><a href="#什么是软件定义网络？" class="headerlink" title="什么是软件定义网络？"></a>什么是软件定义网络？</h4><p>软件定义网络(Software-Defined Networking, SDN)，是由 <a href="https://en.wikipedia.org/wiki/Emulex" target="_blank" rel="external">Emulex</a> 提出的一种新型网络创新架构，其核心技术 <a href="https://www.opennetworking.org/sdn-resources/openflow" target="_blank" rel="external">OpenFlow</a> 协议通过将网络设备控制平面与数据平面分离开来，从而实现了网络流量的灵活控制，为核心网络及应用的创新提供了良好的平台。</p>
<blockquote>
<p>The physical separation of the network control plane from the forwarding plane, and where a control plane controls several devices.<br>SDN is an emerging architecture that is dynamic, manageable, cost-effective, and adaptable, making it ideal for the high-bandwidth, dynamic nature of today’s applications.</p>
</blockquote>
<p><img src="/assets/docker-network/sdn_3layers.jpg" alt="图片来自网络"></p>
<p>由于传统的网络设备(交换机、路由器)的固件是由设备制造商锁定和控制，而SDN将网络控制与物理网络拓扑分离，创建虚拟网络抽象，从而摆脱硬件对网络架构的限制，并且可对网络架构进行修改。更通俗地讲，网络管理者不直接操作底层的设备，而是通过编程的方式，通过控制器的程序去操作交换机等设备，比如设计转发和路由规则、设计新的网络协议、提供各种各样的服务、实现多个安全方案等，这样的好处在于，可以极大地增强控制层的灵活性。</p>
<p>在DOCKER 1.9之后支持了软件定义网络，增强了网络特性，允许Docker引擎创建虚拟网络，这样，具备网络功能的容器可跨越多个主机进行通信，并且容器间可无缝交流有助于实现真正的分布式应用，另外，开发者也可以更加灵活地搭建类产品环境的测试环境了。</p>
<h4 id="Docker网基本络命令"><a href="#Docker网基本络命令" class="headerlink" title="Docker网基本络命令"></a>Docker网基本络命令</h4><p>Docker的<code>network</code>命令主要包含<code>create</code>, <code>connect</code>, <code>disconnect</code>, <code>inspect</code>, <code>ls</code>, <code>prune</code>以及<code>rm</code>，可以通过输入帮助命令查看并了解更多。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ docker network --<span class="built_in">help</span></div><div class="line">Usage:	docker network [OPTIONS] COMMAND [OPTIONS]</div><div class="line"></div><div class="line">Commands:</div><div class="line">  create                   Create a network</div><div class="line">  connect                  Connect container to a network</div><div class="line">  disconnect               Disconnect container from a network</div><div class="line">  inspect                  Display detailed network information</div><div class="line">  ls                       List all networks</div><div class="line">  prune                    Remove all unused networks</div><div class="line">  rm                       Remove a network</div><div class="line"></div><div class="line">Run <span class="string">'docker network COMMAND --help'</span> <span class="keyword">for</span> more information on a <span class="built_in">command</span>.</div></pre></td></tr></table></figure></p>
<ul>
<li><p><code>create</code>用法: <code>docker network create [OPTIONS] NETWORK</code>，创建一个新的网络，可配置一些可选参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">    --attachable             Enable manual container attachment</div><div class="line">    --aux-address map        Auxiliary IPv4 or IPv6 addresses used by Network driver (default map[])</div><div class="line">-d, --driver string          Driver to manage the Network (default &quot;bridge&quot;)</div><div class="line">    --gateway stringSlice    IPv4 or IPv6 Gateway for the master subnet</div><div class="line">    --internal               Restrict external access to the network</div><div class="line">    --ip-range stringSlice   Allocate container ip from a sub-range</div><div class="line">    --ipam-driver string     IP Address Management Driver (default &quot;default&quot;)</div><div class="line">    --ipam-opt map           Set IPAM driver specific options (default map[])</div><div class="line">    --ipv6                   Enable IPv6 networking</div><div class="line">    --label list             Set metadata on a network (default [])</div><div class="line">-o, --opt map                Set driver specific options (default map[])</div><div class="line">    --subnet stringSlice     Subnet in CIDR format that represents a network segment</div></pre></td></tr></table></figure>
<p>在创建一个网络时，不指定<code>--driver</code>情况下默认会使用网络驱动<code>bridge</code>，同时创建一个<code>br-</code>开头的虚拟网桥，可以在『Docker四种网络方式』章节的『bridge模式』部分中找到相关命令查看详细信息。另外，驱动<code>host</code>和<code>null</code>都只能允许管理唯一一个实例网络.</p>
</li>
<li><p><code>connect</code>用法: <code>docker network connect [OPTIONS] NETWORK CONTAINER</code>，连接容器到某个网络中，可选参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">--alias stringSlice           Add network-scoped alias for the container</div><div class="line">--ip string                   IP Address</div><div class="line">--ip6 string                  IPv6 Address</div><div class="line">--link list                   Add link to another container (default [])</div><div class="line">--link-local-ip stringSlice   Add a link-local address for the container</div></pre></td></tr></table></figure>
</li>
<li><p><code>disconnect</code>用法: <code>docker network disconnect [OPTIONS] NETWORK CONTAINER</code>，断开容器到网络的连接，可选参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-f, --force   Force the container to disconnect from a network</div></pre></td></tr></table></figure>
</li>
<li><p><code>inspect</code>用法: <code>docker network inspect [OPTIONS] NETWORK [NETWORK...]</code>，显示在某个网络上的详细信息，可选参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-f, --format string   Format the output using the given Go template</div></pre></td></tr></table></figure>
</li>
<li><p><code>ls</code>用法: <code>docker network ls [OPTIONS]</code>，列出当前所有的网络，可选参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-f, --filter filter   Provide filter values (e.g. &apos;driver=bridge&apos;)</div><div class="line">    --format string   Pretty-print networks using a Go template</div><div class="line">    --no-trunc        Do not truncate the output</div><div class="line">-q, --quiet           Only display network IDs</div></pre></td></tr></table></figure>
</li>
<li><p><code>prune</code>用法: <code>docker network prune [OPTIONS]</code>，删除所有当前未使用的网络，可选参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-f, --force   Do not prompt for confirmation</div></pre></td></tr></table></figure>
</li>
<li><p><code>rm</code>用法: <code>docker network rm NETWORK [NETWORK...]</code>，删除指定的一个或多个网络。</p>
</li>
</ul>
<h4 id="同主机的容器网络通信"><a href="#同主机的容器网络通信" class="headerlink" title="同主机的容器网络通信"></a>同主机的容器网络通信</h4><p>通过学习了Docker的网络命令，那接下来就练习一下，在同一主机上准备创建两个网络，分别为<code>web</code>和<code>app</code>，然后分别在其中创建容器，实现<code>web</code>网络下的容器与<code>app</code>网络下的容器相互通信，从而可通过创建虚拟网络模拟出类似产品环境的网络情况。若之前已创建了同名的网络，可根据情况变更网络名称或删除。</p>
<h6 id="创建网络web并运行容器"><a href="#创建网络web并运行容器" class="headerlink" title="创建网络web并运行容器"></a>创建网络<code>web</code>并运行容器</h6><ul>
<li><p>创建网络<code>web</code>并查看当前所有网络</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker network create web</div><div class="line">$ docker network ls</div></pre></td></tr></table></figure>
</li>
<li><p>在网络<code>web</code>下创建名为<code>web_container</code>的容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -itd --net=web --name web_container busybox</div></pre></td></tr></table></figure>
</li>
<li><p>查看网络<code>web</code>下的所有容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker network inspect web</div></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="创建网络app并运行容器"><a href="#创建网络app并运行容器" class="headerlink" title="创建网络app并运行容器"></a>创建网络<code>app</code>并运行容器</h6><ul>
<li><p>创建网络<code>app</code>并查看当前所有网络</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker network create app</div><div class="line">$ docker network ls</div></pre></td></tr></table></figure>
</li>
<li><p>在网络<code>app</code>下创建名为<code>app_container</code>的容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -itd --name app_container --net=app busybox</div></pre></td></tr></table></figure>
</li>
<li><p>查看网络<code>app</code>下的所有容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker network inspect app</div></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="连接容器到网络并测试"><a href="#连接容器到网络并测试" class="headerlink" title="连接容器到网络并测试"></a>连接容器到网络并测试</h6><ul>
<li><p>通过命令实现容器<code>web_container</code>连接到网络<code>app</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker network connect app web_container</div></pre></td></tr></table></figure>
<p>这样，容器<code>web_container</code>就可以通过<code>app_container.app</code>连接到容器<code>app_container</code>。</p>
</li>
<li><p>在容器<code>web_container</code>中Ping一下<code>app_container.app</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ docker <span class="built_in">exec</span> -it web_container sh  <span class="comment"># 进入容器</span></div><div class="line"></div><div class="line">$ ping app_container.app  <span class="comment"># 在容器内执行，注意返回的IP不应是127.0.x.x</span></div><div class="line">PING app_container.app (172.19.0.2): 56 data bytes</div><div class="line">64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.434 ms</div><div class="line">...</div><div class="line"></div><div class="line">$ <span class="built_in">exit</span> <span class="comment"># 退出容器</span></div></pre></td></tr></table></figure>
</li>
<li><p>再次查看网络<code>web</code>和<code>app</code>下的所有容器，特别注意有什么变化？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker network inspect web</div><div class="line">$ docker network inspect app</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="跨主机的容器网络通信"><a href="#跨主机的容器网络通信" class="headerlink" title="跨主机的容器网络通信"></a>跨主机的容器网络通信</h4><p>在Docker 1.9版本之前，要实现跨主机的容器间网络通信，需要借助第三方网络插件的支持，网络插件在很大程度上降低不同类型主机上容器通信的难度，扩展由Docker提供的核心网络功能。</p>
<p>而在Docker 1.9之后的版本中，Docker官方集成了重叠网络的特性，即支持创建虚拟网络并将其连接到容器上，可实现多个主机上容器相互通信，并且实现不同的应用程序或者应用程序不同部分能够相互隔离，互联子系统设计为可插拔式，兼容VXLAN或者IPVLAN等技术。<br><img src="/assets/docker-network/multi_hosts_network.jpg" alt="图片来自网络"></p>
<p>目前，Docker容器实现跨主机通信主要通过以下方式：</p>
<ul>
<li>自带重叠网络(Overlay Network) 组件，结合 <a href="https://docs.docker.com/swarm/overview/" target="_blank" rel="external">Docker Swarm</a> 实现，主要原理也是通过Key-Value存储服务进行调用。</li>
<li>第三方插件，如 <a href="https://github.com/weaveworks/weave" target="_blank" rel="external">Weave</a>, <a href="https://www.projectcalico.org/docker-libnetwork-is-almost-here-and-calico-is-ready/" target="_blank" rel="external">Calico</a>, <a href="https://github.com/contiv/netplugin" target="_blank" rel="external">Contiv Netplugin</a>, <a href="https://github.com/contiv/netplugin" target="_blank" rel="external">Cisco</a>, <a href="https://docs.docker.com/machine/drivers/vsphere/" target="_blank" rel="external">VMware</a>, <a href="https://blog.midonet.org/kuryr-midonet-networking-docker-1-9/" target="_blank" rel="external">MidoNet</a>, <a href="https://github.com/jpetazzo/pipework" target="_blank" rel="external">pipework</a>, <a href="https://github.com/coreos/flannel" target="_blank" rel="external">flannel</a> 等。</li>
</ul>
<p>而这里将重点介绍自带Overlay Network组件和Docker Swarm的实现方式，首先启动一台虚拟机模拟Node1，将主机模拟为Node2。</p>
<h6 id="初始化-Docker-Swarm"><a href="#初始化-Docker-Swarm" class="headerlink" title="初始化 Docker Swarm"></a>初始化 Docker Swarm</h6><ul>
<li><p>在Node1上初始化并创建Docker Swarm，作为Manager。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ docker swarm init --advertise-addr 192.168.56.102</div><div class="line">Swarm initialized: current node (s08ktyv5yij5v7tu66t1ll2fi) is now a manager.</div><div class="line"></div><div class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</div><div class="line"></div><div class="line">    docker swarm join \</div><div class="line">    --token SWMTKN-1-68zbx1wtxgklsj36y3yjq90h6jcx2hewloku685fkvd44m9hw7-acgn20k3ary37fbd2mgtdf9t5 \</div><div class="line">    192.168.56.102:2377</div><div class="line"></div><div class="line">To add a manager to this swarm, run <span class="string">'docker swarm join-token manager'</span> and follow the instructions.</div></pre></td></tr></table></figure>
</li>
<li><p>在Node2上运行如下命令加入到Swarm中，作为Worker。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker swarm join \</div><div class="line">&gt;     --token SWMTKN-1-68zbx1wtxgklsj36y3yjq90h6jcx2hewloku685fkvd44m9hw7-acgn20k3ary37fbd2mgtdf9t5 \</div><div class="line">&gt;     192.168.56.102:2377</div><div class="line">This node joined a swarm as a worker.</div></pre></td></tr></table></figure>
<p>也可以通过命令<code>docker swarm join-token worker</code>再次查看其token和IP。</p>
</li>
<li><p>在Node1上查看当前所有Node信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker node ls</div><div class="line">ID                           HOSTNAME               STATUS  AVAILABILITY  MANAGER STATUS</div><div class="line">3r8p73yl8rkxkyiocnlxzc4wy    moby                   Ready   Active</div><div class="line">s08ktyv5yij5v7tu66t1ll2fi *  localhost.localdomain  Ready   Active        Leader</div></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="创建-Overlay-Network"><a href="#创建-Overlay-Network" class="headerlink" title="创建 Overlay Network"></a>创建 Overlay Network</h6><ul>
<li><p>在Node1上创建Overlay网络命名为<code>net_overlay</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ docker network create -d=overlay net_overlay</div><div class="line">n9n1no3w0uku2lgn5jo5czc0l</div><div class="line"></div><div class="line">$ docker network ls</div><div class="line">NETWORK ID          NAME                   DRIVER              SCOPE</div><div class="line">694d3a222895        bridge                 bridge              <span class="built_in">local</span></div><div class="line">64f31cf05fee        docker_gwbridge        bridge              <span class="built_in">local</span></div><div class="line">22b5291ac1fb        host                   host                <span class="built_in">local</span></div><div class="line">yhb42l4f7a6q        ingress                overlay             swarm</div><div class="line">n9n1no3w0uku        net_overlay            overlay             swarm</div><div class="line">b76cb60af763        none                   null                <span class="built_in">local</span></div></pre></td></tr></table></figure>
<p>这样，所有在Swarm中的主机都可以访问该网络了，除了<code>docker0</code>默认网桥外，这里多出了一个<code>docker_gwbridge</code>的网桥，<code>docker0</code>在跨多主机容器网络中并没有被用到，而是<code>docker_gwbridge</code>替代了<code>docker0</code>用来实现Overlay网络中容器间的通信以及容器到外部的通信，其职能就和单机容器网络中<code>docker0</code>一样。</p>
</li>
<li><p>查看<code>net_overlay</code>网络的配置信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$ docker network inspect net_overlay</div><div class="line">[</div><div class="line">    &#123;</div><div class="line">        <span class="string">"Name"</span>: <span class="string">"net_overlay"</span>,</div><div class="line">        <span class="string">"Id"</span>: <span class="string">"n9n1no3w0uku2lgn5jo5czc0l"</span>,</div><div class="line">        <span class="string">"Scope"</span>: <span class="string">"swarm"</span>,</div><div class="line">        <span class="string">"Driver"</span>: <span class="string">"overlay"</span>,</div><div class="line">        <span class="string">"EnableIPv6"</span>: <span class="literal">false</span>,</div><div class="line">        <span class="string">"IPAM"</span>: &#123;</div><div class="line">            <span class="string">"Driver"</span>: <span class="string">"default"</span>,</div><div class="line">            <span class="string">"Options"</span>: null,</div><div class="line">            <span class="string">"Config"</span>: [</div><div class="line">                &#123;</div><div class="line">                    <span class="string">"Subnet"</span>: <span class="string">"10.0.0.0/24"</span>,</div><div class="line">                    <span class="string">"Gateway"</span>: <span class="string">"10.0.0.1"</span></div><div class="line">                &#125;</div><div class="line">            ]</div><div class="line">        &#125;,</div><div class="line">    ...</div></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="启动服务并测试连接"><a href="#启动服务并测试连接" class="headerlink" title="启动服务并测试连接"></a>启动服务并测试连接</h6><ul>
<li><p>创建服务并启动容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ docker service create --name hello --network net_overlay --replicas 2 ubuntu sleep infinity</div><div class="line">j56ia0rkjtc39eds80rt3yh4v</div><div class="line"></div><div class="line">$ docker service ls</div><div class="line">j56ia0rkjtc3  hello  replicated  1/2       ubuntu:latest</div></pre></td></tr></table></figure>
<p>这里，创建了一个名为<code>hello</code>的服务，并绑定到<code>net_overlay</code>网络上，同时创建两个容器副本以<code>sleep infinity</code>的命令运行，该命令使得容器不会立即退出，两个容器分别会运行在两个节点为上。</p>
</li>
<li><p>查看容器运行状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker service ps hello</div><div class="line">4fla3n6yogkk  hello.1  ubuntu:latest  localhost.localdomain  Running</div><div class="line">p4adrd04a94y  hello.2  ubuntu:latest  moby                   Running</div></pre></td></tr></table></figure>
</li>
</ul>
<p>然后使用<code>docker ps</code>命令分别在Node1和Node2上查看容器信息获得容器ID，再通过<code>inspect</code>命令分别查看两个节点上的容器IP地址，使用<code>exec</code>命令登录到其中任意一个节点的容器内，使用<code>ping</code>或<code>traceroute</code>命令测试是否能连接到另一个节点上的容器，如果没有<code>ping</code>命令可以执行命令<code>apt-get update; apt-get install iputils-ping -y</code>安装即可。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>主要介绍了Docker网络相关的内容，包括Docker的网络实现原理、容器网络模型组件与优势、桥接网络与重叠网络的概念、Docker的四种网络方式、Docker网络端口映射、软件定义网络概念等，同时还练习了Docker网络基本命令，配置了同主机的容器虚拟网络，以及搭建了跨主机的容器虚拟网络。在整体和细节上都对Docker网络有了一个更清晰的认识，同时也对Docker网络相关命令更加熟练，能够配置同主机上的容器网络，并且也能够搭建跨主机的容器网络环境。</p>
<hr>
<p>References</p>
<ul>
<li><a href="https://docs.docker.com/engine/userguide/networking/" target="_blank" rel="external">Docker networking</a></li>
<li><a href="https://docs.docker.com/engine/userguide/networking/#user-defined-networks" target="_blank" rel="external">Docker container networking</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/underly/network.html" target="_blank" rel="external">Docker 网络实现</a></li>
<li><a href="https://www.sdxcentral.com/sdn/definitions/what-is-overlay-networking/" target="_blank" rel="external">What is Overlay Networking?</a></li>
<li><a href="https://docs.docker.com/engine/userguide/networking/work-with-networks/" target="_blank" rel="external">Work with network commands</a></li>
<li><a href="http://www.docker.org.cn/dockerppt/111.html" target="_blank" rel="external">Docker学习笔记：Docker 网络配置</a></li>
<li><a href="https://www.opennetworking.org/sdn-resources/sdn-definition" target="_blank" rel="external">Software-Defined Networking Definition</a></li>
<li><a href="http://tonybai.com/2016/02/15/understanding-docker-multi-host-networking/" target="_blank" rel="external">理解Docker跨多主机容器网络</a></li>
<li><a href="https://docs.docker.com/engine/userguide/networking/get-started-overlay/" target="_blank" rel="external">Get started with multi-host networking</a></li>
<li><a href="http://blog.nigelpoulton.com/demystifying-docker-overlay-networking/" target="_blank" rel="external">Demystifying Docker overlay networking</a></li>
<li><a href="http://www.dockone.io/article/840" target="_blank" rel="external">Docker 1.9 Overlay Network实现跨主机网络互通</a></li>
<li><a href="https://docs.docker.com/engine/swarm/swarm-mode/" target="_blank" rel="external">Run Docker Engine in swarm mode</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      Docker中的网络接口默认都是虚拟接口，Docker的网络利用了Linux上的网络命名空间和虚拟网络设备实现的，特别是veth pair，它在宿主机和容器内分别创建虚拟接口，并让它们彼此连通。
    
    </summary>
    
      <category term="Platforms" scheme="https://blog.waterstrong.me/categories/Platforms/"/>
    
    
      <category term="Docker" scheme="https://blog.waterstrong.me/tags/Docker/"/>
    
      <category term="容器" scheme="https://blog.waterstrong.me/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Network" scheme="https://blog.waterstrong.me/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>再见多说，你好云跟帖</title>
    <link href="https://blog.waterstrong.me/duoshuo-away/"/>
    <id>https://blog.waterstrong.me/duoshuo-away/</id>
    <published>2017-03-24T10:58:54.000Z</published>
    <updated>2017-03-26T13:49:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多说即将关闭"><a href="#多说即将关闭" class="headerlink" title="多说即将关闭"></a>多说即将关闭</h2><div class="figure left fig-50" style="width:;"><a class="fancybox" href="/assets/duoshuo-away/duoshuo_post.png" title="" data-fancybox-group=""><img class="fig-img" src="/assets/duoshuo-away/duoshuo_post.png" alt=""></a></div>
<p>在多说网本月21号发布关闭多说项目前几天，当时一直在修改主题源码升级博客功能，就一直遇到多说评论框加载失败的情况，一开始以为自己修改的代码影响到了多说的加载，后来一查发现原来是多说系统近期不稳定导致的，本来有时多说加载是相对比较慢，有时会出现问题，但也不至于系统那么不稳定，定是发生了什么事情，果不其然，随后在3月21号，多说网发表声明称<strong>因公司业务调整将在2017年6月1日正式关停多说服务</strong>，以下是通知的原文截图。<br><img src="/assets/duoshuo-away/duoshuo_notice.png" alt="多说即将关闭通知"></p>
<p>随后，在各集成有多说的网站与博客的多说评论框上也醒目地显示了多说项目即将关闭的文字提示，相信大家也都看到了。<br><img src="/assets/duoshuo-away/duoshuo.png" alt="多说即将关闭提示"></p>
<p>多说是一款让评论更活跃、互动性更强的评论系统，官网宣传的永久免费且容易安装，可以用微博、QQ、人人、豆瓣等帐号轻松评论和分享，能够智能识别垃圾评论、稳步提升网站流量。在国内，多说确实算得上是评论老大哥的地位，虽然自己之前也没有用过其他的国内评论系统，但多说使用起来还是挺不错的，而且在周围的朋友中，除了Disqus就是多说了，用户基数还是很乐观的，但正是由于其宣传的永久免费，就目前来说，没有很好的变现方法，可能是资金流遇到困难，或者已经并入到其他项目，也或许该项目只是对市场的试验，反正最后是要关闭了。作为使用评论系统的朋友，需要开始导出数据，寻找替代方案了。</p>
<h2 id="我的替代方案"><a href="#我的替代方案" class="headerlink" title="我的替代方案"></a>我的替代方案</h2><p>当时我的反应就是，该切换回<a href="https://disqus.com/" target="_blank" rel="external">Disqus</a>了，因为就评论系统而言，Disqus各方面绝对是没话说，在国外很流行的，但就是这么一个评论系统被墙了，用户体验直线下降了，我也是对GFW没话说了，不想再吐槽了。<br>其实，刚开始搭博客时，也是用Disqus作为评论系统，但最后还是决定使用国内流行的多说，毕竟在国内嘛，还是要考虑那些没有梯子的朋友，另外，Disqus并不支持集成国内一些主流社会网络的登录方式，但如果它没有被墙的话，那毫不犹豫是首选的。<br><img src="/assets/duoshuo-away/disqus.png" alt="Disqus评论框"></p>
<p>那么问题来了，还有没有其他的国内替代方案呢？当时的想法就是，如果没有合适的国内替代方案就还是就用Disqus了，但在调查后发现了新出来的<a href="https://gentie.163.com/" target="_blank" rel="external">网易云跟帖</a>，然后到官网看了一下，简单集成到自己的博客，看起来还不错的样子，虽然目前是在Beta版本，后台管理功能也不是太完善，那就先试用一段时间吧，如果国内的评论系统确实做不起来，那就再来换Disqus了。<br><img src="/assets/duoshuo-away/yungentie0.png" alt="云跟帖评论框"></p>
<p>最重要的，需要在后台将导出的多说评论(包含文章数据、包含评论数据)再导入到云跟帖中，完成数据的迁移，不过数据很有可能会出现一些问题，比如作者昵称转换成默认值、评论文章ID丢失导致无法加载评论等，只能说云跟帖的数据迁移功能有待完善。</p>
<h2 id="附录：在Hexo中集成云跟帖"><a href="#附录：在Hexo中集成云跟帖" class="headerlink" title="附录：在Hexo中集成云跟帖"></a>附录：在Hexo中集成云跟帖</h2><p>由于每个主题代码结构稍有不同，文件位置可能是不同的，并不适用其他主题的，但源代码和思路是一致的，这里只是记录一下，仅供参考。</p>
<ol>
<li><p>在<code>/layout/_partial/post</code>下新建一个文件命名为<code>yungentie.ejs</code>。</p>
<figure class="highlight html"><figcaption><span>yungentie.ejs</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"cloud-tie-wrapper"</span> <span class="attr">class</span>=<span class="string">"cloud-tie-wrapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>在<code>/layout/_partial</code>下找到加载刚新建的<code>yungentie.ejs</code>的<code>post.ejs</code>文件，并在duoshuo记录后添加逻辑分支:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;% &#125; <span class="keyword">else</span> <span class="keyword">if</span> (theme.yungentie_app_key) &#123; %&gt;</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">post</span>/<span class="attr">yungentie</span>') %&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>在<code>/layout/_partial</code>下找到有关于评论系统逻辑代码的<code>scripts.ejs</code>文件，在duoshuo记录后新加逻辑分支:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;% &#125; <span class="keyword">else</span> <span class="keyword">if</span> (theme.yungentie_app_key) &#123; %&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></span></div><div class="line">    <span class="keyword">var</span> cloudTieConfig = &#123;</div><div class="line">        <span class="attr">url</span>: <span class="built_in">document</span>.location.href,</div><div class="line">        <span class="attr">sourceId</span>: <span class="string">'&lt;%= post.path %&gt;'</span>,</div><div class="line">        <span class="attr">productKey</span>: <span class="string">'&lt;%= theme.yungentie_app_key %&gt;'</span>,</div><div class="line">        <span class="attr">target</span>: <span class="string">'cloud-tie-wrapper'</span></div><div class="line">    &#125;;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">&lt;script src=<span class="string">"https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>在<code>_config.yml</code>文件中找到原来duoshuo的位置添加一条记录，同时要禁用其它评论系统，这里的<code>yungentie_app_key</code>值是唯一需要变化的地方。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Your Yungentie shortname</span></div><div class="line"><span class="attr">yungentie_app_key:</span> <span class="string">&lt;your_app_key&gt;</span> <span class="comment"># 可以在云跟帖后台管理的获取代码中查到</span></div></pre></td></tr></table></figure>
</li>
<li><p>(可选)由于后台目前还不支持自定义的CSS样式，可以选择在<code>/source/_css/layouts/</code>中新加一个文件命名为<code>_yungentie.scss</code>，可以写自定义的样式，同时在入口SCSS文件处引入新建文件，即<code>@import &#39;layouts/yungentie&#39;</code>。<br><img src="/assets/duoshuo-away/yungentie1.png" alt=""></p>
</li>
</ol>
<hr>
]]></content>
    
    <summary type="html">
    
      多说网在3月21号发表声明称因公司业务调整将在2017年6月1日正式关停多说服务，作为使用评论系统的朋友，需要开始导出数据，除了选择Disqus，是否有国内评论系统替代方案呢？
    
    </summary>
    
      <category term="Platforms" scheme="https://blog.waterstrong.me/categories/Platforms/"/>
    
    
      <category term="Disqus" scheme="https://blog.waterstrong.me/tags/Disqus/"/>
    
      <category term="多说" scheme="https://blog.waterstrong.me/tags/%E5%A4%9A%E8%AF%B4/"/>
    
      <category term="评论" scheme="https://blog.waterstrong.me/tags/%E8%AF%84%E8%AE%BA/"/>
    
      <category term="云跟帖" scheme="https://blog.waterstrong.me/tags/%E4%BA%91%E8%B7%9F%E5%B8%96/"/>
    
  </entry>
  
  <entry>
    <title>JSX语法介绍与使用</title>
    <link href="https://blog.waterstrong.me/jsx-syntax/"/>
    <id>https://blog.waterstrong.me/jsx-syntax/</id>
    <published>2017-03-21T05:04:06.000Z</published>
    <updated>2017-03-26T06:28:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是JSX？"><a href="#什么是JSX？" class="headerlink" title="什么是JSX？"></a>什么是JSX？</h2><blockquote>
<p>JSX is an embeddable XML-like syntax extension to JavaScript without any defined semantics.</p>
</blockquote>
<p><code>JSX</code>是一种类<code>XML</code>语言，是<code>JavaScript</code>的语法扩展，全称是<code>JavaScript XML</code>。<code>JSX</code>并不是由引擎或浏览器来实现，也并不打算并入到<code>ECMAScript</code>标准规范中，它旨在被各种预处理器转换成标准的<code>ECMAScript</code>语法。正如前面所说，<code>JSX</code>就像<code>XML</code>一样，它定义有自己的标签名、属性、子元素，需要注意的是，如果属性的值在<em>大括号</em>内，会当作<code>JavaScript</code>表达式处理，如果在<em>引号</em>内，则会当作字符串类型(String)处理。<br>首先，看一个简单的示例，使用<code>JSX</code>来表示一个UI下拉选项框组件：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> dropdown =</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Dropdown</span>&gt;</span></span></div><div class="line">    A dropdown list</div><div class="line">    <span class="tag">&lt;<span class="name">Menu</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">MenuItem</span>&gt;</span>Do Something<span class="tag">&lt;/<span class="name">MenuItem</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">MenuItem</span>&gt;</span>Do Something Fun!<span class="tag">&lt;/<span class="name">MenuItem</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">MenuItem</span>&gt;</span>Do Something Else<span class="tag">&lt;/<span class="name">MenuItem</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">Menu</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">Dropdown</span>&gt;</span>;</div><div class="line"></div><div class="line">render(dropdown);</div></pre></td></tr></table></figure></p>
<h2 id="为什么要学习JSX？"><a href="#为什么要学习JSX？" class="headerlink" title="为什么要学习JSX？"></a>为什么要学习JSX？</h2><p>由于最近在学习 <a href="https://facebook.github.io/react/" target="_blank" rel="external">React</a>，而官方是推荐使用<code>JSX</code>来编写其组件，从技术角度来说，<code>React</code>可以不使用<code>JSX</code>来编写组件，但是使用<code>JSX</code>可以让代码可读性更高、语义更清晰、对<code>React</code>元素进行抽象。基于此，结合对<code>React</code>的学习需求，还是很有必要先学习并掌握<code>JSX</code>的使用，并且学习成本也相对较低，只要了解其语法规则就可以使用了。</p>
<h2 id="JSX的语法规范"><a href="#JSX的语法规范" class="headerlink" title="JSX的语法规范"></a>JSX的语法规范</h2><h4 id="JSX标签"><a href="#JSX标签" class="headerlink" title="JSX标签"></a>JSX标签</h4><ul>
<li><p>自闭合标签<br>如果标签没有子元素，可以使用自闭合标签：<em>&lt; JSXElementName JSXAttributes<sub>opt</sub> / &gt;</em></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"sidebar"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">MyCounter</span> <span class="attr">color</span>=<span class="string">"blue"</span> <span class="attr">count</span>=<span class="string">'&#123;3 + 5&#125;'</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Scoreboard</span> <span class="attr">className</span>=<span class="string">"results"</span> <span class="attr">scores</span>=<span class="string">&#123;gameScores&#125;</span> /&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>开/闭标签<br>也可以写成开/闭标签的形式：<em>&lt; JSXElementName JSXAttributes<sub>opt</sub> &gt; &lt;/ JSXElementName &gt;</em></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element1 = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">"red"</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div><div class="line"><span class="keyword">const</span> element2 = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span>;</div><div class="line"><span class="keyword">const</span> element3 = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">tabIndex</span>=<span class="string">"0"</span>&gt;</span>&#123;user.title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div></pre></td></tr></table></figure>
<p>  如果属性的值在<em>引号</em>内，会当作字符串类型(String)处理，如果属性值是在<em>大括号</em>内，则会当作<code>JavaScript</code>表达式处理。</p>
</li>
</ul>
<h4 id="JSX元素名"><a href="#JSX元素名" class="headerlink" title="JSX元素名"></a>JSX元素名</h4><p><code>JSX</code>的元素名可是一个标识符、命名空间和成员表达式：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// JSXIdentifier</div><div class="line"><span class="tag">&lt;<span class="name">FormInput</span>&gt;</span><span class="tag">&lt;/<span class="name">FormInput</span>&gt;</span></div><div class="line">//JSXIdentifier.JSXIdentifier</div><div class="line"><span class="tag">&lt;<span class="name">MyComponents.DatePicker</span> <span class="attr">color</span>=<span class="string">"blue"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="JSX属性"><a href="#JSX属性" class="headerlink" title="JSX属性"></a>JSX属性</h4><p><code>JSX</code>属性有一般属性、展开属性：<em>JSXAttribute JSXAttributes<sub>opt</sub></em> 、<em>{ … AssignmentExpression }</em> 。<br>属性的值可以用双引号(<code>&quot;string&quot;</code>)、单引号(<code>&#39;string&#39;</code>)和大括号(<code>{expression}</code>)，需要注意的是，如果属性值使用了单/双引号，该字符串值内部就不能再出现相对应的引号了。</p>
<h4 id="JSX子元素"><a href="#JSX子元素" class="headerlink" title="JSX子元素"></a>JSX子元素</h4><ul>
<li><p>String字面值(String Literals)<br>可以直接写字符串类型或HTML格式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">MyComponent</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>This is valid HTML &amp;amp; JSX at the same time.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>JSX子组件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">MyContainer</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">MyFirstComponent</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">MySecondComponent</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">MyContainer</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>JavaScript表达式<br>比如稍微复杂一点的表达式，包括一些取值、方法调用和类型转换的场景：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    &#123;todos.map((message) =&gt; <span class="tag">&lt;<span class="name">Item</span> <span class="attr">key</span>=<span class="string">&#123;message&#125;</span> <span class="attr">message</span>=<span class="string">&#123;message&#125;</span> /&gt;</span>)&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">Repeat</span> <span class="attr">numTimes</span>=<span class="string">&#123;10&#125;</span>&gt;</span></div><div class="line">    &#123;(index) =&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>This is item &#123;index&#125; in the list<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">Repeat</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    Hello &#123;props.addressee&#125;!</div><div class="line">    My JavaScript variable is &#123;String(myVariable)&#125;.</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="在React中使用JSX"><a href="#在React中使用JSX" class="headerlink" title="在React中使用JSX"></a>在React中使用JSX</h2><h4 id="JSX命名规则"><a href="#JSX命名规则" class="headerlink" title="JSX命名规则"></a>JSX命名规则</h4><p>在使用<code>JSX</code>编写<code>React</code>时，针对<code>HTML</code>标签，保留原来的关键字和命名规则，即全部字母小写，而对于自定义的组件(Component)，需要遵循首字母大写的约定。由于<code>JSX</code>相对于<code>HTML</code>更接近于<code>JavaScript</code>，对于所有的<strong>DOM属性及事件处理器</strong>，都应该使用camelCased(骆峰命名)与标准的<code>JavaScript</code>风格保持一致，如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// HTML tag</div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> props.onClick()&#125;&gt;Click &#123;props.toWhat&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">// React Component</div><div class="line"><span class="tag">&lt;<span class="name">Hello</span> <span class="attr">toWhat</span>=<span class="string">"Me"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>因为<code>class</code>和<code>for</code>是<code>JavaScript</code>的保留字，内建 <a href="http://javascript.info/dom-nodes" target="_blank" rel="external">DOM nodes</a> 的<code>JSX</code>元素应该分别使用属性名<code>className</code>和<code>htmlFor</code>，另外，如<code>tabindex</code>也应写成<code>tabIndex</code>。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"foo"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>而自定义的<code>JSX</code>元素可以直接使用<code>class</code>和<code>for</code>。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">my-tag</span> <span class="attr">class</span>=<span class="string">"foo"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="JSX命名空间组件"><a href="#JSX命名空间组件" class="headerlink" title="JSX命名空间组件"></a>JSX命名空间组件</h4><p>如果你正在构建一个有很多子组件的组件，比如表单，你也许会最终得到许多的变量声明，比如以下不太友好的代码块。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Form = MyFormComponent;</div><div class="line"><span class="keyword">var</span> FormRow = Form.Row;</div><div class="line"><span class="keyword">var</span> FormLabel = Form.Label;</div><div class="line"><span class="keyword">var</span> FormInput = Form.Input;</div><div class="line"></div><div class="line"><span class="keyword">var</span> App = (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Form</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">FormRow</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">FormLabel</span> /&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">FormInput</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">FormRow</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>为了使其更简单和容易，命名空间组件令你使用包含其他组件作为属性的单一的组件，通过使用点符号<code>.</code>很方便地在一个组件上表示多个成员组件，使得在语法结构上更加清晰。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Form = MyFormComponent;</div><div class="line"></div><div class="line"><span class="keyword">var</span> App = (</div><div class="line">  &lt;Form&gt;</div><div class="line">    &lt;Form.Row&gt;</div><div class="line">      &lt;Form.Label /&gt;</div><div class="line">      &lt;Form.Input /&gt;</div><div class="line">    &lt;/Form.Row&gt;</div><div class="line">  &lt;/Form&gt;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<h4 id="JavaScript表达式"><a href="#JavaScript表达式" class="headerlink" title="JavaScript表达式"></a>JavaScript表达式</h4><ul>
<li><p>属性表达式<br>对于属性表达式，之前已经在语法规范中提到过了，要使用<code>JavaScript</code>表达式作为属性值，只需把这个表达式用一对大括号(<code>{}</code>)包起来即可。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = <span class="xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&#123;window.isLoggedIn</span> ? <span class="attr">window.name</span> <span class="attr">:</span> ''&#125; /&gt;</span>;</span></div></pre></td></tr></table></figure>
</li>
<li><p>Boolean属性<br>对于Boolean属性，省略一个属性的值会导致<code>JSX</code>把它当做<code>true</code>，要传值<code>false</code>必须使用属性表达式，通常会出现于使用<code>HTML</code>表单元素，含有属性如<code>disabled</code>, <code>required</code>, <code>checked</code>和<code>readOnly</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 在JSX中，对于禁用按钮这二者是相同的</div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">disabled</span> /&gt;</span>;</div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">disabled</span>=<span class="string">&#123;true&#125;</span> /&gt;</span>;</div><div class="line"></div><div class="line">// 在JSX中，对于不禁用按钮这二者是相同的</div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> /&gt;</span>;</div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">disabled</span>=<span class="string">&#123;false&#125;</span> /&gt;</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>子节点表达式<br>对于子节点表达式，同样可以在大括号内表示，比如<code>&lt;Nav /&gt;</code>和<code>&lt;Login /&gt;</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> content = <span class="xml"><span class="tag">&lt;<span class="name">Container</span>&gt;</span>&#123;window.isLoggedIn ? <span class="tag">&lt;<span class="name">Nav</span> /&gt;</span> : <span class="tag">&lt;<span class="name">Login</span> /&gt;</span>&#125;<span class="tag">&lt;/<span class="name">Container</span>&gt;</span></span>;</div></pre></td></tr></table></figure>
</li>
<li><p>如何添加注释<br><code>JSX</code>里添加注释很容易，它们只是<code>JavaScript</code>表达式而已，但需要小心的是，当在一个标签的子节点块时，要用<code>{}</code>包围要注释的部分。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> content = (</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Nav</span>&gt;</span></span></div><div class="line">    &#123;/* child comment, 用 &#123;&#125; 包围 */&#125;</div><div class="line">    <span class="tag">&lt;<span class="name">Person</span></span></div><div class="line">      /* 多</div><div class="line">         行</div><div class="line">         注释 */</div><div class="line">      <span class="attr">name</span>=<span class="string">&#123;window.isLoggedIn</span> ? <span class="attr">window.name</span> <span class="attr">:</span> ''&#125; // 行尾注释</div><div class="line">    /&gt;</div><div class="line">  <span class="tag">&lt;/<span class="name">Nav</span>&gt;</span></div><div class="line">);</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="JSX-DOM陷阱"><a href="#JSX-DOM陷阱" class="headerlink" title="JSX DOM陷阱"></a>JSX DOM陷阱</h4><ul>
<li><p>自定义HTML属性<br><code>React</code>不显示<code>HTML</code>规范里不存在的元素属性，若需要使用自定义属性，要加<code>data-</code>前缀。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-custom-attribute</span>=<span class="string">"foo"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>  而在自定义元素中<strong>任意</strong>的属性都是被支持的（在标签名里带有连接符或<code>is=&quot;...&quot;</code>属性的）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">x-my-component</span> <span class="attr">custom-attribute</span>=<span class="string">"foo"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>  以<code>aria-</code>开头的<a href="https://www.w3.org/WAI/intro/aria" target="_blank" rel="external">网络无障碍</a>属性可以正常使用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">aria-hidden</span>=<span class="string">&#123;true&#125;</span> /&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>HTML实体<br><code>HTML</code>实体可以插入到<code>JSX</code>的文本中，如果想在<code>JSX</code>表达式中显示<code>HTML</code>实体，会遇到二次转义的问题，因为<code>React</code>默认会转义所有字符串，为了防止各种 <acronym title="Cross Site Scripting">XSS</acronym> 攻击。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 正确，可以正常解析HTML</div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>First &amp;middot; Second<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">// 错误，不能解析，会直接显示“First &amp;middot; Second”</div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;'First &amp;middot; Second'&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>  但可以通过使用<a href="http://www.fileformat.info/info/unicode/char/b7/index.htm" target="_blank" rel="external">Unicode</a>字符解决，但需要确保文件是UTF-8编码，且网页也指定为UTF-8编码。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;'First \u00b7 Second'&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;'First ' + String.fromCharCode(183) + ' Second'&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>  可以在数组里混合使用字符串和<code>JSX</code>元素。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;['First ', <span class="tag">&lt;<span class="name">span</span>&gt;</span>&amp;middot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>, ' Second']&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="JSX运行与安全"><a href="#JSX运行与安全" class="headerlink" title="JSX运行与安全"></a>JSX运行与安全</h4><p><code>JSX</code>在运行时被加载元素类型，因此，元素类型不能是表达式，以下是错误的示例：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误，不能是表达式</span></div><div class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">components[props.storyType]</span> <span class="attr">story</span>=<span class="string">&#123;props.story&#125;</span> /&gt;</span>;</span></div></pre></td></tr></table></figure></p>
<p>但可以定义变量，但首字母须大写，如下格式是正确的示例：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> SpecificStory = components[props.storyType];</div><div class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SpecificStory</span> <span class="attr">story</span>=<span class="string">&#123;props.story&#125;</span> /&gt;</span>;</span></div></pre></td></tr></table></figure></p>
<p><code>JSX</code>可以防止注入攻击，在<code>React DOM</code>中，默认在渲染前会转义在<code>JSX</code>中的所有值，因此，可以保证不会被注入攻击，所有的内容都已经被转换为字符串进行渲染，同进也会防止跨站脚本攻击(<acronym title="Cross Site Scripting">XSS</acronym>)。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在JSX内嵌了用户输入，更加安全</span></div><div class="line"><span class="keyword">const</span> title = response.potentiallyMaliciousInput;</div><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div></pre></td></tr></table></figure></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>主要对<code>JSX</code>的基本概念、语法规范、在<code>React</code>中使用等方面进行了介绍并举例，在<code>React</code>中用法主要包括<code>JSX</code>命名规则、命名空间组件、<code>JavaScript</code>表达式、DOM陷阱以及运行与安全方面的介绍和示例。<br>通常，建议在你的编辑器中配置<code>Babel</code>语法体系，从而使得<code>ES6</code>和<code>JSX</code>代码都可以高亮显示。另外，可以到在线的 <a href="http://jsbin.com/qucecahako/1/edit?html,css,js,output" target="_blank" rel="external">JS BIN</a> 或 <a href="https://babeljs.io/repl/" target="_blank" rel="external">Babel REPL</a> 进行简单练习。</p>
<hr>
<p>References</p>
<ul>
<li><a href="https://facebook.github.io/jsx/" target="_blank" rel="external">Draft: JSX Specification</a></li>
<li><a href="http://buildwithreact.com/tutorial/jsx" target="_blank" rel="external">Tutorial: JSX</a></li>
<li><a href="https://facebook.github.io/react/docs/jsx-in-depth.html" target="_blank" rel="external">JSX In Depth</a></li>
<li><a href="https://chenyitian.gitbooks.io/react-docs/content/docs/02.1-jsx-in-depth.html" target="_blank" rel="external">深入 JSX</a></li>
<li><a href="https://chenyitian.gitbooks.io/react-docs/content/docs/ref-06-dom-differences.html" target="_blank" rel="external">DOM 的不同之处</a></li>
<li><a href="https://chenyitian.gitbooks.io/react-docs/content/docs/02.3-jsx-gotchas.html" target="_blank" rel="external">JSX 陷阱</a></li>
<li><a href="https://facebook.github.io/react/docs/introducing-jsx.html" target="_blank" rel="external">Introducing JSX</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/jsx.html" target="_blank" rel="external">JSX Introduction</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      JSX是一种类XML语言，是JavaScript的语法扩展，全称是JavaScript XML。React可以不使用JSX来编写组件，但是使用JSX可以让代码可读性更高、语义更清晰、对React元素进行抽象。
    
    </summary>
    
      <category term="Languages" scheme="https://blog.waterstrong.me/categories/Languages/"/>
    
    
      <category term="JSX" scheme="https://blog.waterstrong.me/tags/JSX/"/>
    
      <category term="JavaScript" scheme="https://blog.waterstrong.me/tags/JavaScript/"/>
    
      <category term="React" scheme="https://blog.waterstrong.me/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>如何创建Git服务器仓库</title>
    <link href="https://blog.waterstrong.me/git-server-repository/"/>
    <id>https://blog.waterstrong.me/git-server-repository/</id>
    <published>2017-02-15T14:35:49.000Z</published>
    <updated>2017-05-14T00:13:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>在使用Git时，通常会选择使用一个项目代码托管平台，这样的平台可以有很多选择，比如目前最流行的面向开源及私有软件项目的托管平台是<a href="https://github.com/" target="_blank" rel="external">GitHub</a>，还有一些其他优秀的平台，如Atlassian的<a href="https://bitbucket.org/" target="_blank" rel="external">Bitbucket</a>、<a href="https://gitlab.com" target="_blank" rel="external">GitLab</a>、<a href="https://coding.net" target="_blank" rel="external">Coding.NET</a>、开源中国的<a href="http://git.oschina.net/" target="_blank" rel="external">码云</a>、<a href="https://code.csdn.net/" target="_blank" rel="external">CSDN.NET</a>等，不仅可以使用Public和Private服务，还可以付费搭建定制服务，不过有些跑题了，本文中只关注使用简单的命令快速搭建共享服务器仓库。另外，关于Git的使用，可以参阅 <a href="/master-git">优雅地使用Git</a> 了解更多内容，这里也不会再涉及Git命令细节。</p>
<h2 id="创建服务器仓库"><a href="#创建服务器仓库" class="headerlink" title="创建服务器仓库"></a>创建服务器仓库</h2><p>先创建一个文件夹名为<code>demo.git</code>，在其中使用命令创建裸仓库(作为服务器仓库)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">git init --bare</div><div class="line"></div><div class="line"># &gt; ls</div><div class="line"># HEAD  branches  config  description  hooks  info  objects  refs</div><div class="line"></div><div class="line"># &gt; tree -a</div><div class="line">.</div><div class="line">├── HEAD 	# 指向当前所处的分支</div><div class="line">├── branches	# 包含的Git分支信息</div><div class="line">├── config	# Git仓库的配置文件</div><div class="line">├── description	# Git仓库的描述信息</div><div class="line">├── hooks	# 一些shell钩子脚本</div><div class="line">│   ├── applypatch-msg.sample</div><div class="line">│   ├── commit-msg.sample</div><div class="line">│   ├── post-update.sample</div><div class="line">│   ├── pre-applypatch.sample</div><div class="line">│   ├── pre-commit.sample</div><div class="line">│   ├── pre-push.sample</div><div class="line">│   ├── pre-rebase.sample</div><div class="line">│   ├── prepare-commit-msg.sample</div><div class="line">│   └── update.sample</div><div class="line">├── info	# 包含仓库的一些信息</div><div class="line">│   └── exclude</div><div class="line">├── objects	# Git仓库的所有对象</div><div class="line">│   ├── info</div><div class="line">│   └── pack</div><div class="line">└── refs 	# 标识分支指向的提交</div><div class="line">    ├── heads</div><div class="line">    └── tags</div></pre></td></tr></table></figure></p>
<p>与使用<code>git init</code>命令创建的目录不太一样，其中并没有<code>.git</code>目录，而是直接在工程目录下列出了其他的目录，并且可以查看到<code>config</code>中的内容<code>bare=true</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[core]</div><div class="line">	repositoryformatversion = 0</div><div class="line">	filemode = true</div><div class="line">	bare = true</div><div class="line">	ignorecase = true</div><div class="line">	precomposeunicode = true</div></pre></td></tr></table></figure></p>
<p>如果期望将普通的Git仓库转换为服务器仓库，可以使用如下命令进行转换，克隆出<code>.git</code>内容作为服务器仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone --bare xxx</div></pre></td></tr></table></figure></p>
<p>其中，bare仓库不包含工作区，目录中不包括项目源代码，不能直接在bare仓库上直接提交变更。</p>
<h2 id="连接服务器仓库"><a href="#连接服务器仓库" class="headerlink" title="连接服务器仓库"></a>连接服务器仓库</h2><p>假设在本地文件系统中创建，目录位置为<code>~/Documents/git-server/demo.git</code>，则可以使用以下命令克隆或关联服务器仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git clone ~/Documents/git-server/demo.git  # 直接clone代码，本地可不用加user@localhost</div><div class="line"></div><div class="line">git remote add origin ~/Documents/git-server/demo.git  # 或是添加为远程origin</div></pre></td></tr></table></figure></p>
<p>如果是使用AWS的EC2这样的服务，若文件目录位置为<code>/home/ec2-user/projects/git-repo.git</code>，服务器地址为<code>aws.waterstrong.me</code>，用户名为<code>ec2-user</code>，则同样可以克隆或关联远程仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git clone ec2-user@aws.waterstrong.me:/home/ec2-user/projects/git-repo.git  # 直接clone</div><div class="line"></div><div class="line">git remote add origin ec2-user@aws.waterstrong.me:/home/ec2-user/projects/git-repo.git  # 或添加origin</div></pre></td></tr></table></figure></p>
<p>在创建bare仓库时，可以在给文件目录命名时加上<code>.git</code>后缀，也符合平常使用Git地址的习惯，这样，就可以像平常一样使用Git操作了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>平时在使用<code>git init</code>命令时，是初始化一个普通的Git本地仓库，而为了创建服务器仓库，可以使用<code>git init --bare &lt;repo&gt;</code>命令，bare仓库没有工作区，不能对其直接提交变更，但可以被正常地clone, push, pull等操作。</p>
<hr>
<p>References</p>
<ul>
<li><a href="https://git-scm.com/docs/git-init" target="_blank" rel="external">git document</a></li>
<li><a href="http://www.saintsjd.com/2011/01/what-is-a-bare-git-repository/" target="_blank" rel="external">What is a bare git repository?</a></li>
<li><a href="https://about.gitlab.com/downloads/" target="_blank" rel="external">GitLab CE Package</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      在使用Git时，通常会选择使用一个项目代码托管平台，这样的平台可以有很多选择，如GitHub、Bitbucket、GitLab、Coding.NET、OSChina.NET、CSDN.NET等，不过，本文中只关注使用简单的Git命令快速搭建共享服务器仓库。
    
    </summary>
    
      <category term="Tools" scheme="https://blog.waterstrong.me/categories/Tools/"/>
    
    
      <category term="Git" scheme="https://blog.waterstrong.me/tags/Git/"/>
    
      <category term="VCS" scheme="https://blog.waterstrong.me/tags/VCS/"/>
    
      <category term="Repository" scheme="https://blog.waterstrong.me/tags/Repository/"/>
    
  </entry>
  
  <entry>
    <title>如何从SVN迁移源码到Git仓库</title>
    <link href="https://blog.waterstrong.me/svn-to-git-migration/"/>
    <id>https://blog.waterstrong.me/svn-to-git-migration/</id>
    <published>2017-02-10T14:51:30.000Z</published>
    <updated>2017-03-30T12:06:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>这里就不再赘述关于SVN与Git的区别以及为什么要迁移源码到Git了，毕竟Git是当前的主流DVCS了，而且已经公认地非常好用，如果你还在使用SVN的话该考虑换了，是时候迁移那些遗留代码了，有兴趣可以参阅 <a href="https://www.atlassian.com/git/tutorials/why-git" target="_blank" rel="external">Why Git</a> 和 <a href="https://www.atlassian.com/git/tutorials/perforce-git" target="_blank" rel="external">Perforce to Git</a> 了解更多。通常来说，在项目开发过程中，难免会遇到一些老项目代码正被SVN管理着，但基于当下诸多原因，或是扩展开发，或是战略转移，或是为了更好地开发体验，需要将这些在维护的遗留项目源码迁移为Git管理。那如何有效地迁移源码？并且如何保留提交记录、分支记录以及开发成员等信息呢？笔者前一段时间就经历了这样的迁移工作，还是有必要分享一下，也算是一种总结了。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>迁移SVN源码到Git仓库的方法肯定不是暴力地将代码Copy再Paste到Git仓库，也不是直接在项目下git init初始化仓库的，而是应该使用<a href="https://git-scm.com/docs/git-svn" target="_blank" rel="external">git svn</a>命令操作实现迁移工作。那git-svn命令如何使用？有哪些注意事项呢？</p>
<p>首先，在正式开始迁移项目之前，需要做一些准备工作：</p>
<ol>
<li>准备一台安装有最新Git环境的磁盘容量足的电脑</li>
<li>已经获知Git仓库的远程地址，无论是自己创建还是团队提供</li>
<li>确保对Git远程仓库有读写权限，无论通过用户名密码还是SSH访问都行</li>
<li>准备一份开发者的SVN用户名到Git全名+邮件的映射关系列表文件authors.txt，格式为：<code>loginname = Username &lt;user@example.com&gt;</code></li>
</ol>
<p>由于SVN对每次提交只记录开发者的用户名，而Git存储其全名和邮件地址，这意味着需要对开发者信息进行映射转换，在准备<code>authors.txt</code>文件时，可以到团队系统数据库直接查询开发者<em>登录名、用户名和邮件地址</em>并拼接成指定的格式，或者可下载<em>Atlassian</em>的工具包<a href="https://bitbucket.org/atlassian/svn-migration-scripts/downloads" target="_blank" rel="external">svn-migration-scripts.jar</a>，通过命令拉取SVN仓库的用户并生成对应的开发者信息映射文件，需要Java运行时环境支持：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar svn-migration-scripts.jar authors https://svn.example.com &gt; authors.txt</div></pre></td></tr></table></figure></p>
<h2 id="转换仓库"><a href="#转换仓库" class="headerlink" title="转换仓库"></a>转换仓库</h2><p>准备工作完成后可以开始实施转移仓库了，应该注意的是，在转移SVN项目时需要根据是否是标准的SVN文件布局来确定命令行的参数。（注：以下所有示意图均来自Atlassian）</p>
<h4 id="标准的SVN文件布局"><a href="#标准的SVN文件布局" class="headerlink" title="标准的SVN文件布局"></a>标准的SVN文件布局</h4><p><img src="/assets/master-git/standard_svn_repo.png" alt=""><br>如果SVN仓库使用标准的了<code>/trunk</code>, <code>/branches</code>和<code>/tags</code>的目录结构，就可在运行命令时加上参数<code>--stdlayout</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git svn clone --stdlayout --authors-file=authors.txt &lt;svn-repo&gt;/&lt;project&gt; &lt;git-repo-name&gt;</div><div class="line"></div><div class="line">git svn clone --stdlayout --authors-file=authors.txt https://svn.waterstrong.com/demo demo</div></pre></td></tr></table></figure></p>
<h4 id="非标准的的SVN文件布局"><a href="#非标准的的SVN文件布局" class="headerlink" title="非标准的的SVN文件布局"></a>非标准的的SVN文件布局</h4><p><img src="/assets/master-git/nonstandard_svn_repo.png" alt=""><br>如果SVN仓库是非标准的目录布局，那就需要分别显示指定参数<code>--trunk, --branches, --tags</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git svn clone --trunk=/trunk --branches=/branches --branches=/bugfixes --tags=/tags --authors-file=authors.txt &lt;svn-repo&gt;/&lt;project&gt; &lt;git-repo-name&gt;</div></pre></td></tr></table></figure></p>
<h4 id="Authors文件的使用"><a href="#Authors文件的使用" class="headerlink" title="Authors文件的使用"></a>Authors文件的使用</h4><ul>
<li><code>--authors-file</code>：在之前的命令中已经提到需要添加参数<code>--authors-file=&lt;filename&gt;</code>读取开发者信息映射文件，文件内容格式为<code>loginname = Username &lt;user@example.com&gt;</code>，但如果在文件中不存SVN某个用户名的对应关系，那么git svn操作会被自动中止，因此，必须在<code>authors.txt</code>文件中添加丢失的用户对应关系，然后重新运行git svn命令即可。配置其git config时的key为<code>svn.authorsfile</code>。</li>
<li><code>--authors-prog</code>：但如果希望在使用authors.txt文件时，即使某个SVN用户名对应关系不存在，命令也可以执行成功并自动使用默认值，可以使用该参数<code>--authors-prog=&lt;filename&gt;</code>。配置其git config时的key为<code>svn.authorsProg</code>，另外，可以在<a href="https://www.atlassian.com/git/tutorials/migrating-synchronize" target="_blank" rel="external">Tutorials - Synchronize</a>中找到关于authors文件的更多使用信息。</li>
</ul>
<h4 id="大仓库的转换策略"><a href="#大仓库的转换策略" class="headerlink" title="大仓库的转换策略"></a>大仓库的转换策略</h4><p>特别注意的是，当SVN仓库非常非常大时，据官方统计数据，若转换拥有33000个提交的400MB大小的仓库需要花12个小时来完成转换。因此，在这种情况下，可以选择找一台机器，运行命令后就不管了直到完成转换为止，或者是选择放弃保存非常老的提交历史记录，这样可以加速转换过程，如果转换时只保留部分提交历史的话可以使用以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git svn clone -r$&#123;REVNUMBER&#125;:HEAD --stdlayout --authors-file=authors.txt &lt;svn-repo&gt;/&lt;project&gt; &lt;git-repo-name&gt;</div><div class="line"></div><div class="line">git svn clone -r19698:HEAD --stdlayout --authors-file=authors.txt https://svn.waterstrong.com/demo demo</div></pre></td></tr></table></figure></p>
<h2 id="清理仓库"><a href="#清理仓库" class="headerlink" title="清理仓库"></a>清理仓库</h2><p>至此，SVN到Git的转换工作接近尾声，如果只是关注 <strong>trunk</strong> 和 <strong>master</strong> 主分支，那么可以不用在意清理仓库这一部分的内容了，可以直接跳过进入下一节，如果需要清理并将分支和标签进行本地化，则可以关注一下本节内容。</p>
<p>对于SVN的分支和标签，转换操作是不会将其导入到新的Git仓库中，而且在Git分支中也找不到SVN的分支branch，也找不到对应的标签tag，不过可以使用命令<code>git branch -r</code>可以查看到所有SVN的分支和标签，这是因为在使用<code>git svn clone</code>命令时会将SVN的分支和标签导入为Git的远程分支和标签，如下示意图所示。<br><img src="/assets/master-git/repo_structure.jpg" alt=""></p>
<p>该策略主要是为SVN与Git双向同步服务的，但通常SVN单向转换到Git后都会直接使用Git了，并且会禁止SVN提交了，所以还是会对分支和标签内容进行清理以转换为Git的分支和标签。可以使用Atlassian提供的脚本工具快速实现对仓库分支和标签的清理工作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -Dfile.encoding=utf-8 -jar svn-migration-scripts.jar clean-git --force</div></pre></td></tr></table></figure></p>
<p>将SVN分支和标签转换Git的本地分支和标签后结构如下图所示：<br><img src="/assets/master-git/local_git_repo.png" alt=""></p>
<h2 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h2><p>完成以上步骤后，迁移工作基本完成，接下来需要根据项目代码性质、团队约定等情况做一些收尾工作，需要具体情况具体分析。这里会以一个Gradle构建的Java项目(IDE使用IntelliJ)为例介绍从SVN迁移到Git后的收尾工作：</p>
<ol>
<li><p>查看Git远程地址是否已经配置了，如果还没有配置，可以使用命令<code>git remote</code>命令配置<code>origin</code>，比较常用的两组命令为：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git remote add origin xxx  # 添加新的远程地址</div><div class="line">git remote set-url origin xxx  # 修改origin的远程地址</div></pre></td></tr></table></figure>
</li>
<li><p>使用命令<code>git update-index</code>配置构建工具的执行权限，如果有其他执行脚本也需要配置相应权限信息：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git update-index --chmod=+x gradlew</div><div class="line">git update-index --chmod=+x gradlew.bat</div><div class="line">git update-index --chmod=+x xxx.sh</div></pre></td></tr></table></figure>
</li>
<li><p>添加<code>.gitignore</code>文件，根据不同的项目写入要忽略的文件，如Java项目ignore文件会包括：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/out</div><div class="line">/build</div><div class="line">/.idea</div><div class="line">.gradle</div><div class="line">.DS_Store</div><div class="line">*.iml</div><div class="line">*.ipr</div><div class="line">*.iws</div></pre></td></tr></table></figure>
</li>
<li><p>更新IDE的vcs配置为Git而非Svn，在<code>build.gradle</code>文件修改vcs配置：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">idea.project.vcs = &quot;Git&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>最后上传到Repo，并根据团队内部的约定设置相应的权限，通常会有一个检查清单，比如：</p>
<ul>
<li>设置分支模型</li>
<li>添加分支权限</li>
<li>限定PR合并权限</li>
<li>配置SVN提交通知</li>
<li>变更CI拉取代码地址</li>
<li>……</li>
</ul>
</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总得来说，从SVN迁移源码到Git仓库包括：准备工作、转换仓库、清理仓库以及收尾工作，其中清理仓库部分可以跳过，其他部分是需要完成的，还必须注意SVN文件布局以及正确地使用authors文件，同时，要考虑在遇到大仓库时应根据实际情况采用相对适合的迁移策略，最后，应遵循团队的约定，对照检查清单完成所有收尾工作。</p>
<hr>
<p>References</p>
<ul>
<li><a href="https://www.atlassian.com/git/tutorials/migrating-convert" target="_blank" rel="external">Migrate to Git from SVN</a></li>
<li><a href="https://git-scm.com/docs/git-svn" target="_blank" rel="external">git-svn docs</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      在项目开发过程中，难免会遇到老项目的代码是被SVN管理的，但基于当下诸多原因，或是扩展开发，或是战略转移，或是为了更好地开发体验，需要将这些在维护的遗留项目源码迁移为Git管理。那如何有效地迁移源码并保留历史记录呢？
    
    </summary>
    
      <category term="Tools" scheme="https://blog.waterstrong.me/categories/Tools/"/>
    
    
      <category term="Git" scheme="https://blog.waterstrong.me/tags/Git/"/>
    
      <category term="VCS" scheme="https://blog.waterstrong.me/tags/VCS/"/>
    
      <category term="SVN" scheme="https://blog.waterstrong.me/tags/SVN/"/>
    
  </entry>
  
</feed>
